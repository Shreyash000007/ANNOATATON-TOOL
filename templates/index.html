<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>PDF Annotations | Dashboard</title>
    <!-- Google Font: Source Sans Pro -->
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="../assets/plugins/fontawesome-free/css/all.min.css">

    <!-- Tempusdominus Bootstrap 4 -->
    <link rel="stylesheet" href="../assets/plugins/tempusdominus-bootstrap-4/css/tempusdominus-bootstrap-4.min.css">
    <!-- Theme style -->
    <link rel="stylesheet" href="../assets/css/main.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.2.4/fabric.min.js"></script>

    <link rel="stylesheet" href="/static/css/pdf.css">



</head>

<body class="hold-transition sidebar-collapse layout-footer-fixed">
    <div class="wrapper">

        <!-- Navbar -->
        <nav class="main-header navbar navbar-expand navbar-white navbar-light text-sm">
            <!-- Left navbar links -->
            <ul class="navbar-nav">

                <li class="nav-item">
                    <a href="" class=""><img src="../assets/img/ann-Gray-logo_2.png" alt="img" height="40"></a>
                </li>

            </ul>

            <!-- Right navbar links -->
            <ul class="navbar-nav ml-auto">

                <li class="nav-item">
                    <a class="nav-link" data-widget="fullscreen" href="#" role="button">
                        <i class="fas fa-expand-arrows-alt"></i>
                    </a>
                </li>

            </ul>
        </nav>

        <!-- /.navbar -->

        <!-- Main Sidebar Container -->
        <aside class="main-sidebar elevation-4 sidebar-light-navy">
            <!-- Brand Logo -->
            <a href="" class="brand-link">
                <img src="../assets/img/logo.png" alt="Logo" class="brand-image img-circle elevation-3"
                    style="opacity: .8">
                <span class="brand-text font-weight-light">PDF</span>
            </a>

            <!-- Sidebar -->
            <div class="sidebar">
                <!-- Sidebar user panel (optional) -->
                <div class="user-panel mt-3 pb-3 mb-3 d-flex">
                    <div class="image">
                        <img src="../assets/img/user2-160x160.jpg" class="img-circle elevation-2" alt="User Image">
                    </div>
                    <div class="info">
                        <a href="#" class="d-block">Vaibhav Barsagade</a>
                    </div>
                </div>



                <!-- Sidebar Menu -->
                <nav class="mt-2">
                    <ul class="nav nav-pills nav-sidebar flex-column nav-compact" data-widget="treeview" role="menu"
                        data-accordion="false">
                        <!-- Add icons to the links using the .nav-icon class
                         with font-awesome or any other icon font library -->

                        <li class="nav-item menu-open">
                            <a href="#" class="nav-link active">
                                <i class="nav-icon fas fa-tachometer-alt"></i>
                                <p>
                                    Admin Menu
                                    <i class="right fas fa-angle-left"></i>
                                </p>
                            </a>
                            <ul class="nav nav-treeview">
                                <li class="nav-item">
                                    <a href="index.html" class="nav-link active">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>Create Employee</p>
                                    </a>
                                </li>
                                <li class="nav-item">
                                    <a href="starter.html" class="nav-link">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>View Employee</p>
                                    </a>
                                </li>
                                <li class="nav-item">
                                    <a href="" class="nav-link">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>Follow Up Check</p>
                                    </a>
                                </li>
                            </ul>
                        </li>

                        <li class="nav-item">
                            <a href="#" class="nav-link">
                                <i class="nav-icon fas fa-chart-pie"></i>
                                <p>
                                    Road Services
                                    <i class="right fas fa-angle-left"></i>
                                </p>
                            </a>
                            <ul class="nav nav-treeview">
                                <li class="nav-item">
                                    <a href="" class="nav-link">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>HighTea</p>
                                    </a>
                                </li>
                                <li class="nav-item">
                                    <a href="" class="nav-link">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>SideHigh</p>
                                    </a>
                                </li>
                                <li class="nav-item">
                                    <a href="" class="nav-link">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>Inline</p>
                                    </a>
                                </li>
                                <li class="nav-item">
                                    <a href="" class="nav-link">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>uPlot</p>
                                    </a>
                                </li>
                            </ul>
                        </li>

                    </ul>
                </nav>
                <!-- /.sidebar-menu -->
            </div>
            <!-- /.sidebar -->
        </aside>

        <!-- Content Wrapper. Contains page content -->
        <div class="content-wrapper">
            <section class="content mt-2">
                <div class="container-fluid">

                    <div class="row">
                        <div class="col-md-12">
                            <div class="card shadow-none mb-1">
                                <div class="card-body p-2">
                                    <div class="row">
                                        <div class="col-lg-2">
                                            <div class="custom-file">
                                                <!-- <input type="file" id="file-input" class="custom-file-input"
                                                    accept="application/pdf" />
                                                <label class="custom-file-label" for="customFile">Choose file</label> -->
                                            </div>
                                        </div>
                                        <div class="col-lg-10">
                                            <div class="btn-group">

                                                <button onclick="toggleThumbnails()" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="ThumbNail!">
                                                    <i class="fas fa-list"></i>
                                                </button>

                                                <button onclick="prevPage()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="ThumbNail!">
                                                    <i class="fas fa-step-backward"></i>
                                                </button>
                                                <button type="button" class="btn btn-default" data-toggle="tooltip"
                                                    data-placement="top" title="ThumbNail!">
                                                    <i class="fas fa-chevron-left"></i>
                                                </button>
                                                <button type="button" class="btn btn-default" data-toggle="tooltip"
                                                    data-placement="top" title="ThumbNail!">
                                                    <i class="fas fa-chevron-right"></i>
                                                </button>
                                                <button onclick="nextPage()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="ThumbNail!">
                                                    <i class="fas fa-step-forward"></i>
                                                </button>
                                                <div id="page-num" class="btn btn-default"
                                                    style="pointer-events: none;">1</div>

                                            </div>
                                            <div class="btn-group">
                                                <button onclick="zoomOut()" id="zoom-out" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="Zoom In">
                                                    <i class="fas fa-search-minus"></i>
                                                </button>
                                                <button type="button" class="btn btn-default">
                                                    <div id="zoom-percent">0</div>
                                                </button>
                                                <button onclick="zoomIn()" id="zoom-in" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="Zoom Out">
                                                    <i class="fas fa-search-plus"></i>
                                                </button>
                                                <button onclick="zoomReset()" id="zoom-reset" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="Zoom Reset">
                                                    <i class="fas fa-sync-alt"></i>
                                                </button>
                                            </div>
                                            <div class="btn-group">
                                                <button onclick="addSquare()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Draw Square">
                                                    <i class="far fa-square"></i>
                                                </button>
                                                <button onclick="addLine()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Draw Line">
                                                    <i class="fas fa-slash"></i>
                                                </button>
                                                <button onclick="addCircle()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Draw Circle">
                                                    <i class="far fa-circle"></i>
                                                </button>
                                                <button onclick="addFreeDraw()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Free Draw">
                                                    <i class="fas fa-edit"></i>
                                                </button>
                                                <button onclick="addCloudAnnotation()" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="Draw Cloud">
                                                    <i class="fas fa-cloud"></i>
                                                </button>
                                                <button onclick="addText()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Add Text">
                                                    <i class="fas fa-text-width"></i>
                                                </button>
                                                <button onclick="addArrowTextCallout()" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="Arrow Text Callout">
                                                    <i class="fas fa-comment-alt ml-1"></i>
                                                </button>
                                                <select id="stampSelect" class="">
                                                    <option value="approve">Approve</option>
                                                    <option value="notApprove">Rejected</option>
                                                    <!-- <option value="right">Right</option>
                                                    <option value="wrong">Wrong</option> -->
                                                </select>
                                                <button onclick="addSelectedStamp()" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="Add Stamp">
                                                    <i class="fas fa-stamp"></i>
                                                </button>
                                                <button onclick="openSignatureCanvas()" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="Draw Signature">
                                                    <i class="fas fa-signature"></i>
                                                </button>
                                                <button id="highlight" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Add Highlighter">
                                                    <i class="fas fa-highlighter"></i>
                                                </button>
                                                <button id="underline" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Add Underline">
                                                    <i class="fas fa-underline"></i>
                                                </button>
                                                <button id="strikeout" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top"
                                                    title="Add strikethrough">
                                                    <i class="fas fa-strikethrough"></i>
                                                </button>
                                                <button onclick="toggleFullScreen()" type="button"
                                                    class="btn btn-default fullscreen-btn" data-toggle="tooltip"
                                                    data-placement="top" title="Enter full-screen (F11)"
                                                    data-shortcut="F11">
                                                    <i class="fas fa-expand"></i>
                                                </button>
                                            </div>
                                            <div class="btn-group">
                                                <button onclick="undo()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Undo">
                                                    <i class="fas fa-undo"></i>
                                                </button>
                                                <button onclick="redo()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Redu">
                                                    <i class="fas fa-redo"></i>
                                                </button>
                                                <!-- <button id="delete-annotation-btn" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Delete">
                                                    <i class="fas fa-trash"></i>
                                                </button> -->

                                            </div>
                                            <div class="btn-group">
                                                <!-- <button type="button" class="btn btn-default" data-toggle="tooltip"
                                                    data-placement="top" title="Expand">
                                                    <i class="fas fa-expand"></i>
                                                </button> -->
                                            </div>
                                            <div class="btn-group">
                                                <!-- <button type="button" class="btn btn-default" data-toggle="tooltip"
                                                    data-placement="top" title="Print">
                                                    <i class="fas fa-print"></i>
                                                </button> -->
                                                <button onclick="save()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Save PDF">
                                                    <i class="fas fa-download"></i>
                                                </button>
                                            </div>
                                            <div class="btn-group">
                                                <button onclick="fitToWidth()" title="Fit to Width" type="button"
                                                    class="btn btn-default">
                                                    <i class="fas fa-arrows-alt-h"></i>
                                                </button>
                                                <button onclick="fitToHeight()" title="Fit to Height" type="button"
                                                    class="btn btn-default">
                                                    <i class="fas fa-arrows-alt-v"></i>
                                                </button>
                                                <div class="btn-group">
                                                    <button id="select-mode" type="button" class="btn btn-default"
                                                        data-toggle="tooltip" title="Select Mode">
                                                        <i class="fas fa-mouse-pointer"></i>
                                                    </button>
                                                    <button id="pan-mode" type="button" class="btn btn-default"
                                                        data-toggle="tooltip" title="Pan Mode">
                                                        <i class="fas fa-hand-paper"></i>
                                                    </button>
                                                </div>
                                                <button id="toggleSidebarBtn" title="Comments" type="button"
                                                    class="btn btn-default">
                                                    <i class="fas fa-comments"></i>
                                                </button>

                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="card bgPDFViewer shadow-none">
                                <div class="card-body p-0">

                                    <div class="row">
                                        <div class="col-lg-3">
                                            <div class="card-body p-1">
                                                <div id="thumbnail-container" style="display: none;">
                                                    <div id="thumbnails"></div>
                                                </div>

                                                <div id="thumbnail-container" style="display: none;">
                                                    <div id="thumbnails"></div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="col-lg-9">
                                            <div class="card-body p-1">
                                                <div id="pdf-container">
                                                    <canvas id="pdf-canvas"></canvas>
                                                    <canvas id="fabric-canvas"></canvas>
                                                    <canvas id="annotation-canvas"></canvas>
                                                    <!-- Canvas for annotations -->
                                                    <div id="text-layer"></div>
                                                </div>

                                                <!-- <div class="row ">
                                                    <div class="col-lg-12">
                                                        <input type="checkbox" id="toggle-selection"> Enable Annotation
                                                        Selection <span>Page: <span id="page-num">1</span> / <span
                                                                id="page-count">0</span></span>
                                                    </div>
                                                </div> -->

                                            </div>

                                        </div>
                                    </div>

                                </div>
                            </div>
                        </div>

                    </div>

                </div>

            </section>
            <section>
                <div id="annotationModal" class="modal">
                    <div class="modal-content">
                        <h2 style="font-size: 1rem;">Add Annotation Details</h2>
                        <span class="close-button">&times;</span>
                        <form id="annotationForm">
                            <label for="content">Content:</label>
                            <textarea id="content" name="content" placeholder="Enter content" required></textarea>
                            <button type="submit">Save</button>
                        </form>
                    </div>
                </div>
            </section>

            <div id="sidebar"
                style="display: none; width: 250px; position: absolute; top: 127; right: 39; background-color: #f1f1f1; padding: 15px; height: 100%; overflow-y: auto; box-shadow: -2px 0px 5px rgba(0, 0, 0, 0.2);">
                <h2>Annotations</h2>
                <div id="annotationList"></div>
            </div>

        </div>
        <!-- /.content-wrapper -->
        <footer class="main-footer text-sm">
            <strong>&copy; 2023 <a href="">PDF System</a>.</strong>
            All rights reserved.
            <div class="float-right d-none d-sm-inline-block">
                <b>Version</b> 3.2.0
            </div>
        </footer>

        <!-- Control Sidebar -->
        <aside class="control-sidebar control-sidebar-dark">
            <div class="p-3 control-sidebar-content">

            </div>
        </aside>
        <!-- /.control-sidebar -->
    </div>


    <!-- ./wrapper -->


    <script>
        let pdfDoc = null;
        let pageNum = 1;
        const pdfCanvas = document.getElementById('pdf-canvas');
        const fabricCanvasElement = document.getElementById('fabric-canvas');
        const textLayer = document.getElementById('text-layer');
        const pdfContext = pdfCanvas.getContext('2d');
        const fabricCanvas = new fabric.Canvas(fabricCanvasElement, {
            selection: true,
            selectionColor: 'rgba(0, 0, 0, 0)',
            selectionBorderColor: 'rgba(0, 0, 0, 0)',
            selectionLineWidth: 0
        });
        let redoStack = [];
        let annotationsByPage = {};
        let isDrawing = false;
        let startX, startY;
        let currentAnnotation = null;
        let isFreeDrawEnabled = false;
        const textLayerAdjustments = {};
        const thumbnailsContainer = document.getElementById("thumbnails");
        const thumbnailContainer = document.getElementById("thumbnail-container");
        let currentPageNum = 1;

        let isPanning = false;
        let scrollLeft, scrollTop;
        let velocityX = 0, velocityY = 0;
        let momentumActive = false;

        document.getElementById('select-mode').addEventListener('click', enableSelectMode);
        document.getElementById('pan-mode').addEventListener('click', enablePanMode);

        const pdfContainer = document.getElementById('pdf-container');
        const handCursor = document.createElement("div");
        handCursor.classList.add("hand-cursor");
        document.body.appendChild(handCursor);

        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                cancelAnnotation();
            }
        });

        function cancelAnnotation() {
            // console.log("ESC pressed! Switching to Select Mode.");
            window.getSelection().removeAllRanges();
            annotationMode = null;

            fabricCanvas.isDrawingMode = false;
            isDrawing = false;
            enableSelectMode();
        }

        function enableSelectMode() {
            showToast('Select mode enabled');
            enableTextLayer();
            isPanning = false;
            fabricCanvas.selection = true;
            fabricCanvas.forEachObject(obj => obj.selectable = true);
            fabricCanvas.defaultCursor = 'default';
            // console.log("Entered Select Mode");
            pdfContainer.style.cursor = 'default';
            handCursor.style.display = "none";
        }

        function enablePanMode() {
            showToast('Pan mode enabled');
            disableTextLayer();
            isPanning = true;

            Object.values(fabricCanvases).forEach(canvas => {
                disableTextLayer();
                canvas.selection = false;
                canvas.forEachObject(obj => obj.selectable = false);
                canvas.defaultCursor = 'grab';
            });

            pdfContainer.style.cursor = 'grab';
            document.querySelectorAll('.pdf-canvas, .fabric-canvas, .annotation-canvas').forEach(canvas => {
                canvas.style.cursor = 'grab';
            });

            console.log("Entered Pan Mode");
        }




        pdfContainer.addEventListener('mousedown', (e) => {

            if (!isPanning) return;

            startX = e.clientX;
            startY = e.clientY;
            scrollLeft = pdfContainer.scrollLeft;
            scrollTop = pdfContainer.scrollTop;
            pdfContainer.style.cursor = 'grabbing';
            document.querySelectorAll('.pdf-canvas, .fabric-canvas, .annotation-canvas').forEach(canvas => {
                canvas.style.cursor = 'grabbing';
            });

            Object.values(fabricCanvases).forEach(canvas => {
                canvas.defaultCursor = 'grabbing';
            });

            let lastX = startX;
            let lastY = startY;
            velocityX = 0;
            velocityY = 0;
            momentumActive = false;

            function onMouseMove(e) {

                if (!isPanning) return;

                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;

                velocityX = dx * 0.7;
                velocityY = dy * 0.7;

                pdfContainer.scrollLeft -= dx;
                pdfContainer.scrollTop -= dy;

                lastX = e.clientX;
                lastY = e.clientY;
            }

            function onMouseUp() {

                pdfContainer.style.cursor = 'grab';
                document.querySelectorAll('.pdf-canvas, .fabric-canvas, .annotation-canvas').forEach(canvas => {
                    canvas.style.cursor = 'grab';
                });
                Object.values(fabricCanvases).forEach(canvas => {
                    canvas.defaultCursor = 'grab';
                });
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                applyMomentum();
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        function applyMomentum() {

            if (momentumActive) return;
            momentumActive = true;

            function step() {
                if (Math.abs(velocityX) < 0.1 && Math.abs(velocityY) < 0.1) {
                    momentumActive = false;
                    return;
                }

                pdfContainer.scrollLeft -= velocityX;
                pdfContainer.scrollTop -= velocityY;

                velocityX *= 0.95;
                velocityY *= 0.95;

                requestAnimationFrame(step);
            }

            requestAnimationFrame(step);
        }


        fabricCanvas.on('mouse:down', function () {
            if (isDrawing) {
                document.addEventListener('keydown', function (event) {
                    if (event.key === 'Escape') {
                        cancelAnnotation();
                    }
                });
            }
        });


        const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
        const sidebar = document.getElementById('sidebar');

        toggleSidebarBtn.addEventListener('click', () => {
            if (sidebar.style.display === 'none' || sidebar.style.display === '') {
                sidebar.style.display = 'block';
            } else {
                sidebar.style.display = 'none';
            }
        });

        function openAnnotationModal(annotation) {
            if (!annotation) {
                console.error("Invalid annotation passed to openAnnotationModal.");
                return;
            }
            currentAnnotation = annotation;

            // document.getElementById('title').value = annotation.title || '';
            // document.getElementById('subject').value = annotation.subject || '';
            // document.getElementById('content').value = annotation.content || '';

            document.getElementById('content').value = '';


            console.log("Opening modal with annotation:", annotation);

            document.getElementById('annotationModal').style.display = "block";
        }

        function closeAnnotationModal() {
            // Send default content when modal is closed without saving
            // if (currentAnnotation) {
            //     const defaultContent = `This is a ${currentAnnotation.type} annotation`;
            //     currentAnnotation.content = defaultContent;

            //     const sessionCommentId = generateGuid();
            //     const backendData = {
            //         DocumentId: sessionDocumentId,
            //         CommentList: [{
            //             UserId: sessionUserId,
            //             Comments: defaultContent,
            //             Remark: "Empty",
            //             CommentDate: new Date().toISOString(),
            //             AnnotationType: currentAnnotation.type,
            //             PageNumber: currentAnnotation.page.toString(),
            //             Id: sessionCommentId,
            //             UserName: "Anurag Sable"
            //         }]
            //     };

            //     console.log("Sending default annotation to backend:", backendData);
            //     sendAnnotationToBackend(backendData);
            updateSidebar(currentAnnotation);
            // }

            document.getElementById('annotationModal').style.display = "none";
            currentAnnotation = null;
        }

        function saveAnnotationDetails(event) {
            event.preventDefault();

            if (!currentAnnotation) {
                console.error("currentAnnotation is null or undefined!");
                return;
            }

            // const title = document.getElementById('title').value;
            // const subject = document.getElementById('subject').value;
            const content = document.getElementById('content').value;

            console.log("Content:", content);

            const finalContent = content.trim() || `This is a ${currentAnnotation.type} annotation`;
            currentAnnotation.content = finalContent;

            // currentAnnotation.title = title;
            // currentAnnotation.subject = subject;
            currentAnnotation.content = content;

            console.log("Updated Annotation:", currentAnnotation);


            // if (!currentAnnotation.id) {
            //     console.error("Annotation ID is missing!");
            //     return;
            // }
            // const sessionCommentId = generateGuid();
            // const backendData = {
            //     DocumentId: sessionDocumentId,
            //     CommentList: [{
            //         UserId: sessionUserId,
            //         Comments: content,
            //         Remark: "Empty",
            //         CommentDate: new Date().toISOString(),
            //         AnnotationType: currentAnnotation.type,
            //         PageNumber: currentAnnotation.page.toString(),
            //         Id: sessionCommentId,
            //         UserName: "Anurag Sable"
            //     }]
            // };

            // console.log("Sending updated annotation to backend:", backendData);
            // sendAnnotationToBackend(backendData);

            //For Send Annotation to Backend directly after adding annotations 


            updateSidebar(currentAnnotation);
            document.getElementById('annotationModal').style.display = "none";
            currentAnnotation = null;
        }

        document.querySelector('.close-button').addEventListener('click', function (event) {
            event.preventDefault();
            closeAnnotationModal();
        });
        document.getElementById('annotationForm').addEventListener('submit', saveAnnotationDetails);

        function updateSidebar(annotation) {
            console.log("Updating Sidebar with Annotation:", annotation);

            if (!annotation || !annotation.id) {
                console.error("Invalid annotation passed to updateSidebar.");
                return;
            }

            const annotationList = document.getElementById("annotationList");
            let annotationItem = document.getElementById(`annotation-${annotation.id}`);

            if (!annotationItem) {
                annotationItem = document.createElement("div");
                annotationItem.id = `annotation-${annotation.id}`;
                annotationItem.classList.add("annotation-item");
                annotationList.appendChild(annotationItem);

                if (annotationList.firstChild) {
                    annotationList.insertBefore(annotationItem, annotationList.firstChild);
                } else {
                    annotationList.appendChild(annotationItem);
                }

                // annotationItem.addEventListener("click", function(event) {
                //     if (!event.target.matches('.btn-delete, .btn-edit')) {
                //         if (annotation.type === 'highlight' || annotation.type === 'underline' || annotation.type === 'strikeout') {
                //             selectTextAnnotation(annotation);
                //         } else {
                //             selectAnnotation(annotation);
                //         }
                //     }
                // });
            }
            const timestamp = new Date().toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });

            let annotationIcon = '';
            switch (annotation.type) {
                case 'cloud':
                    annotationIcon = '<i class="fas fa-cloud"></i>';
                    break;
                case 'circle':
                    annotationIcon = '<i class="far fa-circle"></i>';
                    break;
                case 'square':
                    annotationIcon = '<i class="far fa-square"></i>';
                    break;
                case 'line':
                    annotationIcon = '<i class="fas fa-slash"></i>';
                    break;
                case 'text':
                    annotationIcon = '<i class="fas fa-text-width"></i>';
                    break;
                case 'textCallout':
                    annotationIcon = '<i class="fas fa-comment-dots"></i>';
                    break;
                case 'freeDraw':
                    annotationIcon = '<i class="fas fa-edit"></i>';
                    break;
                case 'highlight':
                    annotationIcon = '<i class="fas fa-highlighter"></i>';
                    break;
                case 'stamp':
                    annotationIcon = '<i class="fas fa-stamp"></i>';
                    break;
                case 'signature':
                    annotationIcon = '<i class="fas fa-signature"></i>';
                    break;
                case 'underline':
                    annotationIcon = '<i class="fas fa-underline"></i>';
                    break;
                case 'strikeout':
                    annotationIcon = '<i class="fas fa-strikethrough"></i>';
                    break;
                default:
                    annotationIcon = '<i class="fas fa-comment"></i>';
            }

            annotationItem.innerHTML = `
        <div class="annotation-box">
            <div class="annotation-header">
                <span class="annotation-type">${annotationIcon} </span>
                <span class="annotation-timestamp">${timestamp}</span>
            </div>
            <div class="annotation-content">
                ${annotation.content || 'No content added'}
            </div>
            <div class="annotation-actions">
                <button class="btn-action btn-edit" data-id="${annotation.id}">
                    <i class="fas fa-edit"></i>
                    
                </button>
                <button class="btn-action btn-delete" data-id="${annotation.id}">
                    <i class="fas fa-trash-alt"></i>
                    
                </button>
            </div>
        </div>
    `;

            if (annotationList.children.length === 0) {
                annotationList.innerHTML = `
            <div class="annotation-empty">
                <i class="fas fa-comment-alt fa-2x mb-3"></i>
                <p>No annotations yet</p>
                <p class="text-sm">Start adding annotations to your document</p>
            </div>
        `;
            }

            const deleteBtn = annotationItem.querySelector('.btn-delete');
            const editBtn = annotationItem.querySelector('.btn-edit');

            deleteBtn.addEventListener('click', function (event) {
                event.stopPropagation();
                deleteAnnotations(annotation.id);
            });

            editBtn.addEventListener('click', function (event) {
                event.stopPropagation();
                openAnnotationModal(annotation);
            });
        }

        //         function updateSidebar(annotationInput) {
        //     console.log("Updating Sidebar with:", annotationInput);

        //     // Handle both single annotation and array of annotations
        //     const annotations = Array.isArray(annotationInput) ? annotationInput : [annotationInput];
        //     const annotationList = document.getElementById("annotationList");

        //     // Clear existing annotations if passing an array
        //     if (Array.isArray(annotationInput)) {
        //         annotationList.innerHTML = '';
        //     }

        //     // Handle empty annotations list
        //     if (annotations.length === 0) {
        //         annotationList.innerHTML = `
        //             <div class="annotation-empty">
        //                 <i class="fas fa-comment-alt fa-2x mb-3"></i>
        //                 <p>No annotations yet</p>
        //                 <p class="text-sm">Start adding annotations to your document</p>
        //             </div>
        //         `;
        //         return;
        //     }

        //     // Process each annotation
        //     annotations.forEach(annotation => {
        //         if (!annotation || !annotation.id) {
        //             console.error("Invalid annotation:", annotation);
        //             return;
        //         }

        //         let annotationItem = document.getElementById(`annotation-${annotation.id}`);

        //         // Create new item if it doesn't exist
        //         if (!annotationItem) {
        //             annotationItem = document.createElement("div");
        //             annotationItem.id = `annotation-${annotation.id}`;
        //             annotationItem.classList.add("annotation-item");
        //             annotationList.appendChild(annotationItem);
        //         }

        //         const timestamp = new Date(annotation.createdAt || new Date()).toLocaleString('en-US', {
        //             month: 'short',
        //             day: 'numeric',
        //             hour: '2-digit',
        //             minute: '2-digit'
        //         });

        //         annotationItem.innerHTML = `
        //             <div class="annotation-box">
        //                 <div class="annotation-header">
        //                     <span class="annotation-type">${annotation.type}</span>
        //                     <span class="annotation-timestamp">${timestamp}</span>
        //                 </div>
        //                 <div class="annotation-content">
        //                     ${annotation.content || 'No content added'}
        //                 </div>
        //                 <div class="annotation-actions">
        //                     <button class="btn-action btn-edit" data-id="${annotation.id}">
        //                         <i class="fas fa-edit"></i>
        //                         Edit
        //                     </button>
        //                     <button class="btn-action btn-delete" data-id="${annotation.id}">
        //                         <i class="fas fa-trash-alt"></i>
        //                         Delete
        //                     </button>
        //                 </div>
        //             </div>
        //         `;

        //         // Add event listeners
        //         const deleteBtn = annotationItem.querySelector('.btn-delete');
        //         const editBtn = annotationItem.querySelector('.btn-edit');

        //         deleteBtn.addEventListener('click', function(event) {
        //             event.stopPropagation();
        //             deleteAnnotations(annotation.id);
        //         });

        //         editBtn.addEventListener('click', function(event) {
        //             event.stopPropagation();
        //             openAnnotationModal(annotation);
        //         });
        //     });
        // }


        // ... existing code ...
        function updateSidebarInput(annotationInput) {
            console.log("Updating Sidebar with:", annotationInput);

            try {
                // Get the annotation list element
                const annotationList = document.getElementById("annotationList");
                if (!annotationList) {
                    console.error("Annotation list element not found in the DOM");
                    return;
                }

                // Handle both single annotation and array of annotations
                const annotations = Array.isArray(annotationInput) ? annotationInput : [annotationInput];

                // Clear existing annotations if passing an array
                if (Array.isArray(annotationInput)) {
                    annotationList.innerHTML = '';
                }

                // Get current user ID from URL
                const urlParams = new URLSearchParams(window.location.search);
                const currentUserId = urlParams.get('UserId');
                console.log("Current User ID from URL:", currentUserId);

                // Process each annotation
                annotations.forEach(annotation => {
                    if (!annotation) {
                        console.error("Null annotation found in list");
                        return;
                    }

                    if (!annotation.id) {
                        console.error("Annotation without ID found:", annotation);
                        return;
                    }

                    // Check if current user is the creator of this annotation
                    const isOwner = currentUserId && annotation.userId === currentUserId;

                    // Log ownership status for debugging
                    console.log(`Annotation ID: ${annotation.id}, Type: ${annotation.type || 'unknown'}, User ID: ${annotation.userId || 'none'}, Current User: ${currentUserId}, Is Owner: ${isOwner}`);

                    if (isOwner) {
                        console.log(`✅ MATCH: User can edit annotation ${annotation.id}`);
                    } else {
                        console.log(`❌ NO MATCH: User cannot edit annotation ${annotation.id} (belongs to ${annotation.userId || 'unknown user'})`);
                    }

                    let annotationItem = document.getElementById(`annotation-${annotation.id}`);

                    // Create new item if it doesn't exist
                    if (!annotationItem) {
                        annotationItem = document.createElement("div");
                        annotationItem.id = `annotation-${annotation.id}`;
                        annotationItem.classList.add("annotation-item");
                        annotationList.appendChild(annotationItem);

                        if (annotationList.firstChild) {
                            annotationList.insertBefore(annotationItem, annotationList.firstChild);
                        } else {
                            annotationList.appendChild(annotationItem);
                        }
                    }

                    // Generate a safe timestamp
                    let timestamp;
                    try {
                        timestamp = new Date(annotation.createdAt || new Date()).toLocaleString('en-US', {
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    } catch (e) {
                        timestamp = new Date().toLocaleString('en-US', {
                            month: 'short',
                            day: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    }

                    // Create sanitized content
                    const content = annotation.content || annotation.text || 'No content added';
                    const sanitizedContent = content.replace(/</g, '&lt;').replace(/>/g, '&gt;');

                    let annotationIcon = '';
                    switch (annotation.type) {
                        case 'cloud':
                            annotationIcon = '<i class="fas fa-cloud"></i>';
                            break;
                        case 'circle':
                            annotationIcon = '<i class="far fa-circle"></i>';
                            break;
                        case 'square':
                            annotationIcon = '<i class="far fa-square"></i>';
                            break;
                        case 'line':
                            annotationIcon = '<i class="fas fa-slash"></i>';
                            break;
                        case 'text':
                            annotationIcon = '<i class="fas fa-text-width"></i>';
                            break;
                        case 'textCallout':
                            annotationIcon = '<i class="fas fa-comment-dots"></i>';
                            break;
                        case 'freeDraw':
                            annotationIcon = '<i class="fas fa-edit"></i>';
                            break;
                        case 'highlight':
                            annotationIcon = '<i class="fas fa-highlighter"></i>';
                            break;
                        case 'stamp':
                            annotationIcon = '<i class="fas fa-stamp"></i>';
                            break;
                        case 'signature':
                            annotationIcon = '<i class="fas fa-signature"></i>';
                            break;
                        case 'underline':
                            annotationIcon = '<i class="fas fa-underline"></i>';
                            break;
                        case 'strikeout':
                            annotationIcon = '<i class="fas fa-strikethrough"></i>';
                            break;
                        default:
                            annotationIcon = '<i class="fas fa-comment"></i>';
                    }

                    // Update item content
                    annotationItem.innerHTML = `
                <div class="annotation-box">
                    <div class="annotation-header">
                        <span class="annotation-type">${annotationIcon} </span>
                        <span class="annotation-timestamp">${timestamp}</span>
                    </div>
                    <div class="annotation-content">
                        ${sanitizedContent}
                    </div>
                    <div class="annotation-actions">
                        ${isOwner ? `
                            <button class="btn-action btn-edit" data-id="${annotation.id}">
                                <i class="fas fa-edit"></i>
                                
                            </button>
                            <button class="btn-action btn-delete" data-id="${annotation.id}">
                                <i class="fas fa-trash-alt"></i>
                                
                            </button>
                        ` : `
                        `}
                    </div>
                </div>
            `;

                    // Add data attribute to track ownership
                    annotationItem.setAttribute('data-is-owner', isOwner);

                    // Safely add event listeners only if user is the owner
                    if (isOwner) {
                        try {
                            const deleteBtn = annotationItem.querySelector('.btn-delete');
                            if (deleteBtn) {
                                // Remove any existing listeners to prevent duplicates
                                const newDeleteBtn = deleteBtn.cloneNode(true);
                                deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);

                                newDeleteBtn.addEventListener('click', function (event) {
                                    event.stopPropagation();
                                    deleteAnnotations(annotation.id);
                                });
                            }

                            const editBtn = annotationItem.querySelector('.btn-edit');
                            if (editBtn) {
                                // Remove any existing listeners to prevent duplicates
                                const newEditBtn = editBtn.cloneNode(true);
                                editBtn.parentNode.replaceChild(newEditBtn, editBtn);

                                newEditBtn.addEventListener('click', function (event) {
                                    event.stopPropagation();
                                    openAnnotationModal(annotation);
                                });
                            }
                        } catch (error) {
                            console.error("Error setting up annotation item event listeners:", error);
                        }
                    }
                });
            } catch (error) {
                console.error("Error updating sidebar:", error);
                // Create a minimal fallback display if the main update fails
                try {
                    const annotationList = document.getElementById("annotationList");
                    if (annotationList) {
                        annotationList.innerHTML = `
                    <div class="annotation-error">
                        <p>Error displaying annotations</p>
                        <p class="text-sm">Please refresh the page and try again</p>
                    </div>
                `;
                    }
                } catch (e) {
                    // Last resort
                    console.error("Fatal error updating sidebar:", e);
                }
            }
        }

        function updateSidebarWithCircleAnnotations(circleAnnotations) {
            console.log("Updating sidebar with circle annotations:", circleAnnotations);

            try {
                const annotationList = document.getElementById("annotationList");
                if (!annotationList) {
                    console.error("Annotation list element not found in the DOM");
                    return;
                }

                // Get current user ID from URL
                const urlParams = new URLSearchParams(window.location.search);
                const currentUserId = urlParams.get('UserId');
                console.log("Current User ID for circle annotations:", currentUserId);

                circleAnnotations.forEach(annotation => {
                    if (!annotation || !annotation.id) {
                        console.error("Invalid circle annotation:", annotation);
                        return;
                    }

                    // Check if current user is the creator of this annotation
                    const isOwner = currentUserId && annotation.userId === currentUserId;

                    // Log ownership status for debugging
                    console.log(`Circle Annotation ID: ${annotation.id}, User ID: ${annotation.userId || 'none'}, Current User: ${currentUserId}, Is Owner: ${isOwner}`);

                    if (isOwner) {
                        console.log(`✅ MATCH: User can edit circle annotation ${annotation.id}`);
                    } else {
                        console.log(`❌ NO MATCH: User cannot edit circle annotation ${annotation.id} (belongs to ${annotation.userId || 'unknown user'})`);
                    }

                    let annotationItem = document.getElementById(`annotation-${annotation.id}`);

                    // Create new item if it doesn't exist
                    if (!annotationItem) {
                        annotationItem = document.createElement("div");
                        annotationItem.id = `annotation-${annotation.id}`;
                        annotationItem.classList.add("annotation-item");
                        annotationItem.setAttribute('data-type', 'circle');
                        annotationList.appendChild(annotationItem);
                        if (annotationList.firstChild) {
                            annotationList.insertBefore(annotationItem, annotationList.firstChild);
                        } else {
                            annotationList.appendChild(annotationItem);
                        }
                    }

                    // Generate timestamp
                    const timestamp = new Date(annotation.createdAt).toLocaleString('en-US', {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });

                    // Create sanitized content
                    const content = annotation.content || 'Circle Annotation';
                    const sanitizedContent = content.replace(/</g, '&lt;').replace(/>/g, '&gt;');

                    // Update item content
                    annotationItem.innerHTML = `
                <div class="annotation-box">
                    <div class="annotation-header">
                        <span class="annotation-type"><i class="far fa-circle"></i> Circle</span>
                        <span class="annotation-timestamp">${timestamp}</span>
                    </div>
                    <div class="annotation-content">
                        ${sanitizedContent}
                    </div>
                    <div class="annotation-actions">
                        ${isOwner ? `
                            <button class="btn-action btn-edit" data-id="${annotation.id}">
                                <i class="fas fa-edit"></i>
                                
                            </button>
                            <button class="btn-action btn-delete" data-id="${annotation.id}">
                                <i class="fas fa-trash-alt"></i>
                                
                            </button>
                        ` : `
                            <span class="annotation-readonly-notice">View only (created by another user)</span>
                        `}
                    </div>
                </div>
            `;

                    // Add data attribute to track ownership
                    annotationItem.setAttribute('data-is-owner', isOwner);

                    // Only add event listeners if user is the owner
                    if (isOwner) {
                        const deleteBtn = annotationItem.querySelector('.btn-delete');
                        if (deleteBtn) {
                            const newDeleteBtn = deleteBtn.cloneNode(true);
                            deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
                            newDeleteBtn.addEventListener('click', (event) => {
                                event.stopPropagation();
                                deleteAnnotations(annotation.id);
                            });
                        }

                        const editBtn = annotationItem.querySelector('.btn-edit');
                        if (editBtn) {
                            const newEditBtn = editBtn.cloneNode(true);
                            editBtn.parentNode.replaceChild(newEditBtn, editBtn);
                            newEditBtn.addEventListener('click', (event) => {
                                event.stopPropagation();
                                openAnnotationModal(annotation);
                            });
                        }
                    }
                });
            } catch (error) {
                console.error("Error updating sidebar with circle annotations:", error);
            }
        }






        // // Function for deleting annotations
        // function deleteAnnotation(id) {
        //     try {
        //         // Confirm before deleting
        //         if (confirm("Are you sure you want to delete this annotation?")) {
        //             // Find the annotation in the array
        //             const index = annotations.findIndex(a => a.id === id);
        //             if (index !== -1) {
        //                 // Remove from main array
        //                 const annotation = annotations.splice(index, 1)[0];

        //                 // Remove from page-specific array
        //                 const pageNum = annotation.page.toString();
        //                 if (annotationsByPage[pageNum]) {
        //                     const pageIndex = annotationsByPage[pageNum].findIndex(a => a.id === id);
        //                     if (pageIndex !== -1) {
        //                         annotationsByPage[pageNum].splice(pageIndex, 1);
        //                     }
        //                 }

        //                 // Remove from DOM
        //                 const element = document.getElementById(`annotation-${id}`);
        //                 if (element) {
        //                     element.remove();
        //                 }

        //                 // Re-render annotations for current page
        //                 renderAnnotationsForPage(currentPageNum, annotations);

        //                 // Update sidebar if needed
        //                 if (annotations.length === 0) {
        //                     updateSidebar([]);
        //                 }

        //                 showToast("Annotation deleted successfully");
        //             }
        //         }
        //     } catch (error) {
        //         console.error("Error deleting annotation:", error);
        //         showToast("Error deleting annotation");
        //     }
        // }


        // function deleteAnnotations(annotationId) {
        //     console.log("Deleting Annotation with ID:", annotationId);

        //     // Remove from sidebar
        //     const annotationItem = document.getElementById(`annotation-${annotationId}`);
        //     if (annotationItem) {
        //         annotationItem.remove();
        //     }

        //     // Check all fabric canvases for the annotation
        //     let found = false;
        //     for (const pageNum in fabricCanvases) {
        //         const canvas = fabricCanvases[pageNum];
        //         const annotationOnCanvas = canvas.getObjects().find(obj => obj.id === annotationId);

        //         if (annotationOnCanvas) {
        //             found = true;
        //             if (annotationOnCanvas.type === "image") {
        //                 console.log("Removing image annotation (signature/stamp):", annotationId);
        //             }
        //             canvas.remove(annotationOnCanvas);
        //             canvas.renderAll();
        //             console.log(`Annotation removed from canvas on page ${pageNum}`);
        //             break; // Break since we found and removed the annotation
        //         }
        //     }

        //     if (!found) {
        //         console.log("Annotation not found on any canvas:", annotationId);
        //     }

        //     // Remove from annotationsByPage
        //     for (let page in annotationsByPage) {
        //         const index = annotationsByPage[page].findIndex(anno => anno.id === annotationId);
        //         if (index !== -1) {
        //             annotationsByPage[page].splice(index, 1);
        //             console.log("Annotation removed from annotationsByPage for page:", page);
        //         }
        //     }

        //     // Remove from annotations array
        //     const index = annotations.findIndex(anno => anno.id === annotationId);
        //     if (index !== -1) {
        //         annotations.splice(index, 1);
        //         console.log("Annotation removed from array:", annotationId);
        //     } else {
        //         console.log("Annotation not found in annotations array:", annotationId);
        //     }

        //     // Update storage
        //     try {
        //         localStorage.setItem('pdfAnnotations', JSON.stringify(annotationsByPage));
        //     } catch (error) {
        //         console.error('Error saving updated annotations to storage:', error);
        //     }

        //     renderAllPages();
        //     showToast('Annotation deleted');
        //     //123
        // }

        function deleteAnnotations(annotationId) {
            console.log("Deleting Annotation with ID:", annotationId);

            const annotationItem = document.getElementById(`annotation-${annotationId}`);
            if (annotationItem) {
                annotationItem.remove();
            }

            const annotationOnCanvas = fabricCanvas.getObjects().find(obj => obj.id === annotationId);
            if (annotationOnCanvas) {
                if (annotationOnCanvas.type === "image") {
                    console.log("Removing image annotation (signature/stamp):", annotationId);
                }

                fabricCanvas.remove(annotationOnCanvas);
                fabricCanvas.renderAll();
            } else {
                console.log("Annotation not found on canvas:", annotationId);
            }

            let annotationFound = false;
            for (let pageNum in fabricCanvases) {
                const canvas = fabricCanvases[pageNum];
                const objectsToRemove = canvas.getObjects().filter(obj => obj.id === annotationId);

                if (objectsToRemove.length > 0) {
                    annotationFound = true;
                    console.log(`Found annotation with ID ${annotationId} on page ${pageNum}`);
                    objectsToRemove.forEach(obj => {
                        canvas.remove(obj);
                    });
                    canvas.renderAll();
                }
            }




            let removedFromPages = false;
            for (let page in annotationsByPage) {
                const index = annotationsByPage[page].findIndex(anno => anno.id === annotationId);
                if (index !== -1) {
                    removedFromPages = true;
                    annotationsByPage[page].splice(index, 1);
                    console.log("Annotation removed from annotationsByPage for page:", page);
                }
            }

            const index = annotations.findIndex(anno => anno.id === annotationId);
            if (index !== -1) {
                annotations.splice(index, 1);
                console.log("Annotation removed from array:", annotationId);
            } else {
                console.log("Annotation not found in annotations array:", annotationId);
            }

            if (window.allCircleAnnotations && Array.isArray(window.allCircleAnnotations)) {
                const circleIndex = window.allCircleAnnotations.findIndex(anno => anno.id === annotationId);
                if (circleIndex !== -1) {
                    window.allCircleAnnotations.splice(circleIndex, 1);
                    console.log("Removed from cached circle annotations array");
                }
            }

            try {
                localStorage.setItem('pdfAnnotations', JSON.stringify(annotationsByPage));
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }

            console.log("Current annotationsByPage before rendering:", JSON.parse(JSON.stringify(annotationsByPage)));


            window.deletedAnnotationIds = window.deletedAnnotationIds || [];
            window.deletedAnnotationIds.push(annotationId);

            // 10. Modify renderAllPages to check for deleted annotations
            const originalRenderAllPages = window.renderAllPages;
            window.renderAllPages = function () {
                // Filter out any deleted annotations before rendering
                if (window.deletedAnnotationIds && window.deletedAnnotationIds.length > 0) {
                    for (let page in annotationsByPage) {
                        annotationsByPage[page] = annotationsByPage[page].filter(anno =>
                            !window.deletedAnnotationIds.includes(anno.id));
                    }
                }
                return originalRenderAllPages.apply(this, arguments);
            };
            renderAllPages();


            window.renderAllPages = originalRenderAllPages;

            console.log("Annotation deleted:", annotationId);

            // console.log("Annotation deleted:", annotation);
            // console.log("Annotation deleted:", annotationId);
            showToast('Annotation deleted');

        }

        // Add this function at an appropriate place in your code
        function addFilterToRenderAllPages() {
            const originalRenderAllPages = window.renderAllPages;
            window.renderAllPages = function () {
                // Always filter out any deleted annotations before rendering
                if (window.deletedAnnotationIds && window.deletedAnnotationIds.length > 0) {
                    console.log("Filtering deleted annotations before rendering:", window.deletedAnnotationIds);
                    for (let page in annotationsByPage) {
                        if (Array.isArray(annotationsByPage[page])) {
                            const before = annotationsByPage[page].length;
                            annotationsByPage[page] = annotationsByPage[page].filter(anno =>
                                !window.deletedAnnotationIds.includes(anno.id));
                            const after = annotationsByPage[page].length;
                            if (before !== after) {
                                console.log(`Filtered ${before - after} deleted annotations from page ${page}`);
                            }
                        }
                    }
                }
                return originalRenderAllPages.apply(this, arguments);
            };
        }

        // Call this function at initialization
        // addFilterToRenderAllPages();

        // ... existing code ...

        function selectAnnotation(annotation) {
            console.log("Attempting to select annotation:", annotation);  //1 

            const pageNum = annotation.page || 1;
            const canvas = fabricCanvases[pageNum];

            if (!canvas) {
                console.error("No canvas found for page:", pageNum);
                return;
            }


            // Check if this annotation is already being processed to prevent duplication
            if (annotation._isBeingProcessed) {
                console.log("Annotation is already being processed, preventing duplication");
                return;
            }

            // Mark as being processed
            annotation._isBeingProcessed = true;

            // Clear the flag after a short delay
            setTimeout(() => {
                delete annotation._isBeingProcessed;
            }, 500);

            if (annotation.type === 'textCallout') {
                console.log("Handling text callout annotation in selectannotaion ");
                const handled = selectTextCalloutAnnotation(annotation, canvas);
                if (handled) {
                    // Scroll to the annotation
                    // scrollToAnnotation(pageNum);
                    return;
                }
            }

            console.log(`Looking for annotation on page ${pageNum}, canvas objects:`, canvas.getObjects()); //2

            // First check if we already have this exact annotation on the canvas
            let existingAnnotations = canvas.getObjects().filter(obj =>
                obj.id === annotation.id ||
                (obj.type === 'circle' && annotation.type === 'circle' &&
                    Math.abs(obj.left - (annotation.x1 || annotation.centerX || 0)) < 10 &&
                    Math.abs(obj.top - (annotation.y1 || annotation.centerY || 0)) < 10)
            );

            let annotationOnCanvas;

            if (existingAnnotations.length > 1) {
                console.log("Found duplicate annotations, removing extras:", existingAnnotations.length);
                // Keep only the first one and remove others
                for (let i = 1; i < existingAnnotations.length; i++) {
                    canvas.remove(existingAnnotations[i]);
                }
                canvas.renderAll();
                // Use the remaining annotation
                annotationOnCanvas = existingAnnotations[0];
            } else {
                // Normal search for the annotation
                annotationOnCanvas = canvas.getObjects().find(obj => {
                    console.log("Checking object:", obj.id, obj.type, "against:", annotation.id, annotation.type);//3 

                    if (obj.id === annotation.id) return true;

                    // Special handling for circle annotations
                    if (annotation.type === 'circle' && obj.type === 'circle') {
                        // For extracted circle annotations, we need to check more properties
                        // since the coordinates might be different (center vs corner)
                        const objCenterX = obj.left;
                        const objCenterY = obj.top;

                        // If annotation has centerX/centerY properties, use those
                        if (annotation.centerX !== undefined && annotation.centerY !== undefined) {
                            return Math.abs(objCenterX - annotation.centerX) < 5 &&
                                Math.abs(objCenterY - annotation.centerY) < 5;
                        }

                        // Otherwise calculate center from x1/y1, x2/y2
                        if (annotation.x1 !== undefined && annotation.x2 !== undefined) {
                            const centerX = (annotation.x1 + annotation.x2) / 2;
                            const centerY = (annotation.y1 + annotation.y2) / 2;
                            return Math.abs(objCenterX - centerX) < 5 &&
                                Math.abs(objCenterY - centerY) < 5;
                        }

                        // Fallback to original check
                        return obj.left === annotation.x1 && obj.top === annotation.y1;
                    }
                });
            }

            // For cloud annotations, we need to be more flexible with the matching
            if (!annotationOnCanvas && annotation.type === 'cloud') {
                console.log("Trying more flexible matching for cloud annotation");

                // Look for any path object that might be a cloud and isn't already marked as a free draw
                const pathObjects = canvas.getObjects().filter(obj =>
                    obj.type === 'path' && !obj.isFreeDrawing
                );
                console.log("Found path objects that could be clouds:", pathObjects.length);

                if (pathObjects.length > 0) {
                    // If we have only one path object, it's likely our cloud
                    if (pathObjects.length === 1) {
                        console.log("Using the only path object as cloud annotation");
                        annotationOnCanvas = pathObjects[0];
                        annotationOnCanvas.id = annotation.id;
                        annotationOnCanvas.isCloud = true;  // Mark as cloud
                    }
                    // If we have multiple path objects, try to match by position with larger tolerance
                    else if (annotation.x1 !== undefined && annotation.y1 !== undefined) {
                        for (const obj of pathObjects) {
                            try {
                                const objBounds = obj.getBoundingRect();
                                // Use a much larger tolerance for cloud annotations
                                const positionMatch = Math.abs(objBounds.left - annotation.x1) < 100 &&
                                    Math.abs(objBounds.top - annotation.y1) < 100;

                                if (positionMatch) {
                                    console.log("Found cloud by position match with larger tolerance");
                                    annotationOnCanvas = obj;
                                    annotationOnCanvas.id = annotation.id;
                                    annotationOnCanvas.isCloud = true;  // Mark as cloud
                                    break;
                                }
                            } catch (error) {
                                console.error("Error checking path object bounds:", error);
                            }
                        }
                    }

                    // If still not found, just use the first path object
                    if (!annotationOnCanvas) {
                        console.log("Using first path object as fallback for cloud annotation");
                        annotationOnCanvas = pathObjects[0];
                        annotationOnCanvas.id = annotation.id;
                        annotationOnCanvas.isCloud = true;  // Mark as cloud
                    }
                }
            } ''
            // Enhance the object finding logic to handle cloud, signature, and stamp annotations
            if (!annotationOnCanvas) {
                console.log("Standard ID check failed, trying alternative methods for special types");

                // For cloud, signature, and stamp annotations, we need special handling
                if (['cloud', 'signature', 'stamp'].includes(annotation.type)) {
                    // Try to find by type and position
                    annotationOnCanvas = canvas.getObjects().find(obj => {
                        // For image objects (signatures and stamps)
                        if (obj.type === 'image' && (annotation.type === 'signature' || annotation.type === 'stamp')) {
                            // Check if position is similar
                            if (annotation.x1 !== undefined && annotation.y1 !== undefined) {
                                const positionMatch = Math.abs(obj.left - annotation.x1) < 20 &&
                                    Math.abs(obj.top - annotation.y1) < 20;
                                return positionMatch;
                            }
                        }

                        // For path objects (cloud)
                        if (obj.type === 'path' && annotation.type === 'cloud') {
                            // Check if position is similar
                            if (annotation.x1 !== undefined && annotation.y1 !== undefined) {
                                const objBounds = obj.getBoundingRect();
                                const positionMatch = Math.abs(objBounds.left - annotation.x1) < 20 &&
                                    Math.abs(objBounds.top - annotation.y1) < 20;
                                return positionMatch;
                            }
                        }

                        return false;
                    });

                    // If found, assign the annotation ID to the object
                    if (annotationOnCanvas) {
                        console.log("Found special annotation by position match");
                        annotationOnCanvas.id = annotation.id;
                    }
                }
            }

            // If still not found, try one more approach for image-based annotations
            if (!annotationOnCanvas && ['signature', 'stamp'].includes(annotation.type)) {
                // Look for any image object that doesn't have an ID assigned yet
                const unassignedImages = canvas.getObjects().filter(obj =>
                    obj.type === 'image' && (!obj.id || obj.id.startsWith('id-'))
                );

                if (unassignedImages.length > 0) {
                    console.log("Found unassigned image that could match:", unassignedImages[0]);
                    annotationOnCanvas = unassignedImages[0];
                    annotationOnCanvas.id = annotation.id;
                }
            }





            if (annotationOnCanvas) {
                console.log("Found annotation on canvas:", annotationOnCanvas); // 4 

                // Fix for circle annotations with undefined radius
                // Fix for circle annotations with undefined radius
                if (annotation.type === 'circle' && annotationOnCanvas.radius === undefined) {
                    console.log("Fixing undefined radius for circle annotation");
                    // Calculate radius from width/height if available
                    if (annotation.width && annotation.height) {
                        const radius = Math.min(annotation.width, annotation.height) / 2;
                        annotationOnCanvas.set({
                            'radius': radius,
                            'width': annotation.width,
                            'height': annotation.height,
                            'visible': true,
                            'dirty': true,
                            'opacity': 1,
                            'strokeWidth': 2
                        });
                    } else if (annotation.radius) {
                        annotationOnCanvas.set({
                            'radius': annotation.radius,
                            'visible': true,
                            'dirty': true,
                            'opacity': 1,
                            'strokeWidth': 2
                        });
                    } else {
                        // Default radius if we can't determine it
                        annotationOnCanvas.set({
                            'radius': 20,
                            'visible': true,
                            'dirty': true,
                            'opacity': 1,
                            'strokeWidth': 2
                        });
                    }
                    // Force a render to ensure the circle is visible
                    canvas.renderAll();
                }

                if (annotation.type === 'circle') {
                    // Make sure the circle is visible
                    annotationOnCanvas.set({
                        'visible': true,
                        'opacity': 1,
                        'dirty': true
                    });

                    // Force a render
                    canvas.renderAll();

                    // If this is the first selection, add special handling
                    if (!annotationOnCanvas.hasBeenSelected) {
                        // Force multiple renders with a slight delay to ensure visibility
                        setTimeout(() => {
                            annotationOnCanvas.set({
                                'dirty': true,
                                'visible': true,
                                'opacity': 1
                            });
                            canvas.renderAll();

                            // Force browser to repaint
                            canvas.getElement().style.display = 'none';
                            setTimeout(() => {
                                canvas.getElement().style.display = '';
                                canvas.renderAll();
                            }, 10);
                        }, 50);

                        annotationOnCanvas.hasBeenSelected = true;
                    }
                }

                // Store original properties if not already stored
                // Store original properties if not already stored
                if (!annotationOnCanvas.originalProperties) {
                    // For different annotation types, use appropriate default properties
                    if (annotation.type === 'signature' || annotation.type === 'stamp') {
                        annotationOnCanvas.originalProperties = {
                            stroke: 'transparent',  // No border for images when deselected
                            strokeWidth: 0,
                            fill: annotationOnCanvas.fill || 'transparent',
                            opacity: annotationOnCanvas.opacity || 1,
                            borderColor: 'transparent'
                        };
                    } else if (annotation.type === 'cloud') {
                        // Special properties for cloud annotations
                        annotationOnCanvas.originalProperties = {
                            stroke: annotationOnCanvas.stroke || '#3B71CA',
                            strokeWidth: annotationOnCanvas.strokeWidth || 2,
                            fill: 'transparent',
                            opacity: annotationOnCanvas.opacity || 1
                        };
                        // Mark this path as a cloud to differentiate from free draw
                        annotationOnCanvas.isCloud = true;
                    } else {
                        // For other annotation types
                        annotationOnCanvas.originalProperties = {
                            stroke: annotationOnCanvas.stroke || 'red',
                            strokeWidth: annotationOnCanvas.strokeWidth || 2,
                            fill: annotationOnCanvas.fill || 'transparent',
                            opacity: annotationOnCanvas.opacity || 1
                        };
                    }
                }

                // For circle annotations, we need to ensure visibility
                if (annotation.type === 'circle') {
                    // Make sure the circle is visible
                    annotationOnCanvas.set('visible', true);

                    // If this is the first selection, force it to be unselected first
                    if (!annotationOnCanvas.hasBeenSelected) {
                        annotationOnCanvas.set('selected', false);
                        annotationOnCanvas.hasBeenSelected = true;
                    }
                }

                if (annotationOnCanvas.selected) {
                    console.log("Annotation is already selected, deselecting it");
                    annotationOnCanvas.set({
                        selected: false,
                        stroke: annotationOnCanvas.originalProperties.stroke,
                        strokeWidth: annotationOnCanvas.originalProperties.strokeWidth,
                        fill: annotationOnCanvas.originalProperties.fill,
                        opacity: annotationOnCanvas.originalProperties.opacity
                    });
                    canvas.discardActiveObject();
                    console.log("Deselected annotation on canvas");
                    updateSidebarSelection(null);
                } else {
                    console.log("Annotation is not selected, selecting it");//5

                    // Deselect all other annotations first
                    Object.values(fabricCanvases).forEach(c => {
                        c.getObjects().forEach(obj => {
                            if (obj.originalProperties) {
                                obj.set({
                                    selected: false,
                                    stroke: obj.originalProperties.stroke,
                                    strokeWidth: obj.originalProperties.strokeWidth,
                                    fill: obj.originalProperties.fill,
                                    opacity: obj.originalProperties.opacity
                                });
                            }
                        });
                        c.renderAll();
                    });

                    // Force selectable to true for this operation
                    const wasSelectable = annotationOnCanvas.selectable;
                    annotationOnCanvas.set('selectable', true);

                    // Apply selection styling
                    annotationOnCanvas.set({
                        selected: true,
                        strokeWidth: 5,
                        stroke: '#4a90e2',
                        opacity: 0.8
                    });
                    console.log("Applied new selection properties to annotation on canvas"); //6

                    // Make this the active object
                    try {
                        canvas.setActiveObject(annotationOnCanvas);
                        console.log("Set as active object successfully");
                    } catch (error) {
                        console.error("Error setting active object:", error);
                    }

                    // Restore original selectable property
                    annotationOnCanvas.set('selectable', wasSelectable);

                    // Update sidebar selection
                    updateSidebarSelection(annotation.id);
                }

                // Scroll to the page containing the annotation
                // Scroll to the page containing the annotation
                const pageWrapper = document.querySelector(`[data-page-number="${pageNum}"]`);
                if (pageWrapper) {
                    console.log("Scrolling to page:", pageNum); //7

                    // Try multiple scrolling approaches for better reliability
                    try {
                        // First approach: scrollIntoView with smooth behavior
                        pageWrapper.scrollIntoView({ behavior: 'smooth', block: 'start' });

                        // Second approach: use setTimeout as a fallback
                        setTimeout(() => {
                            const rect = pageWrapper.getBoundingClientRect();
                            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                            const targetY = rect.top + scrollTop - 50; // 50px offset from top

                            window.scrollTo({
                                top: targetY,
                                behavior: 'smooth'
                            });

                            console.log("Applied fallback scrolling to position:", targetY);
                        }, 100);
                    } catch (error) {
                        console.error("Error during scroll:", error);

                        // Last resort: basic scrolling
                        const offsetTop = pageWrapper.offsetTop;
                        window.scrollTo(0, offsetTop - 50);
                        console.log("Used basic scrolling as last resort");
                    }
                }

                // Ensure the canvas is rendered
                canvas.renderAll();
            } else {
                console.log("No fabric annotation found, trying text annotation");
                selectTextAnnotation(annotation);
            }
        }

        function selectTextCalloutAnnotation(annotation, canvas) {
            console.log("Handling text callout selection in selectTextCalloutAnnotation");

            // Find both arrow and text components
            let arrowGroup = canvas.getObjects().find(obj =>
                obj.id === `${annotation.id}_arrow` ||
                (obj.id && obj.id.includes('_arrow') && (
                    obj.id.startsWith(annotation.id) ||
                    obj.id.startsWith('id-')
                ))
            );

            let textBox = canvas.getObjects().find(obj =>
                obj.id === `${annotation.id}_text` ||
                (obj.id && obj.id.includes('_text') && (
                    obj.id.startsWith(annotation.id) ||
                    obj.id.startsWith('id-')
                ))
            );

            if (!arrowGroup || !textBox) {
                console.log("Direct ID match failed, trying alternative matching approaches");

                const allObjects = canvas.getObjects();
                console.log("All canvas objects:", allObjects.map(obj => ({
                    id: obj.id,
                    type: obj.type,
                    calloutId: obj.calloutId
                })));

                // Try to find the most recently added text callout components
                const arrowCandidates = allObjects.filter(obj =>
                    obj.id && (
                        obj.id.includes('_arrow') ||
                        (obj.type === 'group' && obj.annotationType === 'textCallout')
                    )
                );

                const textBoxCandidates = allObjects.filter(obj =>
                    obj.id && (
                        obj.id.includes('_text') ||
                        (obj.type === 'textbox' && obj.annotationType === 'textCallout')
                    )
                );

                console.log("Arrow candidates:", arrowCandidates);
                console.log("TextBox candidates:", textBoxCandidates);
                if (arrowCandidates.length > 0 && textBoxCandidates.length > 0) {
                    // Try to find pairs that belong together
                    for (const arrow of arrowCandidates) {
                        for (const tb of textBoxCandidates) {
                            // Check if they share the same base ID
                            const arrowBaseId = arrow.id.split('_')[0];
                            const tbBaseId = tb.id.split('_')[0];

                            if (arrowBaseId === tbBaseId) {
                                arrowGroup = arrow;
                                textBox = tb;
                                // Update their IDs to match the annotation
                                arrowGroup.calloutId = annotation.id;
                                textBox.calloutId = annotation.id;
                                console.log("Found matching pair:", { arrow: arrowGroup.id, textBox: textBox.id });
                                break;
                            }
                        }
                        if (arrowGroup && textBox) break;
                    }
                    if (!arrowGroup || !textBox) {
                        arrowGroup = arrowCandidates[arrowCandidates.length - 1];
                        textBox = textBoxCandidates[textBoxCandidates.length - 1];
                        arrowGroup.calloutId = annotation.id;
                        textBox.calloutId = annotation.id;
                        console.log("Using most recent pair:", { arrow: arrowGroup.id, textBox: textBox.id });
                    }
                }
            }


            if (!arrowGroup || !textBox) {
                console.log("Arrow group or textbox not found for text callout");
                return false;
            }

            console.log("Found arrow group and textbox:", arrowGroup, textBox);

            // Store original properties if not already stored
            if (!arrowGroup.originalProperties) {
                arrowGroup.originalProperties = {
                    stroke: annotation.arrowColor || 'red',
                    strokeWidth: 2,
                    opacity: 1
                };
            }

            if (!textBox.originalProperties) {
                textBox.originalProperties = {
                    stroke: textBox.stroke || annotation.borderColor || 'red',
                    strokeWidth: textBox.strokeWidth || 1,
                    opacity: textBox.opacity || 1,
                    fill: textBox.fill
                };
            }

            if (arrowGroup.selected) {
                // Deselect the text callout
                console.log("Deselecting text callout");

                // Reset arrow group
                arrowGroup.getObjects().forEach(obj => {
                    obj.set({
                        stroke: arrowGroup.originalProperties.stroke,
                        strokeWidth: arrowGroup.originalProperties.strokeWidth,
                        opacity: arrowGroup.originalProperties.opacity
                    });
                });

                arrowGroup.set({
                    selected: false,
                    stroke: arrowGroup.originalProperties.stroke,
                    strokeWidth: arrowGroup.originalProperties.strokeWidth,
                    opacity: arrowGroup.originalProperties.opacity,
                    selectable: false,
                    lockMovementX: true,
                    lockMovementY: true
                });

                // Reset textbox
                textBox.set({
                    stroke: textBox.originalProperties.stroke,
                    strokeWidth: textBox.originalProperties.strokeWidth,
                    fill: textBox.originalProperties.fill,
                    opacity: textBox.originalProperties.opacity,
                    selectable: true,
                    evented: true
                });

                canvas.discardActiveObject();
                updateSidebarSelection(null);
            } else {
                // Deselect all other annotations first
                Object.values(fabricCanvases).forEach(c => {
                    c.getObjects().forEach(obj => {
                        if (obj.originalProperties) {
                            obj.set({
                                selected: false,
                                stroke: obj.originalProperties.stroke,
                                strokeWidth: obj.originalProperties.strokeWidth,
                                opacity: obj.originalProperties.opacity
                            });
                        }
                    });
                    c.renderAll();
                });

                // Select and lock the arrow group
                console.log("Selecting text callout arrow");

                // Apply selection styling to arrow group but keep it locked
                arrowGroup.getObjects().forEach(obj => {
                    obj.set({
                        stroke: '#4a90e2',
                        strokeWidth: 4,
                        opacity: 0.8,
                        selectable: false,
                        lockMovementX: true,
                        lockMovementY: true
                    });
                });

                arrowGroup.set({
                    selected: true,
                    stroke: '#4a90e2',
                    strokeWidth: 4,
                    opacity: 0.8,
                    selectable: false,
                    lockMovementX: true,
                    lockMovementY: true,
                    hasControls: false
                });

                // Make textbox movable and selectable
                textBox.set({
                    stroke: '#4a90e2',      // Selection color for border
                    strokeWidth: 2,         // Border width
                    selectable: true,       // Allow selection
                    evented: true,          // Allow events
                    hasControls: true,      // Show controls
                    hasBorders: true,       // Show borders
                    lockMovementX: false,   // Allow movement
                    lockMovementY: false
                });

                try {
                    // Set the textbox as the active object instead of the arrow
                    canvas.setActiveObject(textBox);
                    textBox.setCoords();
                    canvas.requestRenderAll();
                } catch (error) {
                    console.error("Error setting active object:", error);
                }

                updateSidebarSelection(annotation.id);
            }

            // Force a canvas render
            canvas.requestRenderAll();
            return true;
        }
        // ... rest of the code ...

        function selectTextAnnotation(annotation) {
            annotation.selected = !annotation.selected;

            Object.keys(fabricCanvases).forEach(pageNum => {
                const pageWrapper = document.querySelector(`[data-page-number="${pageNum}"]`);
                const annotationCanvas = pageWrapper?.querySelector('.annotation-canvas');
                if (annotationCanvas) {
                    const ctx = annotationCanvas.getContext('2d');
                    ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

                    const pageAnnotations = annotationsByPage[pageNum] || [];
                    pageAnnotations.forEach(anno => {
                        if (anno.lineAnnotations) {
                            anno.lineAnnotations.forEach(rect => {
                                switch (anno.type) {
                                    case 'highlight':
                                        ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                                        ctx.fillRect(
                                            rect.left * currentScale,
                                            rect.top * currentScale,
                                            rect.width * currentScale,
                                            rect.height * currentScale
                                        );
                                        break;
                                    case 'underline':
                                    case 'strikeout':
                                        ctx.strokeStyle = 'red';
                                        ctx.lineWidth = 1;
                                        const y = anno.type === 'underline'
                                            ? rect.top * currentScale + (rect.height * currentScale) - 3
                                            : rect.top * currentScale + (rect.height * currentScale / 2) - 4;
                                        ctx.beginPath();
                                        ctx.moveTo(rect.left * currentScale, y);
                                        ctx.lineTo((rect.left + rect.width) * currentScale, y);
                                        ctx.stroke();
                                        break;
                                }

                                if (anno.id === annotation.id && annotation.selected) {
                                    ctx.strokeStyle = '#4a90e2';
                                    ctx.lineWidth = 2;
                                    ctx.strokeRect(
                                        rect.left * currentScale,
                                        rect.top * currentScale,
                                        rect.width * currentScale,
                                        rect.height * currentScale
                                    );
                                }
                            });
                        }
                    });
                }
            });

            updateSidebarSelection(annotation.selected ? annotation.id : null);

            if (annotation.selected) {
                const pageWrapper = document.querySelector(`[data-page-number="${annotation.page}"]`);
                if (pageWrapper) {
                    pageWrapper.scrollIntoView({ behavior: 'smooth' });
                }
            }
        }

        document.getElementById('annotationList').addEventListener('click', event => {
            const target = event.target.closest('.annotation-item');
            if (target && !event.target.matches('.btn-delete, .btn-edit')) {
                event.stopPropagation();
                const annotationId = target.id.replace('annotation-', '');
                console.log("🎯 Sidebar click - Looking for annotation with ID:", annotationId);

                let foundAnnotation = null;
                for (const pageNum in annotationsByPage) {
                    console.log(`🔍 Checking page ${pageNum} for annotation`);
                    const annotation = annotationsByPage[pageNum].find(anno => anno.id === annotationId);
                    if (annotation) {
                        foundAnnotation = annotation;
                        console.log("✅ Found annotation in annotationsByPage:", annotation);

                        if (!fabricCanvases[pageNum] || fabricCanvases[pageNum].getObjects().length === 0) {
                            console.log("⚠️ Canvas for page not ready, rendering page:", pageNum);
                            renderPage(parseInt(pageNum)).then(() => {
                                console.log("🎨 Page rendered, now selecting annotation");
                                selectAnnotation(foundAnnotation);
                            });
                        } else {

                            selectAnnotation(foundAnnotation);
                        }
                        break;
                    }
                }

                if (!foundAnnotation) {
                    console.error("❌ Annotation not found in annotationsByPage:", annotationId);
                }
            }
        });


        function updateSidebarSelection(selectedId) {
            const annotationItems = document.querySelectorAll('.annotation-item');
            annotationItems.forEach(item => {
                const annotationId = item.id.replace('annotation-', '');
                if (annotationId === selectedId) {
                    item.classList.add('selected');
                    item.style.backgroundColor = 'rgba(74, 144, 226, 0.2)';
                    item.style.borderLeft = '3px solid #4a90e2';
                } else {
                    item.classList.remove('selected');
                    item.style.backgroundColor = '';
                    item.style.borderLeft = '';
                }
            });
        }





        function generateUniqueId() {
            return 'id-' + Math.random().toString(36).substr(2, 9);
        }


        function fitToWidth() {
            const containerWidth = document.getElementById('pdf-container').offsetWidth;

            pdfDoc.getPage(currentPageNum).then(page => {
                const pageWidth = page.getViewport({ scale: 1 }).width;
                const scaleFactor = containerWidth / pageWidth;

                setScale(scaleFactor);
                updateZoomPercent();

            });
        }

        function fitToHeight() {
            const containerHeight = document.getElementById('pdf-container').offsetHeight;

            pdfDoc.getPage(currentPageNum).then(page => {
                const pageHeight = page.getViewport({ scale: 1 }).height;
                const scaleFactor = containerHeight / pageHeight;

                setScale(scaleFactor);
                updateZoomPercent();

            });
        }

        function toggleFullScreen() {
            const pdfContainer = document.getElementById('pdf-container');
            const fullScreenButton = document.querySelector('button[onclick="toggleFullScreen()"]');
            const icon = fullScreenButton.querySelector('i');

            if (!document.fullscreenElement) {
                if (pdfContainer.requestFullscreen) {
                    pdfContainer.requestFullscreen();
                } else if (pdfContainer.mozRequestFullScreen) {
                    pdfContainer.mozRequestFullScreen();
                } else if (pdfContainer.webkitRequestFullscreen) {
                    pdfContainer.webkitRequestFullscreen();
                } else if (pdfContainer.msRequestFullscreen) {
                    pdfContainer.msRequestFullscreen();
                }

                icon.classList.remove('fa-expand');
                icon.classList.add('fa-compress');
                fullScreenButton.setAttribute('title', 'Exit full-screen');

                pdfContainer.classList.add('fullscreen-mode');
                ensureContentWrapper();

            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }

                icon.classList.remove('fa-compress');
                icon.classList.add('fa-expand');
                fullScreenButton.setAttribute('title', 'Enter full-screen');

                pdfContainer.classList.remove('fullscreen-mode');
            }
        }

        function ensureContentWrapper() {
            const pdfContainer = document.getElementById('pdf-container');
            let wrapper = pdfContainer.querySelector('.pdf-content-wrapper');

            if (!wrapper) {
                wrapper = document.createElement('div');
                wrapper.className = 'pdf-content-wrapper';

                while (pdfContainer.firstChild) {
                    wrapper.appendChild(pdfContainer.firstChild);
                }

                pdfContainer.appendChild(wrapper);
            }
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'F11' || (event.key === 'Enter' && (event.ctrlKey || event.metaKey))) {
                event.preventDefault();
                toggleFullScreen();
            }
            else if (event.key === 'Escape' && document.fullscreenElement) {
                document.exitFullscreen();
            }
        });

        document.addEventListener('fullscreenchange', updateFullscreenUI);
        document.addEventListener('webkitfullscreenchange', updateFullscreenUI);
        document.addEventListener('mozfullscreenchange', updateFullscreenUI);
        document.addEventListener('MSFullscreenChange', updateFullscreenUI);

        function updateFullscreenUI() {
            const pdfContainer = document.getElementById('pdf-container');
            const fullScreenButton = document.querySelector('button[onclick="toggleFullScreen()"]');
            const icon = fullScreenButton.querySelector('i');

            if (document.fullscreenElement) {
                icon.classList.remove('fa-expand');
                icon.classList.add('fa-compress');
                fullScreenButton.setAttribute('title', 'Exit full-screen');
                pdfContainer.classList.add('fullscreen-mode');
                showToast('Entered fullscreen mode');
            } else {
                icon.classList.remove('fa-compress');
                icon.classList.add('fa-expand');
                fullScreenButton.setAttribute('title', 'Enter full-screen');
                pdfContainer.classList.remove('fullscreen-mode');
                showToast('Exited fullscreen mode');
            }
        }

        function setScale(scaleFactor) {
            currentScale = scaleFactor;

            pdfDoc.getPage(currentPageNum).then(page => {
                const newViewport = page.getViewport({ scale: currentScale });

                renderAllPages();
            });
        }

        let currentScale = 1.3;
        const defaultScale = 1.3;

        function debounce(func, wait) {
            return function (...args) {
                clearTimeout(zoomTimeout);
                zoomTimeout = setTimeout(() => func.apply(this, args), wait);
            };
        }


        function zoomIn() {
            const container = document.getElementById('pdf-container');

            const scrollTop = container.scrollTop;
            const scrollLeft = container.scrollLeft;
            const relativeY = (scrollTop + container.clientHeight / 2) / container.scrollHeight;
            const relativeX = (scrollLeft + container.clientWidth / 2) / container.scrollWidth;

            currentScale *= 1.1;
            updateZoomPercent();

            requestAnimationFrame(() => {
                const newScrollTop = (container.scrollHeight * relativeY) - (container.clientHeight / 2);
                const newScrollLeft = (container.scrollWidth * relativeX) - (container.clientWidth / 2);
                container.scrollTop = newScrollTop;
                container.scrollLeft = newScrollLeft;
            });

            renderAllPages();
        }

        function zoomOut() {
            const container = document.getElementById('pdf-container');

            const scrollTop = container.scrollTop;
            const scrollLeft = container.scrollLeft;
            const relativeY = (scrollTop + container.clientHeight / 2) / container.scrollHeight;
            const relativeX = (scrollLeft + container.clientWidth / 2) / container.scrollWidth;

            currentScale /= 1.1;
            renderAllPages();
            updateZoomPercent();

            requestAnimationFrame(() => {
                const newScrollTop = (container.scrollHeight * relativeY) - (container.clientHeight / 2);
                const newScrollLeft = (container.scrollWidth * relativeX) - (container.clientWidth / 2);
                container.scrollTop = newScrollTop;
                container.scrollLeft = newScrollLeft;
            });
        }

        function zoomReset() {
            const container = document.getElementById('pdf-container');

            const scrollTop = container.scrollTop;
            const scrollLeft = container.scrollLeft;
            const relativeY = (scrollTop + container.clientHeight / 2) / container.scrollHeight;
            const relativeX = (scrollLeft + container.clientWidth / 2) / container.scrollWidth;

            currentScale = defaultScale;
            renderAllPages();
            updateZoomPercent();

            requestAnimationFrame(() => {
                const newScrollTop = (container.scrollHeight * relativeY) - (container.clientHeight / 2);
                const newScrollLeft = (container.scrollWidth * relativeX) - (container.clientWidth / 2);
                container.scrollTop = newScrollTop;
                container.scrollLeft = newScrollLeft;
            });
        }
        function updateZoomPercent() {
            const zoomPercent = Math.round(currentScale * 100);
            document.getElementById('zoom-percent').textContent = zoomPercent;
            console.log("Zoom Percent:", zoomPercent);
        }

        function toggleThumbnails() {
            thumbnailContainer.style.display =
                thumbnailContainer.style.display === "none" ? "block" : "none";
        }

        function enableFreeDraw() {
            isFreeDrawEnabled = !isFreeDrawEnabled;
            fabricCanvas.isDrawingMode = isFreeDrawEnabled;
            fabricCanvas.freeDrawingBrush.width = 2;
            fabricCanvas.freeDrawingBrush.color = 'black';
        }

        function resetDrawingState() {
            isDrawing = false;
            fabricCanvas.isDrawingMode = false;
            fabricCanvas.selection = true;
            fabricCanvas.off('mouse:down');
            fabricCanvas.off('mouse:move');
            fabricCanvas.off('mouse:up');
        }




        //         function loadPdfAnnotations(file) {
        //     const formData = new FormData();
        //     formData.append('file', file);

        //     console.log("Starting to load annotations from file...");
        //     showToast('Loading annotations...');

        //     fetch('/api/annotations/load', {
        //         method: 'POST',
        //         body: formData
        //     })
        //     .then(response => {
        //         if (!response.ok) {
        //             return response.json().then(data => {
        //                 throw new Error(data.error || `HTTP error! status: ${response.status}`);
        //             });
        //         }
        //         return response.json();
        //     })
        //     .then(data => {
        //         console.log('Received server response:', data);
        //         console.log(`Server processed ${data.metadata.totalAnnotations} annotations`);
        //         console.log(`Removed ${data.metadata.removedAnnotations} annotations from PDF`);

        //         // Create a new PDF blob from the base64 content
        //         if (data.pdfContent) {
        //             console.log("Loading cleaned PDF document...");
        //             const pdfBytes = atob(data.pdfContent);
        //             const pdfArray = new Uint8Array(pdfBytes.length);
        //             for (let i = 0; i < pdfBytes.length; i++) {
        //                 pdfArray[i] = pdfBytes.charCodeAt(i);
        //             }

        //             // Load the modified PDF
        //             pdfjsLib.getDocument({ data: pdfArray }).promise.then((pdf) => {
        //                 console.log("PDF loaded successfully, processing annotations...");
        //                 pdfDoc = pdf;

        //                 // Clear existing annotations
        //                 annotations = [];
        //                 annotationsByPage = {};

        //                 // Process annotations by page
        //                 if (data.annotations) {
        //                     Object.entries(data.annotations).forEach(([pageNum, pageAnnotations]) => {
        //                         console.log(`Processing ${pageAnnotations.length} annotations for page ${pageNum}`);

        //                         const formattedAnnotations = pageAnnotations.map(annotation => {
        //                             try {
        //                                 const scaledAnnotation = convertPdfCoordsToCanvas(annotation, parseInt(pageNum));
        //                                 console.log(`Processed annotation: ${annotation.type} on page ${pageNum}`);
        //                                 return {
        //                                     ...scaledAnnotation,
        //                                     id: annotation.id || generateGuid(),
        //                                     type: annotation.type || 'unknown',
        //                                     page: parseInt(pageNum),
        //                                     userName: annotation.userName || sessionUserName,
        //                                     userId: annotation.userId || sessionUserId,
        //                                     documentId: annotation.documentId || sessionDocumentId,
        //                                     createdAt: annotation.createdAt || new Date().toISOString(),
        //                                     isExisting: true
        //                                 };
        //                             } catch (error) {
        //                                 console.error("Error formatting annotation:", error, annotation);
        //                                 return null;
        //                             }
        //                         }).filter(item => item !== null);

        //                         annotationsByPage[pageNum] = formattedAnnotations;
        //                         annotations.push(...formattedAnnotations);
        //                     });

        //                     console.log(`Total annotations processed: ${annotations.length}`);
        //                     updateSidebar(annotations);
        //                     renderAnnotationsForPage(currentPageNum, annotations, true);
        //                     showToast(`Loaded ${annotations.length} annotations successfully`);
        //                 }
        //             });
        //         }
        //     })
        //     .catch(error => {
        //         console.error('Error loading annotations:', error);
        //         showToast(`Error loading annotations: ${error.message}`);
        //     });
        // }


        // // // Helper function to convert PDF coordinates to canvas coordinates
        // function convertPdfCoordsToCanvas(annotation, pageNum) {
        //     try {
        //         // Defensive check - make sure we have a valid PDF document
        //         if (!pdfDoc) {
        //             console.error('PDF document not loaded');
        //             return annotation; // Return unchanged if no PDF doc
        //         }

        //         // Get the page (with fallback for page number issues)
        //         let page;
        //         try {
        //             page = pdfDoc.getPage(pageNum);
        //         } catch (e) {
        //             console.warn(`Error getting page ${pageNum}, trying page ${pageNum-1}`, e);
        //             try {
        //                 // Try with zero-based index
        //                 page = pdfDoc.getPage(pageNum-1);
        //             } catch (e2) {
        //                 console.error(`Failed to get page ${pageNum-1} too`, e2);
        //                 return annotation; // Return unchanged
        //             }
        //         }

        //         // Get viewport with current scale
        //         const viewport = page.getViewport({ scale: currentScale });

        //         // Clone the annotation to avoid modifying the original
        //         const converted = {...annotation};

        //         // Calculate scaling factors
        //         const scaleX = viewport.width / page.view[2];  
        //         const scaleY = viewport.height / page.view[3];

        //         // Convert coordinates - handle potential missing coordinates
        //         if (annotation.hasOwnProperty('x1')) converted.x1 = annotation.x1 * scaleX;
        //         if (annotation.hasOwnProperty('y1')) converted.y1 = viewport.height - (annotation.y1 * scaleY); // Y-axis is inverted
        //         if (annotation.hasOwnProperty('x2')) converted.x2 = annotation.x2 * scaleX;
        //         if (annotation.hasOwnProperty('y2')) converted.y2 = viewport.height - (annotation.y2 * scaleY); // Y-axis is inverted

        //         // Calculate width and height based on coordinates
        //         converted.width = (converted.x2 - converted.x1) || annotation.width * scaleX;
        //         converted.height = (converted.y2 - converted.y1) || annotation.height * scaleY;

        //         return converted;
        //     } catch (error) {
        //         console.error("Error in coordinate conversion:", error);
        //         return annotation; // Return unchanged on error
        //     }
        // }



        // For IIS 

        window.onload = function () {
            const urlParams = new URLSearchParams(window.location.search);
            const pdfUrl = urlParams.get('pdf');

            sessionDocumentId = urlParams.get('DocumentId') || generateGuid();
            sessionUserId = urlParams.get('UserId') || generateGuid();
            sessionUserName = decodeURIComponent(urlParams.get('UserName')) || "Anurag Sable";

            console.log("Session values:", {
                documentId: sessionDocumentId,
                userId: sessionUserId,
                userName: sessionUserName
            });

            if (pdfUrl) {
                loadPdfFromUrl(pdfUrl);
            }
        }



        // async function loadPdfFromUrl(url) {
        //     document.getElementById("pdf-canvas").style.display = "none";
        //     document.getElementById("fabric-canvas").style.display = "none";
        //     document.getElementById("annotation-canvas").style.display = "none";
        //     document.getElementById("text-layer").style.display = "none";
        //     document.querySelector(".upper-canvas").style.pointerEvents = "none";
        //     try {
        //         pdfContext.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
        //         fabricCanvas.clear();
        //         textLayer.innerHTML = '';
        //         const annotationCanvas = document.getElementById('annotation-canvas');
        //         const ctx = annotationCanvas.getContext('2d');
        //         ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

        //         annotationsByPage = {};
        //         annotations = [];

        //         showToast('Loading PDF...');

        //         document.getElementById("pdf-canvas").style.display = "block";
        //         document.getElementById("fabric-canvas").style.display = "block";
        //         document.getElementById("annotation-canvas").style.display = "block";
        //         document.getElementById("text-layer").style.display = "block";
        //         document.querySelector(".upper-canvas").style.pointerEvents = "auto";



        //         const encodedUrl = btoa(url); 
        //         const proxyUrl = `/load-pdf/${encodedUrl}`;
        //         console.log("Requesting PDF from:", proxyUrl);

        //         const response = await fetch(proxyUrl);

        //         if (!response.ok) {
        //             const errorData = await response.json();
        //             throw new Error(errorData.error || 'Failed to fetch PDF');
        //         }
        //         const contentType = response.headers.get('content-type');
        //         if (!contentType || !contentType.includes('application/pdf')) {
        //             console.warn('Unexpected content type:', contentType);
        //         }

        //         const pdfData = await response.arrayBuffer();
        //         if (!pdfData || pdfData.byteLength === 0) {
        //             throw new Error('Empty PDF data received');
        //         }

        //         const blob = new Blob([pdfData], { type: 'application/pdf' });
        // const pdfFile = new File([blob], 'document.pdf', { type: 'application/pdf' });

        // // await extractAndLoadAnnotations(url);
        // // await loadPDFWithAnnotations(pdfFile);
        //         pdfjsLib.getDocument({ data: new Uint8Array(pdfData) }).promise.then((pdf) => {
        //             pdfDoc = pdf;
        //             generateThumbnails();
        //             renderAllPages();                   
        //             updateZoomPercent();
        //             addScrollListener();
        //             document.getElementById('page-num').textContent = pageNum;
        //             highlightThumbnail(pageNum);
        //             window.scrollTo(0, 0);
        //             showToast('PDF loaded successfully');
        //             // loadPDFWithAnnotations(pdfFile);
        //         });

        //         // loadPDFWithAnnotations(url);

        //         toggleThumbnails();
        //         // debugAnnotations();


        //         } catch (error) {
        //         console.error('Error loading PDF:', error);
        //         showToast('Error loading PDF from URL');

        //         document.getElementById("pdf-canvas").style.display = "none";
        //         document.getElementById("fabric-canvas").style.display = "none";
        //         document.getElementById("annotation-canvas").style.display = "none";
        //         document.getElementById("text-layer").style.display = "none";
        //         document.querySelector(".upper-canvas").style.pointerEvents = "none";
        //     }
        // }

        //========================================================================

        let cleanedPdfData = null;

        function checkUserPermissions(annotationUserId, currentUserId) {
            console.log("Checking permissions:", { annotationUserId, currentUserId });
            const cleanAnnotationUserId = annotationUserId?.replace(/^[0-9]+-/, '');
            const cleanCurrentUserId = currentUserId?.replace(/^[0-9]+-/, '');
            return cleanAnnotationUserId === cleanCurrentUserId;
        }




        async function loadPdfFromUrl(url) {
            document.getElementById("pdf-canvas").style.display = "none";
            document.getElementById("fabric-canvas").style.display = "none";
            document.getElementById("annotation-canvas").style.display = "none";
            document.getElementById("text-layer").style.display = "none";
            document.querySelector(".upper-canvas").style.pointerEvents = "none";
            try {

                // Clear the canvas

                const cleanPdfData = await extractAndLoadAnnotations(url);
                if (!cleanPdfData) {
                    throw new Error('Failed to get clean PDF data');
                }
                cleanedPdfData = cleanPdfData;

                pdfContext.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
                fabricCanvas.clear();
                textLayer.innerHTML = '';
                const annotationCanvas = document.getElementById('annotation-canvas');
                const ctx = annotationCanvas.getContext('2d');
                ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

                annotationsByPage = {};
                annotations = [];

                showToast('Loading PDF...');

                document.getElementById("pdf-canvas").style.display = "block";
                document.getElementById("fabric-canvas").style.display = "block";
                document.getElementById("annotation-canvas").style.display = "block";
                document.getElementById("text-layer").style.display = "block";
                document.querySelector(".upper-canvas").style.pointerEvents = "auto";



                const encodedUrl = btoa(url);
                const proxyUrl = `/load-pdf/${encodedUrl}`;
                console.log("Requesting PDF from:", proxyUrl);

                const response = await fetch(proxyUrl);

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to fetch PDF');
                }
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/pdf')) {
                    console.warn('Unexpected content type:', contentType);
                }

                const pdfData = await response.arrayBuffer();
                if (!pdfData || pdfData.byteLength === 0) {
                    throw new Error('Empty PDF data received');
                }

                const blob = new Blob([pdfData], { type: 'application/pdf' });
                const pdfFile = new File([blob], 'document.pdf', { type: 'application/pdf' });

                await extractAndLoadAnnotations(url);
                // await loadPDFWithAnnotations(pdfFile);
                pdfjsLib.getDocument({ data: cleanPdfData }).promise.then((pdf) => {
                    pdfDoc = pdf;

                    generateThumbnails();
                    renderAllPages();
                    updateZoomPercent();
                    addScrollListener();
                    document.getElementById('page-num').textContent = pageNum;
                    highlightThumbnail(pageNum);
                    window.scrollTo(0, 0);
                    showToast('PDF loaded successfully');
                    // loadPDFWithAnnotations(pdfFile);
                });

                // loadPDFWithAnnotations(url);

                toggleThumbnails();
                // debugAnnotations();


            } catch (error) {
                console.error('Error loading PDF:', error);
                showToast('Error loading PDF from URL');

                document.getElementById("pdf-canvas").style.display = "none";
                document.getElementById("fabric-canvas").style.display = "none";
                document.getElementById("annotation-canvas").style.display = "none";
                document.getElementById("text-layer").style.display = "none";
                document.querySelector(".upper-canvas").style.pointerEvents = "none";
            }
        }



        function checkForTwoLinksAfterUsername() {
    const url = window.location.href;

    const urlParams = new URLSearchParams(url.split('?')[1]);

    const userName = urlParams.get('UserName');

    if (!userName) {
        return false;
    }

    const urlParts = url.split('?')[1].split('&');

    const userNameIndex = urlParts.findIndex(part => part.startsWith('UserName='));

    const linksAfterUsername = urlParts.slice(userNameIndex + 1);
    const isValid = linksAfterUsername.length >= 2 && linksAfterUsername.every(part => part.startsWith('http://'));

    return isValid;
}

const result = checkForTwoLinksAfterUsername();
console.log(result);

fetch('/check_links_result', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ result: result })
});

// console.log(checkForTwoLinksAfterUsername());  


        


        async function extractAndLoadAnnotations(url) {
            try {
                console.log("Starting annotation extraction for URL:", url);
                const response = await fetch('/api/annotations/extract', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ url: url })
                });

                if (!response.ok) {
                    throw new Error('Failed to extract annotations');
                }

                const data = await response.json();
                console.log("Annotations extracted:", data);

                // Convert base64 to Uint8Array
                const cleanPdfBytes = atob(data.cleanPdfContent);
                const cleanPdfArray = new Uint8Array(cleanPdfBytes.length);
                for (let i = 0; i < cleanPdfBytes.length; i++) {
                    cleanPdfArray[i] = cleanPdfBytes.charCodeAt(i);
                }

                const urlParams = new URLSearchParams(window.location.search);
                const currentUserId = urlParams.get('UserId');
                console.log("Current User ID from URL:", currentUserId);


                if (window.deletedAnnotationIds && window.deletedAnnotationIds.length > 0) {
                    console.log("Filtering out deleted annotations:", window.deletedAnnotationIds);
                    // Filter annotations for each page
                    for (const pageNum in data.annotations) {
                        if (Array.isArray(data.annotations[pageNum])) {
                            data.annotations[pageNum] = data.annotations[pageNum].filter(anno =>
                                !window.deletedAnnotationIds.includes(anno.id));
                        }
                    }
                }



                // Store annotations globally
                annotationsByPage = data.annotations || {};
                console.log("Annotations before adding user IDs:", JSON.parse(JSON.stringify(annotationsByPage)));



                // Count annotations without user IDs
                let annotationsWithoutUserId = 0;
                let totalAnnotations = 0;

                for (const pageNum in annotationsByPage) {
                    if (Array.isArray(annotationsByPage[pageNum])) {
                        totalAnnotations += annotationsByPage[pageNum].length;

                        // Count annotations without user IDs
                        annotationsByPage[pageNum].forEach(anno => {
                            if (!anno.userId) {
                                annotationsWithoutUserId++;
                            }
                        });

                        // Add user IDs to annotations that don't have them
                        annotationsByPage[pageNum] = annotationsByPage[pageNum].map(anno => {
                            // If annotation doesn't have a userId, assign the one from the URL
                            if (!anno.userId) {
                                console.log(`Adding user ID ${currentUserId} to annotation:`, anno.id);
                                return { ...anno, userId: currentUserId };
                            }
                            return anno;
                        });
                    }
                }

                console.log(`Found ${annotationsWithoutUserId} out of ${totalAnnotations} annotations without user IDs`);
                console.log("Annotations after adding user IDs:", JSON.parse(JSON.stringify(annotationsByPage)));

                // Wait longer for PDF to fully render and canvases to be ready
                setTimeout(async () => {
                    console.log("Applying annotations...");
                    // Process all annotations and collect them
                    const [circleAnnotations, nonCircleAnnotations] = await Promise.all([
                        processCircleAnnotations(annotationsByPage),
                        applyAnnotationsFromBackend(annotationsByPage)
                    ]);

                    console.log("Circle annotations:", circleAnnotations);
                    console.log("Non-circle annotations:", nonCircleAnnotations);

                    const allAnnotations = [
                        ...(Array.isArray(circleAnnotations) ? circleAnnotations : []),
                        ...(Array.isArray(nonCircleAnnotations) ? nonCircleAnnotations : [])
                    ].filter(annotation => annotation && annotation.id);

                    console.log("Combined annotations:", allAnnotations);

                    // Update the sidebar with all annotations
                    if (allAnnotations.length > 0) {
                        const annotationList = document.getElementById("annotationList");
                        if (annotationList) {
                            annotationList.innerHTML = ''; // Clear existing annotations
                            allAnnotations.forEach(annotation => {
                                updateSidebarInput(annotation);
                            });
                        }
                    }
                }, 1);

                return cleanPdfArray;
            } catch (error) {
                console.error('Error extracting annotations:', error);
                showToast('Error extracting annotations');
                return null;
            }
        }


        async function processCircleAnnotations(annotations) {

            console.log("Starting to process circle annotations:", annotations);
            if (!annotations) {
                console.log("No annotations to process");
                return;
            }

            // Wait for fabricCanvases to be initialized
            await waitForFabricCanvases();

            let allCircleAnnotations = [];

            for (const pageNum in annotations) {
                const pageAnnotations = annotations[pageNum];
                const canvas = fabricCanvases[pageNum];

                if (!canvas) {
                    console.error(`No fabric canvas found for page ${pageNum}`);
                    continue;
                }

                // Filter only circle annotations
                const circleAnnotations = pageAnnotations.filter(anno =>
                    anno.type && anno.type.toLowerCase() === 'circle'
                );

                if (window.deletedAnnotationIds && window.deletedAnnotationIds.length > 0) {
                    console.log("Filtering deleted annotations from circle processing:", window.deletedAnnotationIds);
                    circleAnnotations = circleAnnotations.filter(anno =>
                        !window.deletedAnnotationIds.includes(anno.id));
                }

                console.log(`Processing ${circleAnnotations.length} circle annotations for page ${pageNum}`);

                for (const annotation of circleAnnotations) {
                    try {
                        const annotationWithUserId = {
                            ...annotation,
                            userId: annotation.userId || currentUserId // Use existing userId or current user's ID
                        };

                        console.log("Processing circle annotation with user ID:", annotationWithUserId.userId);
                        const circle = await createCircleAnnotation(annotation, pageNum, canvas);
                        if (circle) {
                            // Add to allCircleAnnotations array with required properties for sidebar
                            allCircleAnnotations.push({
                                id: circle.id || annotation.id,
                                userId: circle.userId || annotationWithUserId.userId,
                                type: 'circle',
                                content: circle.content || annotation.content || 'Circle Annotation',
                                createdAt: circle.createdAt || annotation.createdAt || new Date().toISOString(),
                                userName: circle.userName || annotation.userName || sessionUserName,
                                page: parseInt(pageNum),
                                // Include additional properties needed for rendering
                                x1: circle.x1 || annotation.x1,
                                y1: circle.y1 || annotation.y1,
                                radius: circle.radius || annotation.radius,
                                stroke: circle.stroke || annotation.stroke || 'red'
                            });
                        }
                    } catch (error) {
                        console.error(`Error processing circle annotation:`, error);
                    }

                }
                // return allCircleAnnotations;
            }
            // Update sidebar with circle annotations
            if (allCircleAnnotations.length > 0) {
                console.log("Updating sidebar with circle annotations:", allCircleAnnotations);
                // Clear existing circle annotations from sidebar before adding new ones
                const annotationList = document.getElementById("annotationList");
                if (annotationList) {
                    // Remove only circle annotations
                    const existingCircles = annotationList.querySelectorAll('.annotation-item[data-type="circle"]');
                    existingCircles.forEach(item => item.remove());
                }
                updateSidebarWithCircleAnnotations(allCircleAnnotations);
            }
            window.allCircleAnnotations = allCircleAnnotations;

            return allCircleAnnotations;
        }


        async function createCircleAnnotation(annotation, pageNum, canvas) {
            try {
                const scaleFactor = getScaleFactor();
                let centerX, centerY, radius;

                const urlParams = new URLSearchParams(window.location.search);
                const currentUserId = urlParams.get('UserId');

                const userId = annotation.userId || currentUserId;

                console.log(`Creating circle annotation with ID ${annotation.id} and userId ${userId}`);

                console.log(`Creating circle annotation with ID ${annotation.id}`);
                console.log(`Annotation user ID: ${annotation.userId || 'none'}, Current user ID: ${currentUserId}`);

                const isOwner = userId === currentUserId;
                console.log(`User can ${isOwner ? 'edit' : 'only view'} this circle annotation`);


                if (annotation.radius !== undefined) {
                    centerX = (annotation.x1 + annotation.x2) / 2;
                    centerY = (annotation.y1 + annotation.y2) / 2;
                    radius = annotation.radius * scaleFactor.x;
                } else {
                    centerX = (annotation.x1 + annotation.x2) / 2;
                    centerY = (annotation.y1 + annotation.y2) / 2;
                    radius = Math.min(annotation.width, annotation.height) / 2;
                }

                // Create the circle object
                const circle = new fabric.Circle({
                    id: annotation.id,
                    userId: userId,
                    left: centerX,
                    top: centerY,
                    radius: radius,
                    fill: annotation.fill || 'transparent',
                    stroke: annotation.stroke || 'red',
                    strokeWidth: annotation.strokeWidth || 2,
                    selectable: isOwner, // Only selectable if user is owner
                    lockMovementX: !isOwner,
                    lockMovementY: !isOwner,
                    lockRotation: !isOwner,
                    lockScalingX: !isOwner,
                    lockScalingY: !isOwner,
                    hasControls: isOwner,
                    hasBorders: isOwner,
                    evented: true,
                    hoverCursor: isOwner ? 'move' : 'not-allowed',

                    annotationType: 'circle',
                    originX: 'center',
                    originY: 'center',
                    content: annotation.content || '',
                    userName: annotation.userName || sessionUserName,
                    // userId: annotation.userId || currentUserId, // Store the user ID
                    createdAt: annotation.createdAt || new Date().toISOString(),
                });

                // Add visual indicator for non-editable annotations
                // if (!isOwner) {
                //     circle.set({
                //         hoverCursor: 'not-allowed',
                //         stroke: annotation.stroke || '#888', // Use a more muted color for non-editable annotations
                //         strokeDashArray: [5, 5] // Add dashed line for non-editable annotations
                //     });
                // }

                canvas.add(circle);
                canvas.renderAll();

                // Store in annotationsByPage
                if (!annotationsByPage[pageNum]) {
                    annotationsByPage[pageNum] = [];
                }

                const circleData = {
                    ...annotation,
                    id: circle.id,
                    type: 'circle',
                    page: parseInt(pageNum),
                    x1: annotation.x1,
                    y1: annotation.y1,
                    x2: annotation.x2,
                    y2: annotation.y2,
                    radius: radius,
                    stroke: circle.stroke,
                    strokeWidth: circle.strokeWidth,
                    fill: circle.fill,
                    userId: circle.userId // Include the user ID
                };

                annotationsByPage[pageNum].push(circleData);

                // Save to localStorage
                try {
                    localStorage.setItem('pdfAnnotations', JSON.stringify(annotationsByPage));
                } catch (error) {
                    console.error('Error saving circle annotation to storage:', error);
                }
                return circleData;
            } catch (error) {
                console.error('Error creating circle annotation:', error);
                return null;
            }

        }



        async function applyAnnotationsFromBackend(annotations) {
            console.log("Starting to apply annotations:", annotations);
            if (!annotations) {
                console.log("No annotations to apply");
                return;
            }

            await waitForFabricCanvases();
            let allNonCircleAnnotations = [];

            const urlParams = new URLSearchParams(window.location.search);
            const currentUserId = urlParams.get('UserId');

            for (const pageNum in annotations) {
                console.log("Processing page:", pageNum);
                const pageAnnotations = annotations[pageNum];
                const canvas = fabricCanvases[pageNum];

                if (!canvas) {
                    console.error(`No fabric canvas found for page ${pageNum}`);
                    continue;
                }

                // Filter out circle annotations
                const nonCircleAnnotations = pageAnnotations.filter(anno =>
                    anno && anno.type && anno.type.toLowerCase() !== 'circle'
                );

                for (const annotation of nonCircleAnnotations) {
                    try {
                        if (annotation instanceof fabric.Object) {
                            canvas.add(annotation);
                            allNonCircleAnnotations.push(annotation);
                            continue;
                        }

                        // Process non-circle annotations here
                        // Add your other annotation type processing logic here
                        allNonCircleAnnotations.push(annotation);

                    } catch (error) {
                        console.error(`Error applying annotation on page ${pageNum}:`, error, annotation);
                    }
                }
                canvas.renderAll();
            }

            // Update sidebar with non-circle annotations
            // if (allNonCircleAnnotations.length > 0) {
            //     console.log("Updating sidebar with non-circle annotations:", allNonCircleAnnotations);
            //     updateSidebar(allNonCircleAnnotations);
            // }

            // Save to localStorage
            try {
                localStorage.setItem('pdfAnnotations', JSON.stringify(annotationsByPage));
            } catch (error) {
                console.error('Error saving annotations to storage:', error);
            }
            addFilterToRenderAllPages();

            return allNonCircleAnnotations;
        }


        function waitForFabricCanvases() {
            return new Promise((resolve) => {
                const checkCanvases = () => {
                    if (Object.keys(fabricCanvases).length > 0) {
                        resolve();
                    } else {
                        setTimeout(checkCanvases, 100);
                    }
                };
                checkCanvases();
            });
        }


        //=====================================================================================================================


        // async function applyAnnotation(annotation) {
        //     console.log("Applying annotation:", {
        //         type: annotation.type,
        //         coordinates: {
        //             x1: annotation.x1,
        //             y1: annotation.y1,
        //             x2: annotation.x2,
        //             y2: annotation.y2,
        //             width: annotation.width,
        //             height: annotation.height
        //         },
        //         content: annotation.content,
        //         id: annotation.id
        //     });

        //     const type = (annotation.type || '').toLowerCase();
        //     console.log("Annotation type (lowercase):", type);  // Debug log

        //     switch (type) {
        //         case 'text':
        //             console.log("Applying text annotation:", annotation);
        //             applyTextAnnotation(annotation);
        //             break;
        //         case 'highlight':
        //         case 'underline':
        //         case 'strikeout':
        //             console.log("Applying text layer annotation:", annotation);
        //             applyTextLayerAnnotation(annotation);
        //             break;
        //         case 'square':
        //             console.log("Applying square annotation:", annotation);
        //             applySquare1Annotation(annotation);
        //             break;
        //         case 'circle':
        //             // Add this right before the switch statement in applyAnnotation
        // console.log("Raw annotation type:", annotation.type);
        // console.log("Lowercase annotation type:", (annotation.type || '').toLowerCase());
        //             console.log("Applying circle annotation:", annotation);
        //             applyCircleAnnotation(annotation);
        //             break;
        //         case 'line':
        //             console.log("Applying line annotation:", annotation);
        //             applyLine1Annotation(annotation);
        //             break;
        //         case 'freedraw':
        //             console.log("Applying freedraw annotation:", annotation);
        //             applyFreeDrawAnnotation(annotation);
        //             break;
        //         case 'cloud':
        //             console.log("Applying cloud annotation:", annotation);
        //             applyCloudAnnotation(annotation);
        //             break;
        //         case 'stamp':
        //             console.log("Applying stamp annotation:", annotation);
        //             await applyStampAnnotation(annotation);
        //             break;
        //         case 'signature':
        //             console.log("Applying signature annotation:", annotation);
        //             await applySignatureAnnotation(annotation);
        //             break;
        //         default:
        //             console.warn('Unknown annotation type:', annotation.type);
        //     }
        // }

        // function applyTextLayerAnnotation(annotation) {
        //     console.log("Applying text layer annotation:", annotation);
        //     const pageWrapper = document.querySelector(`[data-page-number="${annotation.page}"]`);
        //     if (!pageWrapper) return;

        //     const textLayer = pageWrapper.querySelector('.text-layer');
        //     if (!textLayer) return;

        //     const textLayerRect = textLayer.getBoundingClientRect();

        //     annotation.lineAnnotations.forEach(rect => {
        //         drawAnnotation(rect, annotation.type.toLowerCase(), textLayerRect, pageWrapper);
        //     });
        // }

        // function applyTextAnnotation(annotation) {
        //     console.log("Applying text annotation:", annotation);
        //     const text = new fabric.Textbox(annotation.content || "Enter Text", {
        //         left: annotation.x1,
        //         top: annotation.y1,
        //         width: annotation.width || 200,
        //         fontSize: annotation.fontSize || 16,
        //         fill: annotation.fill || 'black',
        //         id: annotation.id,
        //         selectable: true,
        //         evented: true,
        //         annotationType: 'text'
        //     });
        //     fabricCanvas.add(text);
        // }

        // function applySquare1Annotation(annotation) {
        //     console.log("Applying square annotation:", annotation);
        //     const rect = new fabric.Rect({
        //         left: annotation.x1,
        //         top: annotation.y1,
        //         width: annotation.x2 - annotation.x1,
        //         height: annotation.y2 - annotation.y1,
        //         fill: 'transparent',
        //         stroke: annotation.stroke || 'red',
        //         strokeWidth: annotation.strokeWidth || 1,
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'square'
        //     });
        //     fabricCanvas.add(rect);
        // }

        // function applyCircleAnnotation(annotation) {
        //     console.log("Starting to apply circle annotation:", annotation);

        //     // Get the fabric canvas for the correct page
        //     const pageNum = annotation.page;
        //     const fabricCanvas = fabricCanvases[pageNum];

        //     if (!fabricCanvas) {
        //         console.error(`Fabric canvas not found for page ${pageNum}`);
        //         return;
        //     }

        //     // Calculate center point and radius
        //     const centerX = (annotation.x1 + annotation.x2) / 2;
        //     const centerY = (annotation.y1 + annotation.y2) / 2;
        //     const radius = Math.min(annotation.width, annotation.height) / 2;

        //     console.log("Circle calculations:", {
        //         centerX, centerY, radius,
        //         stroke: annotation.stroke,
        //         strokeWidth: annotation.strokeWidth
        //     });

        //     const circle = new fabric.Circle({
        //         left: centerX - radius,
        //         top: centerY - radius,
        //         radius: radius,
        //         fill: 'transparent',
        //         stroke: annotation.stroke || 'red',
        //         strokeWidth: annotation.strokeWidth || 1,
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'circle'
        //     });

        //     console.log("Created circle object:", circle);
        //     fabricCanvas.add(circle);
        //     fabricCanvas.renderAll();
        // }



        // function applyLine1Annotation(annotation) {
        //     console.log("Applying line annotation:", annotation);
        //     const line = new fabric.Line([
        //         annotation.x1,
        //         annotation.y1,
        //         annotation.x2,
        //         annotation.y2
        //     ], {
        //         stroke: annotation.stroke || 'red',
        //         strokeWidth: annotation.strokeWidth || 2,
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'line'
        //     });
        //     fabricCanvas.add(line);
        // }

        // function applyFreeDrawAnnotation(annotation) {
        //     console.log("Applying freedraw annotation:", annotation);
        //     // For freedraw, we expect points array in the annotation
        //     if (!annotation.points || !Array.isArray(annotation.points)) {
        //         console.warn('No valid points data for freedraw annotation');
        //         return;
        //     }

        //     const path = new fabric.Path(pointsToSVGPath(annotation.points), {
        //         stroke: annotation.stroke || 'red',
        //         strokeWidth: annotation.strokeWidth || 2,
        //         fill: 'transparent',
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'freedraw'
        //     });

        //     fabricCanvas.add(path);
        //     fabricCanvas.renderAll();
        // }

        // function pointsToSVGPath(points) {
        //     if (points.length < 2) return '';

        //     let path = `M ${points[0].x} ${points[0].y}`;
        //     for (let i = 1; i < points.length; i++) {
        //         path += ` L ${points[i].x} ${points[i].y}`;
        //     }
        //     return path;
        // }


        // function applyCloudAnnotation(annotation) {
        //     console.log("Applying cloud annotation:", annotation);
        //     const width = annotation.x2 - annotation.x1;
        //     const height = annotation.y2 - annotation.y1;
        //     const bubbleRadius = Math.min(width, height) / 8;
        //     const numBubbles = Math.floor((2 * (width + height)) / (bubbleRadius * 2));

        //     let pathData = '';

        //     // Create cloud effect using multiple circles
        //     for (let i = 0; i < numBubbles; i++) {
        //         const angle = (i * 2 * Math.PI) / numBubbles;
        //         const x = annotation.x1 + width/2 + (width/2 - bubbleRadius) * Math.cos(angle);
        //         const y = annotation.y1 + height/2 + (height/2 - bubbleRadius) * Math.sin(angle);

        //         if (i === 0) {
        //             pathData += `M ${x + bubbleRadius} ${y} `;
        //         }

        //         const nextAngle = ((i + 1) * 2 * Math.PI) / numBubbles;
        //         const nextX = annotation.x1 + width/2 + (width/2 - bubbleRadius) * Math.cos(nextAngle);
        //         const nextY = annotation.y1 + height/2 + (height/2 - bubbleRadius) * Math.sin(nextAngle);

        //         pathData += `A ${bubbleRadius} ${bubbleRadius} 0 0 1 ${nextX + bubbleRadius} ${nextY} `;
        //     }
        //     pathData += 'Z';

        //     const cloud = new fabric.Path(pathData, {
        //         stroke: annotation.stroke || 'red',
        //         strokeWidth: annotation.strokeWidth || 1,
        //         fill: 'transparent',
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'cloud'
        //     });

        //     fabricCanvas.add(cloud);
        //     fabricCanvas.renderAll();
        // }

        // async function applyStampAnnotation(annotation) {
        //     console.log("Applying stamp annotation:", annotation);
        //     // Create stamp using image or text
        //     const stamp = new fabric.Textbox(annotation.content || 'STAMP', {
        //         left: annotation.x1,
        //         top: annotation.y1,
        //         width: annotation.width || 100,
        //         fontSize: 20,
        //         fill: 'red',
        //         textAlign: 'center',
        //         backgroundColor: 'rgba(255, 0, 0, 0.1)',
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'stamp'
        //     });
        //     fabricCanvas.add(stamp);
        // }

        // async function applySignatureAnnotation(annotation) {
        //     console.log("Applying signature annotation:", annotation);
        //     if (annotation.signatureData) {
        //         fabric.Image.fromURL(annotation.signatureData, function(img) {
        //             img.set({
        //                 left: annotation.x1,
        //                 top: annotation.y1,
        //                 scaleX: annotation.width / img.width,
        //                 scaleY: annotation.height / img.height,
        //                 selectable: true,
        //                 evented: true,
        //                 id: annotation.id,
        //                 annotationType: 'signature'
        //             });
        //             fabricCanvas.add(img);
        //         });
        //     }
        // }

        // function createCloudPath(x, y, width, height) {
        //     const radius = Math.min(width, height) / 8;
        //     let path = `M ${x + radius} ${y} `;

        //     // Top edge
        //     for (let i = x + radius; i < x + width - radius; i += radius * 2) {
        //         path += `Q ${i + radius} ${y - radius} ${i + radius * 2} ${y} `;
        //     }

        //     // Right edge
        //     for (let i = y + radius; i < y + height - radius; i += radius * 2) {
        //         path += `Q ${x + width + radius} ${i} ${x + width} ${i + radius} `;
        //     }

        //     // Bottom edge
        //     for (let i = x + width - radius; i > x + radius; i -= radius * 2) {
        //         path += `Q ${i - radius} ${y + height + radius} ${i - radius * 2} ${y + height} `;
        //     }

        //     // Left edge
        //     for (let i = y + height - radius; i > y + radius; i -= radius * 2) {
        //         path += `Q ${x - radius} ${i} ${x} ${i - radius} `;
        //     }

        //     path += 'Z';
        //     return path;
        // }




        //==================================================================================




        //==================================================================================







        //=============================================================================================


        // // Add this function to perform a second pass of annotation removal
        // function performSecondPassAnnotationRemoval(pdfData) {
        //     showToast('Performing additional annotation cleanup...');

        //     // Create a file from the PDF data
        //     const blob = new Blob([pdfData], { type: 'application/pdf' });
        //     const pdfFile = new File([blob], 'document_first_pass.pdf', { type: 'application/pdf' });

        //     // Create form data
        //     const formData = new FormData();
        //     formData.append('file', pdfFile);

        //     // Send to a new endpoint that specifically targets remaining annotations
        //     return fetch('/api/annotations/remove_remaining', {
        //         method: 'POST',
        //         body: formData
        //     })
        //     .then(response => {
        //         if (!response.ok) {
        //             throw new Error(`HTTP error! status: ${response.status}`);
        //         }
        //         return response.json();
        //     })
        //     .then(data => {
        //         console.log('Second pass annotation removal result:', data);

        //         // If we have a clean PDF from the second pass, use it
        //         if (data.pdfContent) {
        //             // Convert base64 to binary array
        //             const binaryString = atob(data.pdfContent);
        //             const pdfBytes = new Uint8Array(binaryString.length);
        //             for (let i = 0; i < binaryString.length; i++) {
        //                 pdfBytes[i] = binaryString.charCodeAt(i);
        //             }

        //             showToast('Additional cleanup completed');
        //             return pdfBytes;
        //         } else {
        //             // If no clean PDF was returned, use the original
        //             showToast('No additional cleanup needed');
        //             return new Uint8Array(pdfData);
        //         }
        //     })
        //     .catch(error => {
        //         console.error('Error in second pass removal:', error);
        //         showToast('Error in additional cleanup');
        //         // Return original data if there's an error
        //         return new Uint8Array(pdfData);
        //     });
        // }

        // // Update the extractAnnotationsFromPDF function to include the second pass
        // function extractAnnotationsFromPDF(pdfFile) {
        //     showToast('Extracting annotations...');

        //     const formData = new FormData();
        //     formData.append('file', pdfFile);

        //     fetch('/api/annotations/extract', {
        //         method: 'POST',
        //         body: formData
        //     })
        //     .then(response => {
        //         if (!response.ok) {
        //             throw new Error(`HTTP error! status: ${response.status}`);
        //         }
        //         return response.json();
        //     })
        //     .then(data => {
        //         console.log('Extracted annotations:', data);

        //         // Store annotations by page
        //         if (data.annotations) {
        //             annotationsByPage = data.annotations;

        //             // Count total annotations
        //             let totalAnnotations = 0;
        //             Object.keys(annotationsByPage).forEach(pageNum => {
        //                 totalAnnotations += annotationsByPage[pageNum].length;
        //             });

        //             showToast(`Extracted ${totalAnnotations} annotations`);

        //             // If we have a clean PDF, perform a second pass
        //             if (data.pdfContent) {
        //                 // Convert base64 to binary array
        //                 const binaryString = atob(data.pdfContent);
        //                 const firstPassPdfBytes = new Uint8Array(binaryString.length);
        //                 for (let i = 0; i < binaryString.length; i++) {
        //                     firstPassPdfBytes[i] = binaryString.charCodeAt(i);
        //                 }

        //                 // Perform second pass removal
        //                 return performSecondPassAnnotationRemoval(firstPassPdfBytes.buffer);
        //             } else {
        //                 // Use the original PDF file
        //                 return pdfFile.arrayBuffer().then(buffer => new Uint8Array(buffer));
        //             }
        //         } else {
        //             // Use the original PDF file
        //             return pdfFile.arrayBuffer().then(buffer => new Uint8Array(buffer));
        //         }
        //     })
        //     .then(pdfBytes => {
        //         // Load the final PDF (either clean or original)
        //         pdfjsLib.getDocument({ data: pdfBytes }).promise.then((pdf) => {
        //             pdfDoc = pdf;

        //             // Filter out cloud, stamp, and signature annotations
        //             Object.keys(annotationsByPage).forEach(pageNum => {
        //                 annotationsByPage[pageNum] = annotationsByPage[pageNum].filter(annotation => {
        //                     return annotation.type !== 'cloud' && 
        //                            annotation.type !== 'stamp' && 
        //                            annotation.type !== 'signature';
        //                 });
        //             });

        //             // Render the PDF
        //             renderAllPages();
        //             updateZoomPercent();
        //             addScrollListener();
        //             document.getElementById('page-num').textContent = pageNum;
        //             highlightThumbnail(pageNum);
        //             window.scrollTo(0, 0);

        //             showToast('PDF loaded with annotations');
        //         });
        //     })
        //     .catch(error => {
        //         console.error('Error processing annotations:', error);
        //         showToast('Error processing annotations');

        //         // Fall back to loading the original PDF
        //         pdfFile.arrayBuffer().then(arrayBuffer => {
        //             pdfjsLib.getDocument({ data: new Uint8Array(arrayBuffer) }).promise.then((pdf) => {
        //                 pdfDoc = pdf;
        //                 renderAllPages();
        //                 updateZoomPercent();
        //                 addScrollListener();
        //                 document.getElementById('page-num').textContent = pageNum;
        //                 highlightThumbnail(pageNum);
        //                 window.scrollTo(0, 0);
        //                 showToast('PDF loaded (original version)');
        //             });
        //         });
        //     });
        // }
        // // We don't need the base64ToBlob function anymore since we're using a different approach


        //     // // Modify the existing PDF loading function to extract annotations
        //     // function loadPDF(file) {
        //     //     const reader = new FileReader();
        //     //     reader.onload = function(e) {
        //     //         const typedarray = new Uint8Array(e.target.result);

        //     //         pdfjsLib.getDocument({data: typedarray}).promise.then(function(pdf) {
        //     //             pdfDoc = pdf;
        //     //             pageNum = 1;

        //     //             // Initialize page rendering
        //     //             renderAllPages().then(() => {
        //     //                 // Extract annotations from the PDF
        //     //                 extractAnnotationsFromPDF(file);
        //     //             });
        //     //         });
        //     //     };
        //     //     reader.readAsArrayBuffer(file);
        //     // }

        //     // Update renderPageAnnotations function to handle different annotation types
        // function renderPageAnnotations(pageNum) {
        //     const pageAnnotations = annotationsByPage[pageNum] || [];
        //     if (pageAnnotations.length === 0) {
        //         console.log(`No annotations found for page ${pageNum}`);
        //         return;
        //     } 

        //     console.log(`Rendering ${pageAnnotations.length} annotations for page ${pageNum}`);

        //     // Get the annotation canvas for the current page
        //     const annotationCanvas = document.getElementById('annotation-canvas');
        //     if (!annotationCanvas) {
        //         console.error('Annotation canvas not found');
        //         return;
        //     }

        //     const ctx = annotationCanvas.getContext('2d');
        //     ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

        //     // Clear existing fabric objects
        //     fabricCanvas.clear();

        //     // Process each annotation
        //     pageAnnotations.forEach(annotation => {
        //         try {
        //             const type = annotation.type;
        //             console.log(`Rendering annotation of type ${type} on page ${pageNum}`);

        //             // Text layer annotations (highlight, underline, strikeout)
        //             if (type === 'highlight' || type === 'underline' || type === 'strikeout') {
        //                 if (annotation.lineAnnotations && annotation.lineAnnotations.length > 0) {
        //                     annotation.lineAnnotations.forEach(line => {
        //                         const rect = {
        //                             left: line.left,
        //                             top: line.top,
        //                             width: line.width,
        //                             height: line.height
        //                         };

        //                         switch (type) {
        //                             case 'highlight':
        //                                 ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
        //                                 ctx.fillRect(rect.left, rect.top, rect.width, rect.height);
        //                                 break;
        //                             case 'underline':
        //                                 ctx.strokeStyle = 'red';
        //                                 ctx.lineWidth = 1;
        //                                 ctx.beginPath();
        //                                 ctx.moveTo(rect.left, rect.top + rect.height - 2);
        //                                 ctx.lineTo(rect.left + rect.width, rect.top + rect.height - 2);
        //                                 ctx.stroke();
        //                                 break;
        //                             case 'strikeout':
        //                                 ctx.strokeStyle = 'red';
        //                                 ctx.lineWidth = 1;
        //                                 ctx.beginPath();
        //                                 ctx.moveTo(rect.left, rect.top + rect.height / 2);
        //                                 ctx.lineTo(rect.left + rect.width, rect.top + rect.height / 2);
        //                                 ctx.stroke();
        //                                 break;
        //                         }
        //                     });
        //                 }
        //             } 
        //             // Fabric.js annotations
        //             else {
        //                 let fabricObj;

        //                 switch (type) {
        //                     case 'square':
        //                         fabricObj = new fabric.Rect({
        //                             left: annotation.x1,
        //                             top: annotation.y1,
        //                             width: annotation.width,
        //                             height: annotation.height,
        //                             fill: 'transparent',
        //                             stroke: annotation.color,
        //                             strokeWidth: annotation.strokeWidth,
        //                             id: annotation.id,
        //                             annotationType: 'square'
        //                         });
        //                         break;

        //                     case 'circle':
        //                         const radius = annotation.radius || Math.min(annotation.width, annotation.height) / 2;
        //                         fabricObj = new fabric.Circle({
        //                             left: annotation.x1,
        //                             top: annotation.y1,
        //                             radius: radius,
        //                             fill: 'transparent',
        //                             stroke: annotation.color,
        //                             strokeWidth: annotation.strokeWidth,
        //                             id: annotation.id,
        //                             annotationType: 'circle'
        //                         });
        //                         break;

        //                     case 'line':
        //                         fabricObj = new fabric.Line([
        //                             annotation.x1, annotation.y1,
        //                             annotation.x2, annotation.y2
        //                         ], {
        //                             stroke: annotation.color,
        //                             strokeWidth: annotation.strokeWidth,
        //                             id: annotation.id,
        //                             annotationType: 'line'
        //                         });
        //                         break;

        //                     case 'text':
        //                         fabricObj = new fabric.Textbox(annotation.content || 'Text Annotation', {
        //                             left: annotation.x1,
        //                             top: annotation.y1,
        //                             width: annotation.width,
        //                             fontSize: 16,
        //                             fill: annotation.color,
        //                             id: annotation.id,
        //                             annotationType: 'text'
        //                         });
        //                         break;

        //                     case 'freeDraw':
        //                         if (annotation.path) {
        //                             // Convert path array to SVG path string
        //                             const pathString = annotation.path.map((cmd, i) => {
        //                                 if (cmd[0] === 'M') return `M ${cmd[1]} ${cmd[2]}`;
        //                                 if (cmd[0] === 'L') return `L ${cmd[1]} ${cmd[2]}`;
        //                                 if (cmd[0] === 'Q') return `Q ${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`;
        //                                 return '';
        //                             }).join(' ');

        //                             fabricObj = new fabric.Path(pathString, {
        //                                 fill: '',
        //                                 stroke: annotation.color || 'red',
        //                                 strokeWidth: annotation.strokeWidth || 2,
        //                                 id: annotation.id,
        //                                 annotationType: 'freeDraw'
        //                             });
        //                         }
        //                         break;

        //                     case 'cloud':
        //                         if (annotation.path) {
        //                             // Convert path array to SVG path string
        //                             const pathString = annotation.path.map((cmd, i) => {
        //                                 if (cmd[0] === 'M') return `M ${cmd[1]} ${cmd[2]}`;
        //                                 if (cmd[0] === 'L') return `L ${cmd[1]} ${cmd[2]}`;
        //                                 if (cmd[0] === 'Q') return `Q ${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`;
        //                                 return '';
        //                             }).join(' ');

        //                             fabricObj = new fabric.Path(pathString, {
        //                                 fill: 'transparent',
        //                                 stroke: annotation.color || 'blue',
        //                                 strokeWidth: annotation.strokeWidth || 2,
        //                                 id: annotation.id,
        //                                 annotationType: 'cloud'
        //                             });
        //                         }
        //                         break;

        //                         case 'stamp':
        //                         console.log("Creating stamp placeholder:", annotation);
        //                         // Create a placeholder stamp
        //                         const stampRect = new fabric.Rect({
        //                             left: 0,
        //                             top: 0,
        //                             width: annotation.width || 100,
        //                             height: annotation.height || 50,
        //                             fill: annotation.placeholderColor || 'rgba(255, 0, 0, 0.2)',
        //                             stroke: annotation.placeholderBorder || 'red',
        //                             strokeWidth: 1,
        //                             rx: 5,
        //                             ry: 5
        //                         });

        //                         const stampText = new fabric.Text(annotation.placeholderText || 'STAMP', {
        //                             left: (annotation.width || 100)/2,
        //                             top: (annotation.height || 50)/2,
        //                             originX: 'center',
        //                             originY: 'center',
        //                             fontSize: 16,
        //                             fill: annotation.placeholderBorder || 'red'
        //                         });

        //                         fabricObj = new fabric.Group([stampRect, stampText], {
        //                             left: annotation.x1 || 0,
        //                             top: annotation.y1 || 0,
        //                             id: annotation.id,
        //                             annotationType: 'stamp'
        //                         });
        //                         break;

        //                         case 'signature':
        //                         console.log("Creating signature placeholder:", annotation);
        //                         // Create a placeholder signature
        //                         const signRect = new fabric.Rect({
        //                             left: 0,
        //                             top: 0,
        //                             width: annotation.width || 100,
        //                             height: annotation.height || 50,
        //                             fill: annotation.placeholderColor || 'rgba(0, 0, 255, 0.1)',
        //                             stroke: annotation.placeholderBorder || 'blue',
        //                             strokeWidth: 1
        //                         });

        //                         // Create a signature-like path
        //                         const signPath = new fabric.Path('M10,30 Q30,0 50,30 T90,30', {
        //                             left: 10,
        //                             top: (annotation.height || 50)/2 - 15,
        //                             fill: '',
        //                             stroke: annotation.placeholderBorder || 'blue',
        //                             strokeWidth: 2,
        //                             scaleX: (annotation.width || 100) / 100,
        //                             scaleY: (annotation.height || 50) / 60
        //                         });

        //                         fabricObj = new fabric.Group([signRect, signPath], {
        //                             left: annotation.x1 || 0,
        //                             top: annotation.y1 || 0,
        //                             id: annotation.id,
        //                             annotationType: 'signature'
        //                         });
        //                         break;
        //                 }

        //                 if (fabricObj) {
        //                     fabricCanvas.add(fabricObj);
        //                 }
        //             }

        //             // Add to sidebar
        //             updateSidebar(annotation);

        //         } catch (error) {
        //             console.error(`Error rendering annotation: ${error}`, annotation);
        //         }
        //     });

        //     fabricCanvas.renderAll();
        // }

        // // Add this debug function
        // function debugAnnotations() {
        //     console.log("Current annotations by page:", annotationsByPage);

        //     // Check if we have any annotations
        //     let totalAnnotations = 0;
        //     for (const pageNum in annotationsByPage) {
        //         totalAnnotations += annotationsByPage[pageNum].length;
        //     }

        //     console.log(`Total annotations: ${totalAnnotations}`);

        //     // Check if page containers exist
        //     const pageContainers = document.querySelectorAll('.page-container');
        //     console.log(`Found ${pageContainers.length} page containers`);

        //     // Check canvas elements
        //     pageContainers.forEach(container => {
        //         const pageNum = container.getAttribute('data-page-number');
        //         const annotationCanvas = container.querySelector('.annotation-canvas');
        //         const fabricCanvas = container.querySelector('.fabric-canvas');

        //         console.log(`Page ${pageNum}:`, {
        //             annotationCanvas: !!annotationCanvas,
        //             fabricCanvas: !!fabricCanvas,
        //             annotations: (annotationsByPage[pageNum] || []).length
        //         });
        //     });
        // }



        // ... existing code ...
        //=============================================================================================



        //         async function loadPdfFromUrl(url) {
        //     document.getElementById("pdf-canvas").style.display = "none";
        //     document.getElementById("fabric-canvas").style.display = "none";
        //     document.getElementById("annotation-canvas").style.display = "none";
        //     document.getElementById("text-layer").style.display = "none";
        //     document.querySelector(".upper-canvas").style.pointerEvents = "none";
        //     try {
        //         pdfContext.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
        //         fabricCanvas.clear();
        //         textLayer.innerHTML = '';
        //         const annotationCanvas = document.getElementById('annotation-canvas');
        //         const ctx = annotationCanvas.getContext('2d');
        //         ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

        //         annotationsByPage = {};
        //         annotations = [];

        //         showToast('Loading PDF...');

        //         document.getElementById("pdf-canvas").style.display = "block";
        //         document.getElementById("fabric-canvas").style.display = "block";
        //         document.getElementById("annotation-canvas").style.display = "block";
        //         document.getElementById("text-layer").style.display = "block";
        //         document.querySelector(".upper-canvas").style.pointerEvents = "auto";

        //         const encodedUrl = btoa(url); 
        //         const proxyUrl = `/load-pdf/${encodedUrl}`;
        //         console.log("Requesting PDF from:", proxyUrl);

        //         const response = await fetch(proxyUrl);

        //         if (!response.ok) {
        //             const errorData = await response.json();
        //             throw new Error(errorData.error || 'Failed to fetch PDF');
        //         }
        //         const contentType = response.headers.get('content-type');
        //         if (!contentType || !contentType.includes('application/pdf')) {
        //             console.warn('Unexpected content type:', contentType);
        //         }

        //         const pdfData = await response.arrayBuffer();
        //         if (!pdfData || pdfData.byteLength === 0) {
        //             throw new Error('Empty PDF data received');
        //         }

        //         const blob = new Blob([pdfData], { type: 'application/pdf' });
        //         const pdfFile = new File([blob], 'document.pdf', { type: 'application/pdf' });

        //         // Process annotations first, but don't render the PDF yet
        //         await processAnnotations(pdfFile);

        //         toggleThumbnails();

        //     } catch (error) {
        //         console.error('Error loading PDF:', error);
        //         showToast('Error loading PDF from URL');

        //         document.getElementById("pdf-canvas").style.display = "none";
        //         document.getElementById("fabric-canvas").style.display = "none";
        //         document.getElementById("annotation-canvas").style.display = "none";
        //         document.getElementById("text-layer").style.display = "none";
        //         document.querySelector(".upper-canvas").style.pointerEvents = "none";
        //     }
        // }

        // // New function to process annotations and load PDF only once
        // async function processAnnotations(pdfFile) {
        //     try {
        //         showToast('Processing PDF annotations...');

        //         const formData = new FormData();
        //         formData.append('file', pdfFile);

        //         const response = await fetch('/api/annotations/load', {
        //             method: 'POST',
        //             body: formData
        //         });


        //         if (!response.ok) {
        //             throw new Error('Failed to load annotations');
        //         }

        //         const data = await response.json();
        //         console.log("Received data from server:", {
        //             annotationsCount: Object.keys(data.annotations || {}).length,
        //             hasPdfContent: !!data.pdfContent,
        //             metadata: data.metadata
        //         });

        //         // Store annotations globally
        //         annotationsByPage = data.annotations || {};

        //         // Use the clean PDF if available, otherwise use the original
        //         let pdfBytes;
        //         if (data.pdfContent) {
        //             console.log("Using clean PDF from server");
        //             // Convert base64 to binary array
        //             const binaryString = atob(data.pdfContent);
        //             pdfBytes = new Uint8Array(binaryString.length);
        //             for (let i = 0; i < binaryString.length; i++) {
        //                 pdfBytes[i] = binaryString.charCodeAt(i);
        //             }
        //             showToast('Using PDF with annotations removed');
        //         } else {
        //             console.warn("No clean PDF received, using original");
        //             // Use the original PDF file
        //             const arrayBuffer = await pdfFile.arrayBuffer();
        //             pdfBytes = new Uint8Array(arrayBuffer);
        //         }

        //         // Load the PDF (either clean or original) only once
        //         pdfjsLib.getDocument({ data: pdfBytes }).promise.then((pdf) => {
        //             pdfDoc = pdf;
        //             generateThumbnails();
        //             renderAllPages();
        //             updateZoomPercent();
        //             addScrollListener();
        //             document.getElementById('page-num').textContent = pageNum;
        //             highlightThumbnail(pageNum);
        //             window.scrollTo(0, 0);

        //             // Apply annotations after PDF is loaded
        //             applyAnnotationsFromJSON(annotationsByPage);

        //             showToast('PDF loaded successfully');
        //         });

        //     } catch (error) {
        //         console.error('Error processing annotations:', error);
        //         showToast('Error processing annotations');

        //         // Fall back to loading the original PDF
        //         const arrayBuffer = await pdfFile.arrayBuffer();
        //         pdfjsLib.getDocument({ data: new Uint8Array(arrayBuffer) }).promise.then((pdf) => {
        //             pdfDoc = pdf;
        //             generateThumbnails();
        //             renderAllPages();
        //             updateZoomPercent();
        //             addScrollListener();
        //             document.getElementById('page-num').textContent = pageNum;
        //             highlightThumbnail(pageNum);
        //             window.scrollTo(0, 0);
        //             showToast('PDF loaded (original version)');
        //         });
        //     }
        // }

        // // Update loadPDFWithAnnotations to use the new processAnnotations function
        // async function loadPDFWithAnnotations(pdfFile) {
        //     await processAnnotations(pdfFile);
        // }



        //         // Add this function to your index.html
        // function applyAnnotationsFromJSON(annotationsData) {
        //     try {
        //         console.log("Applying annotations from JSON:", annotationsData);

        //         // Clear existing annotations on canvas
        //         fabricCanvas.clear();

        //         // Process annotations by page
        //         Object.entries(annotationsData).forEach(([pageNum, annotations]) => {
        //             // Skip if not current page
        //             if (parseInt(pageNum) !== currentPageNum) return;

        //             annotations.forEach(annotation => {
        //                 try {
        //                     const scaledAnnotation = convertPdfCoordsToCanvas(annotation, parseInt(pageNum));

        //                     switch (scaledAnnotation.type.toLowerCase()) {
        //                         case 'text':
        //                             applyTextAnnotation(scaledAnnotation);
        //                             break;
        //                         case 'highlight':
        //                             applyHighlightAnnotation(scaledAnnotation);
        //                             break;
        //                         case 'underline':
        //                             applyUnderlineAnnotation(scaledAnnotation);
        //                             break;
        //                         case 'strikeout':
        //                             applyStrikeoutAnnotation(scaledAnnotation);
        //                             break;
        //                         case 'square':
        //                             applySquareAnnotation(scaledAnnotation);
        //                             break;
        //                         case 'circle':
        //                             applyCircleAnnotation(scaledAnnotation);
        //                             break;
        //                         case 'line':
        //                             applyLineAnnotation(scaledAnnotation);
        //                             break;
        //                         case 'freedraw':
        //                             applyFreeDrawAnnotation(scaledAnnotation);
        //                             break;
        //                         case 'cloud':
        //                             applyCloudAnnotation(scaledAnnotation);
        //                             break;
        //                         case 'stamp':
        //                             applyStampAnnotation(scaledAnnotation);
        //                             break;
        //                         case 'signature':
        //                             applySignatureAnnotation(scaledAnnotation);
        //                             break;
        //                         default:
        //                             console.warn(`Unknown annotation type: ${scaledAnnotation.type}`);
        //                     }
        //                 } catch (err) {
        //                     console.error(`Error applying annotation: ${err.message}`, scaledAnnotation);
        //                 }
        //             });
        //         });

        //         fabricCanvas.renderAll();
        //     } catch (error) {
        //         console.error("Error applying annotations:", error);
        //         showToast('Error applying annotations');
        //     }
        // }

        // function convertPdfCoordsToCanvas(annotation, pageNum) {
        //     try {
        //         // Make a copy of the annotation to avoid modifying the original
        //         const scaledAnnotation = {...annotation};

        //         // Get the scale factor between PDF and canvas
        //         const scale = getScaleFactor();

        //         // Scale the coordinates
        //         if (scaledAnnotation.x1 !== undefined) scaledAnnotation.x1 = scaledAnnotation.x1 / scale.x;
        //         if (scaledAnnotation.y1 !== undefined) scaledAnnotation.y1 = scaledAnnotation.y1 / scale.y;
        //         if (scaledAnnotation.x2 !== undefined) scaledAnnotation.x2 = scaledAnnotation.x2 / scale.x;
        //         if (scaledAnnotation.y2 !== undefined) scaledAnnotation.y2 = scaledAnnotation.y2 / scale.y;
        //         if (scaledAnnotation.width !== undefined) scaledAnnotation.width = scaledAnnotation.width / scale.x;
        //         if (scaledAnnotation.height !== undefined) scaledAnnotation.height = scaledAnnotation.height / scale.y;

        //         return scaledAnnotation;
        //     } catch (error) {
        //         console.error("Error converting coordinates:", error);
        //         return annotation; // Return original if conversion fails
        //     }
        // }


        // // Helper functions for each annotation type
        // function applyTextAnnotation(annotation) {
        //     const textbox = new fabric.Textbox(annotation.text || "Enter Text", {
        //         left: annotation.x1,
        //         top: annotation.y1,
        //         width: annotation.width || 150,
        //         fontSize: annotation.fontSize || 16,
        //         fill: annotation.fill || 'black',
        //         id: annotation.id,
        //         selectable: true,
        //         evented: true,
        //         annotationType: 'text'
        //     });
        //     fabricCanvas.add(textbox);
        //     console.log("Successfully applied text annotation");
        // }

        // function applyHighlightAnnotation(annotation) {
        //     const rect = new fabric.Rect({
        //         left: annotation.x1,
        //         top: annotation.y1,
        //         width: annotation.x2 - annotation.x1,
        //         height: annotation.y2 - annotation.y1,
        //         fill: 'rgba(255, 255, 0, 0.3)',
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'highlight'
        //     });
        //     fabricCanvas.add(rect);
        //     console.log("Successfully applied highlight annotation");
        // }

        // function applyUnderlineAnnotation(annotation) {
        //     const line = new fabric.Line([
        //         annotation.x1,
        //         annotation.y2,
        //         annotation.x2,
        //         annotation.y2
        //     ], {
        //         stroke: 'red',
        //         strokeWidth: 1,
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'underline'
        //     });
        //     fabricCanvas.add(line);
        //     console.log("Successfully applied underline annotation");
        // }

        // function applyStrikeoutAnnotation(annotation) {
        //     const line = new fabric.Line([
        //         annotation.x1,
        //         (annotation.y1 + annotation.y2) / 2,
        //         annotation.x2,
        //         (annotation.y1 + annotation.y2) / 2
        //     ], {
        //         stroke: 'red',
        //         strokeWidth: annotation.strokeWidth || 1,
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'strikeout'
        //     });
        //     fabricCanvas.add(line);
        //     console.log("Successfully applied strikeout annotation");
        // }

        // function applySquareAnnotation(annotation) {
        //     const rect = new fabric.Rect({
        //         left: annotation.x1,
        //         top: annotation.y1,
        //         width: annotation.x2 - annotation.x1,
        //         height: annotation.y2 - annotation.y1,
        //         fill: 'transparent',
        //         stroke: 'red',
        //         strokeWidth: annotation.strokeWidth || 1,
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'square'
        //     });
        //     fabricCanvas.add(rect);
        //     console.log("Successfully applied square annotation");
        // }

        // function applyCircleAnnotation(annotation) {
        //     // Calculate radius based on width and height
        //     const width = Math.abs(annotation.x2 - annotation.x1);
        //     const height = Math.abs(annotation.y2 - annotation.y1);
        //     const radius = Math.min(width, height) / 2;

        //     // Calculate center point
        //     const centerX = annotation.x1 + width/2;
        //     const centerY = annotation.y1 + height/2;

        //     const circle = new fabric.Circle({
        //         left: centerX - radius,
        //         top: centerY - radius,
        //         radius: radius,
        //         fill: 'transparent',
        //         stroke: annotation.color || 'red',
        //         strokeWidth: annotation.strokeWidth || 2,
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'circle'
        //     });

        //     fabricCanvas.add(circle);
        //     console.log("Successfully applied circle annotation");
        // }


        // function applyLineAnnotation(annotation) {
        //     const line = new fabric.Line([
        //         annotation.x1,
        //         annotation.y1,
        //         annotation.x2,
        //         annotation.y2
        //     ], {
        //         stroke: 'red',
        //         strokeWidth: annotation.strokeWidth || 2,
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'line'
        //     });
        //     fabricCanvas.add(line);
        //     console.log("Successfully applied line annotation");
        // }

        // function applyFreeDrawAnnotation(annotation) {
        //     if (!annotation.path) return;

        //     const path = new fabric.Path(annotation.path.map(cmd => cmd.join(' ')).join(' '), {
        //         stroke: annotation.stroke || 'red',
        //         strokeWidth: annotation.strokeWidth || 2,
        //         fill: 'transparent',
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'freeDraw'
        //     });
        //     fabricCanvas.add(path);
        //     console.log("Successfully applied freeDraw annotation");
        // }

        // function applyCloudAnnotation(annotation) {
        //     if (!annotation.path) return;

        //     const path = new fabric.Path(annotation.path.map(cmd => cmd.join(' ')).join(' '), {
        //         stroke: annotation.stroke || 'red',
        //         strokeWidth: annotation.strokeWidth || 2,
        //         fill: 'transparent',
        //         selectable: true,
        //         evented: true,
        //         id: annotation.id,
        //         annotationType: 'cloud'
        //     });
        //     fabricCanvas.add(path);
        // }

        // function applyStampAnnotation(annotation) {
        //     // Check if we have image data
        //     if (!annotation.imageData) {
        //         console.warn('No image data for stamp annotation:', annotation.id);
        //         return;
        //     }

        //     // Create image URL from base64 data
        //     const imageUrl = `data:image/png;base64,${annotation.imageData}`;

        //     fabric.Image.fromURL(imageUrl, img => {
        //         img.set({
        //             left: annotation.x1,
        //             top: annotation.y1,
        //             width: annotation.width,
        //             height: annotation.height,
        //             selectable: true,
        //             evented: true,
        //             id: annotation.id,
        //             annotationType: 'stamp',
        //             crossOrigin: 'Anonymous'
        //         });
        //         fabricCanvas.add(img);
        //     }, { crossOrigin: 'Anonymous' });
        //     console.log("Successfully applied stamp annotation");
        // }

        // function applySignatureAnnotation(annotation) {
        //     // Check if we have image data
        //     if (!annotation.imageData) {
        //         console.warn('No image data for signature annotation:', annotation.id);
        //         return;
        //     }

        //     // Create image URL from base64 data
        //     const imageUrl = `data:image/png;base64,${annotation.imageData}`;

        //     fabric.Image.fromURL(imageUrl, img => {
        //         img.set({
        //             left: annotation.x1,
        //             top: annotation.y1,
        //             width: annotation.width,
        //             height: annotation.height,
        //             selectable: true,
        //             evented: true,
        //             id: annotation.id,
        //             annotationType: 'signature',
        //             crossOrigin: 'Anonymous'
        //         });
        //         fabricCanvas.add(img);
        //     }, { crossOrigin: 'Anonymous' });
        //     console.log("Successfully applied signature annotation");
        // }





        // ... existing code ...
        // async function loadPDFWithAnnotations(pdfFile) {
        //     try {
        //         // Show loading toast
        //         showToast('Processing PDF annotations...');

        //         // Create FormData and append the file
        //         const formData = new FormData();
        //         formData.append('file', pdfFile);

        //         // Fetch annotations from backend
        //         const response = await fetch('/api/annotations/load', {
        //             method: 'POST',
        //             body: formData
        //         });

        //         if (!response.ok) {
        //             throw new Error('Failed to load annotations');
        //         }

        //         const data = await response.json();
        //         console.log("Received data from server:", {
        //             annotationsCount: Object.keys(data.annotations || {}).length,
        //             hasPdfContent: !!data.pdfContent,
        //             metadata: data.metadata
        //         });

        //         // Store annotations globally
        //         annotationsByPage = data.annotations || {};

        //         // Use the clean PDF (with annotations removed) if available
        //         if (data.pdfContent) {
        //             console.log("Loading clean PDF from server response");

        //             // Convert base64 to binary array
        //             const binaryString = atob(data.pdfContent);
        //             const bytes = new Uint8Array(binaryString.length);
        //             for (let i = 0; i < binaryString.length; i++) {
        //                 bytes[i] = binaryString.charCodeAt(i);
        //             }

        //             // Load the clean PDF with PDF.js
        //             pdfjsLib.getDocument({ data: bytes }).promise.then((pdf) => {
        //                 // Replace the current PDF document
        //                 pdfDoc = pdf;

        //                 // Re-render everything with the clean PDF
        //                 generateThumbnails();
        //                 renderAllPages();
        //                 updateZoomPercent();
        //                 addScrollListener();
        //                 document.getElementById('page-num').textContent = pageNum;
        //                 highlightThumbnail(pageNum);
        //                 window.scrollTo(0, 0);

        //                 // Apply annotations to the clean PDF
        //                 applyAnnotationsFromJSON(annotationsByPage);

        //                 showToast('PDF loaded with annotations removed');
        //             }).catch(error => {
        //                 console.error("Error loading clean PDF:", error);
        //                 showToast('Error loading clean PDF');

        //                 // Fall back to applying annotations to the original PDF
        //                 applyAnnotationsFromJSON(annotationsByPage);
        //             });
        //         } else {
        //             console.warn("No clean PDF content received from server");
        //             // Just apply annotations to the current PDF
        //             applyAnnotationsFromJSON(annotationsByPage);
        //         }

        //     } catch (error) {
        //         console.error('Error loading annotations:', error);
        //         showToast('Error loading annotations');
        //     }
        // }






        // For Local Server App.py



        // window.onload = function() {
        //     // Get the PDF URL from the query parameters
        //     const urlParams = new URLSearchParams(window.location.search);
        //     const pdfUrl = urlParams.get('pdf');

        //     if (pdfUrl) {
        //         loadPdfFromUrl(pdfUrl);
        //     }
        // }


        // async function loadPdfFromUrl(url) {
        //     document.getElementById("pdf-canvas").style.display = "none";
        //         document.getElementById("fabric-canvas").style.display = "none";
        //         document.getElementById("annotation-canvas").style.display = "none";
        //         document.getElementById("text-layer").style.display = "none";
        //         document.querySelector(".upper-canvas").style.pointerEvents = "none";
        //     try {
        //         pdfContext.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
        //         fabricCanvas.clear();
        //         textLayer.innerHTML = '';
        //         const annotationCanvas = document.getElementById('annotation-canvas');
        //         const ctx = annotationCanvas.getContext('2d');
        //         ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

        //         annotationsByPage = {};
        //         annotations = [];

        //         showToast('Loading PDF...');

        //         document.getElementById("pdf-canvas").style.display = "block";
        //         document.getElementById("fabric-canvas").style.display = "block";
        //         document.getElementById("annotation-canvas").style.display = "block";
        //         document.getElementById("text-layer").style.display = "block";
        //         document.querySelector(".upper-canvas").style.pointerEvents = "auto";

        //         const proxyUrl = `/load-pdf/${encodeURIComponent(url)}`;
        //         const response = await fetch(proxyUrl);

        //         if (!response.ok) throw new Error('Failed to fetch PDF');
        //         const pdfData = await response.arrayBuffer();
        //         pdfjsLib.getDocument({ data: new Uint8Array(pdfData) }).promise.then((pdf) => {
        //             pdfDoc = pdf;
        //             generateThumbnails();
        //             renderAllPages();
        //             updateZoomPercent();
        //             addScrollListener();
        //             document.getElementById('page-num').textContent = pageNum;
        //             highlightThumbnail(pageNum);
        //             window.scrollTo(0, 0);
        //             showToast('PDF loaded successfully');
        //         });

        //         toggleThumbnails();
        //     } catch (error) {
        //         console.error('Error loading PDF:', error);
        //         showToast('Error loading PDF from URL');

        //         document.getElementById("pdf-canvas").style.display = "none";
        //         document.getElementById("fabric-canvas").style.display = "none";
        //         document.getElementById("annotation-canvas").style.display = "none";
        //         document.getElementById("text-layer").style.display = "none";
        //         document.querySelector(".upper-canvas").style.pointerEvents = "none";
        //     }
        // }        



        // document.getElementById("pdf-canvas").style.display = "none";
        // document.getElementById("fabric-canvas").style.display = "none";
        // document.getElementById("annotation-canvas").style.display = "none";
        // document.getElementById("text-layer").style.display = "none";
        // document.querySelector(".upper-canvas").style.pointerEvents = "none";

        // document.getElementById("file-input").addEventListener("change", (event) => {
        //     const file = event.target.files[0];

        //     if (file) {
        //         // showToast('Opening PDF file...');

        //         // resetCanvas();
        //         pdfContext.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
        //         fabricCanvas.clear();
        //         textLayer.innerHTML = '';
        //         const annotationCanvas = document.getElementById('annotation-canvas');
        //         const ctx = annotationCanvas.getContext('2d');

        //         ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height); 

        //         annotationsByPage = {};
        //         annotations = []; 



        //         document.getElementById("pdf-canvas").style.display = "block";
        //         document.getElementById("fabric-canvas").style.display = "block";
        //         document.getElementById("annotation-canvas").style.display = "block";
        //         document.getElementById("text-layer").style.display = "block";

        //         document.querySelector(".upper-canvas").style.pointerEvents = "auto";
        //         const reader = new FileReader();
        //         reader.onload = function (e) {
        //             const pdfData = new Uint8Array(e.target.result);
        //             pdfjsLib.getDocument({ data: pdfData }).promise.then((pdf) => {
        //                 pdfDoc = pdf;
        //                 generateThumbnails();
        //                 renderAllPages();
        //                 updateZoomPercent();
        //                 addScrollListener();
        //                 document.getElementById('page-num').textContent = pageNum;
        //                 highlightThumbnail(pageNum);
        //                 window.scrollTo(0, 0);

        //             });
        //         };
        //         reader.readAsArrayBuffer(file);
        //         toggleThumbnails();
        //     } else {

        //         document.getElementById("pdf-canvas").style.display = "none";
        //         document.getElementById("fabric-canvas").style.display = "none";
        //         document.getElementById("annotation-canvas").style.display = "none";
        //         document.getElementById("text-layer").style.display = "none";
        //         document.querySelector(".upper-canvas").style.pointerEvents = "none";
        //     }
        // });



        function generateThumbnails() {
            thumbnailsContainer.innerHTML = "";
            const renderPromises = [];

            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'thumbnail-wrapper thumbnail-loading';

                const placeholder = document.createElement('div');
                placeholder.style.width = '100%';
                placeholder.style.height = '150px';
                wrapper.appendChild(placeholder);

                const pageNumber = document.createElement('div');
                pageNumber.className = 'page-number';
                pageNumber.textContent = `Page ${i}`;
                wrapper.appendChild(pageNumber);

                thumbnailsContainer.appendChild(wrapper);
                renderPromises.push(
                    pdfDoc.getPage(i).then((page) => {
                        const viewport = page.getViewport({ scale: 0.2 });
                        const thumbnailCanvas = document.createElement("canvas");
                        thumbnailCanvas.width = viewport.width;
                        thumbnailCanvas.height = viewport.height;
                        const context = thumbnailCanvas.getContext("2d");
                        const renderContext = {
                            canvasContext: context,
                            viewport: viewport,
                        };

                        return page.render(renderContext).promise.then(() => {
                            thumbnailCanvas.setAttribute('data-page', i);
                            thumbnailCanvas.addEventListener("click", () => {
                                const targetPage = document.querySelector(`.pdf-page[data-page-number="${i}"]`);
                                if (targetPage) {
                                    targetPage.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                    highlightThumbnail(i);
                                    document.getElementById('page-num').textContent = i;
                                    pageNum = i;
                                }
                            });

                            wrapper.innerHTML = '';
                            wrapper.appendChild(thumbnailCanvas);
                            wrapper.appendChild(pageNumber);
                            wrapper.classList.remove('thumbnail-loading');

                            return wrapper;
                        });
                    })
                );
            }

            Promise.all(renderPromises).then(() => {
                highlightThumbnail(pageNum);
            });
        }

        function highlightThumbnail(pageNum) {
            const thumbnails = document.querySelectorAll("#thumbnails canvas");

            thumbnails.forEach((thumbnail) => {
                const wrapper = thumbnail.parentElement;
                const currentPage = parseInt(thumbnail.getAttribute('data-page'));

                if (currentPage === pageNum) {
                    thumbnail.classList.add('thumbnail-active');

                    const container = document.getElementById('thumbnail-container');
                    const wrapperRect = wrapper.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();

                    const scrollTop = wrapper.offsetTop - (container.clientHeight / 2) + (wrapperRect.height / 2);

                    container.scrollTo({
                        top: scrollTop,
                        behavior: 'smooth'
                    });
                } else {
                    thumbnail.classList.remove('thumbnail-active');
                }
            });
        }



        function addScrollListener() {
            let scrollTimeout;
            const pdfContainer = document.getElementById('pdf-container');

            // Change from window to pdfContainer
            pdfContainer.addEventListener('scroll', () => {
                if (scrollTimeout) {
                    clearTimeout(scrollTimeout);
                }
                scrollTimeout = setTimeout(() => {
                    const visiblePage = getMostVisiblePage();
                    if (visiblePage) {
                        highlightThumbnail(visiblePage);
                        document.getElementById('page-num').textContent = visiblePage;
                        pageNum = visiblePage;
                    }
                }, 50);
            });
        }

        function getMostVisiblePage() {
            const pdfContainer = document.getElementById('pdf-container');
            const pages = pdfContainer.querySelectorAll('.pdf-page');
            let maxVisibleArea = 0;
            let mostVisiblePage = 1;

            pages.forEach(page => {
                const rect = page.getBoundingClientRect();
                const containerRect = pdfContainer.getBoundingClientRect();
                const pageNum = parseInt(page.dataset.pageNumber);

                const visibleTop = Math.max(rect.top, containerRect.top);
                const visibleBottom = Math.min(rect.bottom, containerRect.bottom);
                const visibleHeight = Math.max(0, visibleBottom - visibleTop);
                const visibleArea = visibleHeight * rect.width;

                if (visibleArea > maxVisibleArea) {
                    maxVisibleArea = visibleArea;
                    mostVisiblePage = pageNum;
                }
            });

            return mostVisiblePage;
        }


        function renderDrawingAnnotation(annotation, fabricCanvas) {
            if (['highlight', 'underline', 'strikeout'].includes(annotation.type)) {
                return;
            }
            let obj;

            const left = annotation.x1;
            const top = annotation.y1;
            const width = (annotation.x2 - annotation.x1);
            const height = (annotation.y2 - annotation.y1);

            switch (annotation.type) {


                case 'square':
                    obj = new fabric.Rect({
                        left: left,
                        top: top,
                        width: width,
                        height: height,
                        fill: '',
                        stroke: annotation.stroke || 'red',
                        strokeWidth: (annotation.strokeWidth || 2),
                    });
                    break;
                case 'line':
                    obj = new fabric.Line(
                        [left, top, annotation.x2, annotation.y2],
                        {
                            stroke: annotation.stroke || 'red',
                            strokeWidth: (annotation.strokeWidth || 2),
                        }
                    );
                    break;
                case 'circle':
                    obj = new fabric.Circle({
                        left: left,
                        top: top,
                        radius: annotation.radius,
                        fill: annotation.fill || 'transparent',
                        stroke: annotation.stroke || 'red',
                        strokeWidth: (annotation.strokeWidth || 2),
                    });
                    break;
                case 'text':
                    obj = new fabric.Textbox(annotation.content || 'Enter Text', {
                        left: left,
                        top: top,
                        fontSize: (annotation.fontSize || 20),
                        fill: annotation.fill || 'black',
                    });
                    break;
                case 'freeDraw':
                    obj = new fabric.Path(annotation.path, {
                        stroke: annotation.stroke || 'red',
                        strokeWidth: (annotation.strokeWidth || 2) * currentScale,
                        fill: '',
                        left: annotation.x1,
                        top: annotation.y1,
                        id: annotation.id,
                        annotationType: 'freeDraw',
                    });
                    break;
                case 'cloud':
                    obj = new fabric.Path(annotation.path, {
                        fill: 'transparent',
                        stroke: annotation.stroke || 'blue',
                        strokeWidth: (annotation.strokeWidth || 2) * currentScale,
                    });
                    break;

                case 'stamp':
                    fabric.Image.fromURL(annotation.imgSrc, function (img) {
                        const StampsScaleFactor = annotation.scaleFactor || 0.6;
                        img.scale(StampsScaleFactor);
                        img.set({
                            left: left,
                            top: top,
                            // width: width,
                            // height: height,
                            originX: 'left',
                            originY: 'top',
                            selectable: true,
                            evented: true,
                        });
                        fabricCanvas.add(img);
                        console.log("Stamp Annotation:", annotation);
                    });
                    break;
                case 'signature':
                    fabric.Image.fromURL(annotation.dataURL, function (img) {
                        const SigniturescaleFactor = annotation.scaleFactor || 0.4;
                        img.scale(SigniturescaleFactor);
                        img.set({
                            left: left,
                            top: top,
                            originX: 'left',
                            originY: 'top',
                            selectable: true,
                            evented: true,

                        });
                        fabricCanvas.add(img);
                    });
                    break;
                case 'textCallout':
                // Create the text box
                case 'textCallout':
                    // Create the text box
                    const textBox = new fabric.Textbox(annotation.content || '', {
                        left: annotation.textLeft,
                        top: annotation.textTop,
                        fontSize: 13,
                        fill: annotation.textColor || 'red',
                        backgroundColor: 'white',
                        strokeWidth: 0.5,
                        stroke: annotation.borderColor || 'red',
                        strokeUniform: true,
                        padding: 5,
                        width: annotation.textWidth || 75,
                        editable: true,
                        showTextBoxBorder: true,
                        hasControls: true
                    });

                    // Get arrow start and end points
                    const arrowStart = annotation.arrowStart || [0, 0];
                    const arrowEnd = annotation.arrowEnd || [0, 0];

                    const arrow = createArrow([
                        arrowStart[0],
                        arrowStart[1],
                        arrowEnd[0],
                        arrowEnd[1]
                    ], {
                        stroke: annotation.arrowColor || 'red',
                        strokeWidth: 1.5,
                        fill: annotation.arrowColor || 'red'
                    });


                    // Generate callout ID if it doesn't exist
                    const calloutId = annotation.id;

                    // Set properties for arrow and text box
                    arrow.set({
                        id: calloutId + '_arrow',
                        calloutId: calloutId,
                        annotationType: 'textCallout',
                        startX: arrowStart[0],
                        startY: arrowStart[1],
                        endX: arrowEnd[0],
                        endY: arrowEnd[1],
                        selectable: false,
                        hasControls: false
                    });

                    textBox.set({
                        id: calloutId + '_text',
                        calloutId: calloutId,
                        annotationType: 'textCallout',
                        selectable: true
                    });

                    // Add both elements to canvas
                    fabricCanvas.add(arrow);
                    fabricCanvas.add(textBox);

                    // Store reference to the callout elements in the canvas for future updates
                    fabricCanvas.calloutElements = fabricCanvas.calloutElements || {};
                    fabricCanvas.calloutElements[calloutId] = {
                        textBox: textBox,
                        arrow: arrow,
                        startPoint: { x: arrowStart[0], y: arrowStart[1] }
                    };

                    textBox.on('moving', function () {
                        updateCalloutArrow(fabricCanvas, calloutId);
                    });

                    textBox.on('moved', function () {
                        updateCalloutArrow(fabricCanvas, calloutId, true);
                    });

                    textBox.on('editing:exited', function () {
                        updateTextCalloutContent(calloutId, textBox.text);
                    });

                    textBox.on('changed', function () {
                        updateTextCalloutContent(calloutId, textBox.text);
                    });

                    return null;


                default:
                    console.warn('Unknown annotation type:', annotation.type);
                    return;
            }

            if (obj) {
                obj.id = annotation.id;
                fabricCanvas.add(obj);
            }
        }

        function renderAnnotationsForPage(pageNum, annotations, viewport, textLayer) {
            let fabricCanvas = fabricCanvases[pageNum];
            if (!fabricCanvas) {
                console.error("Fabric.js canvas not found for page:", pageNum);
                return;
            }
            fabricCanvas.clear();
            annotations.forEach(annotation => {
                renderDrawingAnnotation(annotation, fabricCanvas);
            });

            setAlwaysVisibleBorders();

            // setupAnnotationPositionUpdaters();   New one 

        }


        async function renderAllPages() {
            const pdfContainer = document.getElementById('pdf-container');
            pdfContainer.innerHTML = '';

            // Create placeholder divs for all pages
            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                const pageWrapper = document.createElement('div');
                pageWrapper.classList.add('pdf-page');
                pageWrapper.style.position = 'relative';
                pageWrapper.style.marginBottom = '10px';
                pageWrapper.dataset.pageNumber = pageNum;

                pdfDoc.getPage(pageNum).then(page => {
                    const viewport = page.getViewport({ scale: currentScale });
                    pageWrapper.style.width = `${viewport.width}px`;
                    pageWrapper.style.height = `${viewport.height}px`;
                });
                pageWrapper.innerHTML = `<div class="page-loading">Loading page ${pageNum}...</div>`;
                pdfContainer.appendChild(pageWrapper);
            }

            // Set up Intersection Observer
            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const pageNum = parseInt(entry.target.dataset.pageNumber);
                        renderPage(pageNum).then(() => {
                            // Unobserve after rendering
                            observer.unobserve(entry.target);
                        });
                    }
                });
            }, {
                root: null,
                rootMargin: '10px 0px',
                threshold: 0.1
            });

            // Observe all page wrappers
            document.querySelectorAll('.pdf-page').forEach(pageWrapper => {
                observer.observe(pageWrapper);
            });

            // Render the first visible page immediately
            const visiblePage = getMostVisiblePage() || 1;
            await renderPage(visiblePage);
            highlightThumbnail(visiblePage);
            document.getElementById('page-num').textContent = visiblePage;
        }

        function renderPage(num) {
            return new Promise((resolve) => {
                const pageWrapper = document.querySelector(`.pdf-page[data-page-number="${num}"]`);
                if (!pageWrapper) {
                    console.error(`Page wrapper ${num} not found`);
                    resolve();
                    return;
                }

                // Clear the loading placeholder
                pageWrapper.innerHTML = '';
                currentPageNum = num;

                pdfDoc.getPage(num).then(page => {
                    const viewport = page.getViewport({ scale: currentScale });

                    // Create and append canvas elements
                    const pdfCanvas = document.createElement('canvas');
                    pdfCanvas.classList.add('pdf-canvas');
                    pdfCanvas.width = viewport.width;
                    pdfCanvas.height = viewport.height;
                    pageWrapper.appendChild(pdfCanvas);

                    attachFabricCanvas(pageWrapper, viewport, num);

                    const annotationCanvas = document.createElement('canvas');
                    annotationCanvas.classList.add('annotation-canvas');
                    annotationCanvas.width = viewport.width;
                    annotationCanvas.height = viewport.height;
                    annotationCanvas.style.position = 'absolute';
                    annotationCanvas.style.top = '0';
                    annotationCanvas.style.left = '0';
                    annotationCanvas.style.pointerEvents = 'none';
                    pageWrapper.appendChild(annotationCanvas);

                    // Render PDF content
                    const pdfContext = pdfCanvas.getContext('2d');
                    const renderContext = {
                        canvasContext: pdfContext,
                        viewport: viewport,
                    };

                    page.render(renderContext).promise.then(() => {
                        const fabricCanvas = fabricCanvases[num];
                        if (fabricCanvas) {
                            fabricCanvas.setWidth(viewport.width);
                            fabricCanvas.setHeight(viewport.height);
                            fabricCanvas.setZoom(currentScale);
                        }

                        renderTextLayer(page, viewport, pageWrapper, num);
                        const ctx = initializeAnnotationCanvas(viewport, pageWrapper);
                        if (ctx) {
                            renderAnnotations(num, ctx, viewport);
                        }

                        if (annotationsByPage[num]) {
                            renderAnnotationsForPage(num, annotationsByPage[num], viewport, textLayer);
                        }

                        resolve();
                    });
                });
            });
        }

        // Add some CSS for the loading state
        const style = document.createElement('style');
        style.textContent = `
    .page-loading {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
        font-size: 1.2em;
        color: #666;
        background: #f5f5f5;
    }
`;
        document.head.appendChild(style);


        let fabricCanvases = {};

        function attachFabricCanvas(pageWrapper, viewport, num) {
            const fabricCanvasElement = document.createElement('canvas');
            fabricCanvasElement.width = viewport.width;
            fabricCanvasElement.height = viewport.height;
            pageWrapper.appendChild(fabricCanvasElement);

            const fabricCanvas = new fabric.Canvas(fabricCanvasElement, {
                selection: true,
                selectionColor: 'rgba(0, 0, 0, 0)',
                selectionBorderColor: 'rgba(0, 0, 0, 0)',
                selectionLineWidth: 0,
                willReadFrequently: true
            });

            fabricCanvas.setZoom(currentScale);
            fabricCanvases[num] = fabricCanvas;

            //  setupAnnotationPositionUpdaters();  

        }


        function renderTextLayer(page, viewport, pageWrapper, pageNum) {
            let existingTextLayer = pageWrapper.querySelector('.text-layer');
            if (existingTextLayer) {
                existingTextLayer.remove();
            }
            const textLayerDiv = document.createElement('div');
            textLayerDiv.dataset.pageNumber = pageNum;

            textLayerDiv.innerHTML = `
        <style>
           .text-layer {
                position: absolute;
                top: 0;
                left: 0;
                overflow: visible;
                pointer-events: none; 
                transform-origin: 0 0;
                background: rgba(255, 255, 255, 0.001); 
                will-change: transform;
                mix-blend-mode: multiply;
            }
                
            .text-layer span {
                pointer-events: all;
                position: absolute;
                white-space: pre;
                color: transparent;
                background: transparent;
                transform-origin: 0 0;
                user-select: text;
                transition: background-color 0.15s ease;
                -webkit-text-fill-color: transparent;
            }

            .text-layer span::selection {
                background: rgba(0, 120, 215, 0.3);
                color: transparent;
                transition: background-color 0.15s ease;
                
            }

            .text-layer span::-moz-selection {
                background: rgba(0, 120, 215, 0.3);
                color: transparent;
                transition: background-color 0.15s ease;
            }

            .text-layer span + span {
                margin-left: -0.5px;
            }
        </style>
    `;
            textLayerDiv.classList.add('text-layer');
            pageWrapper.appendChild(textLayerDiv);
            page.getTextContent().then(textContent => {
                pdfjsLib.renderTextLayer({
                    textContent,
                    container: textLayerDiv,
                    viewport,
                    textDivs: [],
                    enhanceTextSelection: true,
                }).promise.then(() => {
                    setupTextLayerEventListeners(pageWrapper, pageNum);
                });
            });
        }



        function stopAnnotationMode() {
            annotationMode = null;
            console.log("Annotation mode stopped");
            window.getSelection().removeAllRanges();
        }


        let annotationMode = null;
        document.getElementById('highlight').addEventListener('click', () => {
            if (annotationMode === 'highlight') {
                stopAnnotationMode();
                enableSelectMode();
            } else {
                annotationMode = 'highlight';
                console.log("Annotation mode set to highlight");
                enableTextLayer();
            }
        });

        document.getElementById('underline').addEventListener('click', () => {
            if (annotationMode === 'underline') {
                stopAnnotationMode();
                enableSelectMode();
            } else {
                annotationMode = 'underline';
                console.log("Annotation mode set to underline");
                enableTextLayer();
            }
        });

        document.getElementById('strikeout').addEventListener('click', () => {
            if (annotationMode === 'strikeout') {
                stopAnnotationMode();
                enableSelectMode();
            } else {
                annotationMode = 'strikeout';
                console.log("Annotation mode set to strikeout");
                enableTextLayer();
            }
        });
        document.addEventListener('DOMContentLoaded', () => {
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                if (!['highlight', 'underline', 'strikeout'].includes(button.id)) {
                    button.addEventListener('click', () => {
                        if (annotationMode !== null) {
                            stopAnnotationMode();
                            enableSelectMode();
                        }
                    });
                }
            });
        });

        function cancelAnnotation() {
            console.log("Canceling annotation...");
            window.getSelection().removeAllRanges();

            if (currentAnnotationType === 'stamp') {
                stopStampProcess();
            }

            annotationMode = null;
            fabricCanvas.isDrawingMode = false;
            isDrawing = false;
            currentAnnotationType = null;
            enableSelectMode();
        }



        function setupTextLayerEventListeners(pageWrapper, pageNum) {
            const textLayer = pageWrapper.querySelector('.text-layer');
            if (!textLayer) {
                console.error("Text layer not found");
                return;
            }

            textLayer.dataset.pageNumber = pageNum;
            console.log(`Setting up text layer listeners for page ${pageNum}`);

            textLayer.addEventListener('mouseup', (event) => {
                console.log("Mouse up event on page:", pageNum);

                // console.log("Mouse up event triggered");
                const selection = window.getSelection();

                const actualPageNum = parseInt(textLayer.dataset.pageNumber);
                console.log(`Creating annotation on page ${actualPageNum}`);


                // console.log("Selection:", selection);
                // console.log("Annotation Mode:", annotationMode);

                if (!selection || selection.isCollapsed || !annotationMode) {
                    console.log("Selection invalid or no annotation mode");
                    return;
                }

                const range = selection.getRangeAt(0);
                const text = selection.toString().trim();
                // console.log("Selected Text:", text);
                // console.log("Range:", range);

                if (!text) {
                    console.log("No text selected");
                    return;
                }

                //   const textLayer = document.getElementById('text-layer');
                if (!textLayer.contains(range.commonAncestorContainer)) {
                    console.log("Selection not within text layer");
                    return;
                }

                const rects = Array.from(range.getClientRects());
                const textLayerRect = textLayer.getBoundingClientRect();

                let uniqueRects = [];
                const annotationsToAdd = [];

                rects.forEach((rect) => {
                    let merged = false;

                    uniqueRects.forEach((uniqueRect) => {
                        const isSameLine = Math.abs(uniqueRect.top - rect.top) < rect.height * 0.7; // Allow slight variation for same line
                        const overlapX = Math.min(uniqueRect.right, rect.right) > Math.max(uniqueRect.left, rect.left);
                        const overlapY = Math.min(uniqueRect.bottom, rect.bottom) > Math.max(uniqueRect.top, rect.top); // Vertical overlap

                        if (isSameLine && overlapX && overlapY) {
                            uniqueRect.left = Math.min(uniqueRect.left, rect.left);
                            uniqueRect.top = Math.min(uniqueRect.top, rect.top);
                            uniqueRect.right = Math.max(uniqueRect.right, rect.right);
                            uniqueRect.bottom = Math.max(uniqueRect.bottom, rect.bottom);
                            uniqueRect.width = uniqueRect.right - uniqueRect.left;
                            uniqueRect.height = uniqueRect.bottom - uniqueRect.top;
                            merged = true;
                        }
                    });

                    if (!merged) {
                        uniqueRects.push({
                            left: rect.left,
                            top: rect.top,
                            right: rect.right,
                            bottom: rect.bottom,
                            width: rect.width,
                            height: rect.height,
                        });
                    }
                });

                uniqueRects = uniqueRects.filter((rect) => rect.width > 0 && rect.height > 0);

                console.log("Merged Rectangles:", uniqueRects);

                const startIndex = range.startOffset;
                const endIndex = range.endOffset;
                const lineAnnotations = [];


                uniqueRects.forEach((rect) => {
                    const lineAnnotation = {
                        left: (rect.left - textLayerRect.left) / currentScale,
                        top: (rect.top - textLayerRect.top) / currentScale,
                        width: rect.width / currentScale,
                        height: rect.height / currentScale,

                    };
                    console.log('Line Annotation:', lineAnnotation);
                    lineAnnotations.push(lineAnnotation);
                    drawAnnotation(rect, annotationMode, textLayerRect, pageWrapper);
                });



                const annotationId = Date.now() + Math.random().toString(36).substr(2, 9); // Unique ID
                const annotation = {
                    id: annotationId,
                    //   mode: annotationMode,
                    type: annotationMode,
                    text,
                    startIndex,
                    endIndex,
                    page: actualPageNum,
                    scale: currentScale,
                    lineAnnotations,
                    title: `${annotationMode} Annotation`,
                    content: `This is a ${annotationMode} annotation`,
                    subject: `This is a ${annotationMode} annotation`,
                };
                console.log('Annotation:', annotationMode, annotation);
                if (['highlight', 'underline', 'strikeout'].includes(annotationMode)) {
                    // uniqueRects.forEach(() => {
                    storeTextAnnotation(annotationMode, annotation);
                    console.log("Annotation stored for page:", actualPageNum);

                    // });
                }

                textRedoStack = [];
                const annotationsMap = {};
                annotationsMap[annotationId] = annotation;
                console.log('Annotations Map:', annotationsMap);

                console.log('Annotations Before:', annotations);
                annotations.push(annotation);
                console.log('Annotations After :', annotations);
                annotationsToAdd.push(annotation);
                console.log('Annotations annotationtoadd:', annotationsToAdd);




                textUndoStack.push({ type: 'add', annotations: annotationsToAdd });
                textRedoStack = [];

                selection.removeAllRanges();
                //   annotationMode = null;

            });
        }
        // setupTextLayerEventListeners();



        function drawAnnotation(rect, mode, textLayerRect, pageWrapper) {
            console.log("Drawing annotation:", mode, rect);
            const canvas = pageWrapper.querySelector('.annotation-canvas');
            if (!canvas) {
                console.error("Annotation canvas not found");
                return;
            }
            console.log("Annotation canvas dimensions:", canvas.width, canvas.height);
            const ctx = canvas.getContext('2d');


            ctx.lineWidth = 1;
            ctx.strokeStyle = 'red';

            switch (mode) {
                case 'highlight':
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.fillRect(
                        rect.left - textLayerRect.left,
                        rect.top - textLayerRect.top,
                        rect.width,
                        rect.height
                    );
                    break;
                case 'underline':
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(
                        rect.left - textLayerRect.left,
                        rect.bottom - textLayerRect.top - 3
                    );
                    ctx.lineTo(
                        rect.right - textLayerRect.left,
                        rect.bottom - textLayerRect.top - 3
                    );
                    ctx.stroke();
                    break;
                case 'strikeout':
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(
                        rect.left - textLayerRect.left,
                        rect.top - textLayerRect.top + rect.height / 2 - 4
                    );
                    ctx.lineTo(
                        rect.right - textLayerRect.left,
                        rect.top - textLayerRect.top + rect.height / 2 - 4
                    );
                    ctx.stroke();
                    break;
            }


        }



        function drawAnnotationFromData(annotation) {
            const textLayer = document.getElementById('text-layer');
            if (!annotation.lineAnnotations || annotation.lineAnnotations.length === 0) {
                console.error('No lineAnnotations in annotation:', annotation);
                return;
            }
            const textLayerRect = textLayer.getBoundingClientRect();

            const canvas = document.getElementById('annotation-canvas');
            const ctx = canvas.getContext('2d');

            annotation.lineAnnotations.forEach((rect) => {
                const left = rect.left * currentScale;
                const top = rect.top * currentScale;
                const width = rect.width * currentScale;
                const height = rect.height * currentScale;

                switch (annotation.mode) {
                    case 'highlight':
                        drawHighlight({ left, top, width, height }, ctx);
                        break;
                    case 'underline':
                        drawLine({ left, top, width, height }, 'underline', ctx);
                        break;
                    case 'strikeout':
                        drawLine({ left, top, width, height }, 'strikeout', ctx);
                        break;
                }
            });
        }


        function applyAnnotation(span, mode) {
            const canvas = document.getElementById('annotation-canvas');
            if (!canvas) {
                console.error('Annotation canvas not found!');
                return;
            }

            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Failed to get 2D context for annotation canvas.');
                return;
            }

            switch (mode) {
                case 'highlight':
                    drawHighlight(span, ctx, canvas);
                    break;
                case 'underline':
                    drawLine(span, 'underline', ctx, canvas);
                    break;
                case 'strikeout':
                    drawLine(span, 'strikeout', ctx, canvas);
                    break;
            }
        }

        function initializeAnnotationCanvas(viewport, pageWrapper) {
            const annotationCanvas = pageWrapper.querySelector('.annotation-canvas');

            if (!annotationCanvas) {
                console.error('Annotation canvas not found!');
                return null;
            }

            annotationCanvas.width = viewport.width;
            annotationCanvas.height = viewport.height;
            annotationCanvas.style.position = 'absolute';
            annotationCanvas.style.top = '0';
            annotationCanvas.style.left = '0';
            annotationCanvas.style.pointerEvents = 'none';

            return annotationCanvas.getContext('2d');
        }

        function drawHighlight(rect, ctx) {
            ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
            ctx.fillRect(rect.left, rect.top, rect.width, rect.height);
        }

        function drawLine(rect, mode, ctx) {
            let lineY;

            if (mode === 'underline') {
                lineY = rect.top + rect.height - 2;
                ctx.strokeStyle = 'red';
            } else if (mode === 'strikeout') {
                lineY = rect.top + rect.height / 2 - 4;
            }

            ctx.strokeStyle = 'red';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(rect.left, lineY);
            ctx.lineTo(rect.left + rect.width, lineY);
            ctx.stroke();
        }


        function renderAnnotations(pageNum, ctx, viewport) {
            if (!annotationsByPage.hasOwnProperty(pageNum)) {
                console.log(`No annotations for page ${pageNum}, skipping render`);
                return;
            }

            let pageAnnotations = annotationsByPage[pageNum];
            console.log(`Rendering annotations specifically for page ${pageNum}:`, pageAnnotations);

            pageAnnotations = JSON.parse(JSON.stringify(pageAnnotations));

            ctx.clearRect(0, 0, viewport.width, viewport.height);

            if (!Array.isArray(pageAnnotations) || pageAnnotations.length === 0) {
                console.log(`No valid annotations for page ${pageNum}`);
                return;
            }

            pageAnnotations.forEach(annotation => {
                if (!annotation.lineAnnotations) {
                    console.log('Invalid annotation format:', annotation);
                    return;
                }

                annotation.lineAnnotations.forEach(rect => {
                    const left = rect.left * currentScale;
                    const top = rect.top * currentScale;
                    const width = rect.width * currentScale;
                    const height = rect.height * currentScale;

                    if (width > 0 && height > 0) {
                        switch (annotation.type) {
                            case 'highlight':
                                drawHighlight({ left, top, width, height }, ctx);
                                break;
                            case 'underline':
                                drawLine({ left, top, width, height }, 'underline', ctx);
                                break;
                            case 'strikeout':
                                drawLine({ left, top, width, height }, 'strikeout', ctx);
                                break;
                        }
                    }
                });
            });
        }

        function disableTextLayer() {
            const textLayerDiv = document.querySelector('.text-layer');
            if (textLayerDiv) {
                console.log('Disabling text layer');
                textLayerDiv.style.display = 'none';
            }
        }

        function enableTextLayer() {
            const textLayerDiv = document.querySelector('.text-layer');
            if (textLayerDiv) {
                console.log('Enabling text layer');
                textLayerDiv.style.display = 'block';
            }
        }



        //         function deleteSelectedAnnotation() {
        //     const activeObject = fabricCanvas.getActiveObject(); 

        //     if (activeObject) {
        //         const annotationIndex = annotationsByPage[pageNum]?.findIndex((ann) => ann.id === activeObject.id);

        //         if (annotationIndex !== -1) {
        //             annotationsByPage[pageNum].splice(annotationIndex, 1); 
        //             console.log("Annotation removed from annotationsByPage:", activeObject.id);
        //         }

        //         fabricCanvas.remove(activeObject); 
        //         console.log("Annotation deleted from canvas:", activeObject); 

        //         const sidebarItem = document.getElementById(`annotation-${activeObject.id}`);
        //         if (sidebarItem) {
        //             sidebarItem.remove();  
        //             console.log("Annotation removed from sidebar:", activeObject.id);
        //         }

        //         const isSelectionEnabled = document.getElementById('toggle-selection').checked;
        //         if (!isSelectionEnabled) {
        //             enableTextLayer();
        //         }

        //         fabricCanvas.renderAll();
        //     } else {
        //         console.log("No annotation selected to delete");
        //     }

        // }


        // document.getElementById('delete-annotation-btn').addEventListener('click', deleteSelectedAnnotation);

        // document.getElementById('toggle-selection').addEventListener('change', function () {
        //     const isChecked = this.checked;
        //     if (isChecked) {
        //         fabricCanvas.selection = true;
        //         fabricCanvas.forEachObject(obj => {
        //             obj.selectable = true;
        //         });
        //         disableTextLayer();
        //     } else {
        //         fabricCanvas.selection = false;
        //         fabricCanvas.forEachObject(obj => {
        //             obj.selectable = false;
        //         });
        //         enableTextLayer();
        //     }
        //     fabricCanvas.renderAll();
        // });

        let annotations = [];

        let currentAnnotationType = null;

        function setAnnotationMode(type) {
            currentAnnotationType = type;
            document.body.style.cursor = type ? 'text' : 'default';
        }

        function getScaleFactor() {
            return {
                x: pdfCanvas.width / fabricCanvas.getWidth(),
                y: pdfCanvas.height / fabricCanvas.getHeight(),
            };
        }

        function prevPage() {
            if (pageNum <= 1) return;
            pageNum--;
            renderAllPages();
        }
        function nextPage() {
            if (pageNum >= pdfDoc.numPages) return;
            pageNum++;
            renderAllPages();
        }







        function sendAnnotationToBackend(annotation) {
            console.log("Original annotation data:", annotation);

            fetch('/proxy/annotation', {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                },
                body: JSON.stringify(annotation)
            })
                .then(response => {
                    console.log("Response status:", response.status);
                    console.log("Response headers:", response.headers);
                    console.log("Full response:", response);

                    if (response.ok) {
                        return response.json().then(json => {
                            console.log("Response body (JSON):", json);
                        });
                    } else {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                })
                .catch(error => {
                    console.error("Error details:", {
                        message: error.message,
                        name: error.name,
                        stack: error.stack
                    });
                });
        }

        function generateGuid() {
            function s4() {
                return Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1);
            }
            return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                s4() + '-' + s4() + s4() + s4();
        }


        let sessionDocumentId = generateGuid();
        let sessionUserId = generateGuid();

        function storeTextAnnotation(type, obj) {


            // console.log("Storing text annotation:", mode, annotation);

            const scaleFactor = getScaleFactor();
            const pageNumber = obj.page;
            console.log('storeTextAnnotation called for page:', pageNumber);

            if (!annotationsByPage[pageNumber]) {
                console.log('Initializing annotations array for page:', pageNumber);
                annotationsByPage[pageNumber] = [];
            }

            // const annotationExists = annotationsByPage[currentPageNum].find((ann) => ann.id === obj.id);
            // if (annotationExists) {
            //     console.warn("Annotation already exists:", obj.id);
            //     return; 
            // }
            obj.id = obj.id || Date.now() + Math.random().toString(36).substr(2, 9);
            const annotation = {
                userName: "Anurag Sable",
                id: generateGuid(),
                // mode:annotationMode,
                userId: sessionUserId,
                documentId: sessionDocumentId,

                type: annotationMode,
                text: obj.text,
                startIndex: obj.startIndex,
                endIndex: obj.endIndex,
                lineAnnotations: obj.lineAnnotations,
                radius: obj.radius,
                page: pageNumber,
                title: `${annotationMode} Annotation`,
                content: `This is a ${annotationMode} annotation`,
                subject: `This is a ${annotationMode} annotation`,
                fontSize: obj.fontSize / Math.min(scaleFactor.x, scaleFactor.y),
                color: type === 'highlight' ? 'yellow' : undefined,
                stroke: type === 'underline' ? 'red' : type === 'strikeout' ? 'red' : undefined,
                strokeWidth: 1,
            };
            //  openAnnotationModal(annotation);

            if (type === "Highlight Annotation") {
                annotation.title = "Highlight Title";
                annotation.subject = "Highlight Subject";
                annotation.content = "This is a highligh annotation.";
                annotation.color = "yellow";
                annotation.opacity = 0.5;
            } else if (type === "Underline Annotation") {
                annotation.title = "Underline Title";
                annotation.subject = "Underline Subject";
                annotation.content = "This is a underline annotation.";
                annotation.stroke = "red";
                annotation.strokeWidth = 1;
            } else if (type === "Strikeout Annotation") {
                annotation.title = "Strike-out Title";
                annotation.subject = "Strike-out Subject";
                annotation.content = "This is a strike-out annotation.";
                annotation.stroke = "red";
                annotation.strokeWidth = 1;
                annotation.translateY = obj.height / 2;
            }
            annotationsByPage[pageNumber].push(annotation);

            const undoAction = {
                type: 'text',
                page: pageNumber,
                annotations: [annotation],
                timestamp: Date.now()
            };
            console.log("Adding text annotation to undo stack:", undoAction);
            addToUndoStack(undoAction);

            console.log("Stored Annotation:", annotation);
            console.log(`Stored annotation for page ${pageNumber}`, annotationsByPage);
            updateSidebar(annotation);

            // const sessionDocumentId = generateGuid();
            // const sessionUserId = generateGuid();
            const sessionCommentId = generateGuid();


            // const backendData = {
            //     DocumentId: sessionDocumentId,
            //     CommentList: [
            //         {
            //             UserId: sessionUserId,
            //             Comments: annotation.content,
            //             Remark: "Empty String",
            //             CommentDate: new Date().toISOString(),
            //             AnnotationType: annotation.type,
            //             PageNumber: annotation.page.toString(),
            //             Id: sessionCommentId,
            //             UserName: annotation.userName
            //         }
            //     ]
            // };

            // console.log("Backend Data:", backendData);

            // sendAnnotationToBackend(backendData);

        }


        function storeAnnotation(type, obj, pageNum) {
            pageNum = parseInt(pageNum, 10);
            const scaleFactor = getScaleFactor();
            if (!annotationsByPage[pageNum]) {
                annotationsByPage[pageNum] = [];
            }
            const annotationExists = annotationsByPage[pageNum].find((ann) => ann.id === obj.id);
            if (annotationExists) {
                console.warn("Annotation already exists:", obj.id);
                return;
            }
            const annotationId = obj.id || generateGuid();
            obj.id = annotationId;
            console.log("annotationId", annotationId);

            const annotation = {
                userName: "Anurag Sable",
                id: annotationId,
                userId: sessionUserId,
                documentId: sessionDocumentId,

                type: type,
                x1: obj.left,
                y1: obj.top,
                x2: (obj.left + (obj.width || 0)),
                y2: (obj.top + (obj.height || 0)),
                radius: obj.radius / scaleFactor.x,
                page: pageNum,
                title: "",
                subject: "",
                content: type === 'text' ? obj.text : "Enter Text",
                fontSize: obj.fontSize / Math.min(scaleFactor.x, scaleFactor.y), // Use the smaller scale factor for font size
                color: type === 'highlight' ? 'yellow' : undefined,
                stroke: type === 'underline' ? 'red' : type === 'strikeout' ? 'black' : undefined,
            };
            if (type !== "text" && type !== "textCallout") {
                openAnnotationModal(annotation);
            }

            if (type === "square") {
                annotation.title = "Square Title";
                annotation.subject = "Square Subject";
                annotation.content = "This is a square annotation.";
                annotation.stroke = obj.stroke;
                annotation.strokeWidth = obj.strokeWidth;
            }
            else if (type === "circle") {
                annotation.title = "Circle Title";
                annotation.subject = "Circle Subject";
                annotation.content = "This is a circle annotation.";
                annotation.radius = obj.radius / scaleFactor.x;
                annotation.fill = obj.fill;
            } else if (type === "line") {
                annotation.title = "Line Title";
                annotation.subject = "Line Subject";
                annotation.content = "This is a line annotation.";
                annotation.x2 = obj.x2 / scaleFactor.x;
                annotation.y2 = obj.y2 / scaleFactor.y;
                annotation.stroke = obj.stroke;
                annotation.strokeWidth = obj.strokeWidth / scaleFactor.x;
            } if (type === "text") {
                annotation.subject = "Text Subject";
                annotation.title = "Text";
                annotation.text = obj.text || "";
                annotation.fontSize = obj.fontSize / scaleFactor.x;
                annotation.fill = obj.fill;
            }
            else if (type === "freeDraw") {
                annotation.title = "Free Draw Title";
                annotation.subject = "Free Draw Subject";
                annotation.content = "This is a Free Draw annotation.";
                annotation.path = obj.path;
                annotation.stroke = obj.stroke;
                annotation.strokeWidth = obj.strokeWidth / scaleFactor.x;
            } else if (type === "cloud") {
                annotation.title = "Cloud Annotation";
                annotation.subject = "Cloud Subject";
                annotation.content = "This is a cloud annotation.";
                annotation.path = obj.path;
                annotation.stroke = obj.stroke || 'red';
                annotation.strokeWidth = obj.strokeWidth || 2;
                annotation.annotationType = 'cloud'; // Explicitly set the annotation type
            } else if (type === "stamp") {
                annotation.title = "Stamp Annotation";
                annotation.subject = "Stamp Subject";
                annotation.content = "This is a stamp annotation.";
                annotation.imgSrc = obj.imgSrc || "";

                // Fix for stamp positioning - adjust for center origin
                if (obj.originX === 'center' && obj.originY === 'center') {
                    const halfWidth = (obj.width || 0) / 2;
                    const halfHeight = (obj.height || 0) / 2;

                    // Adjust coordinates to account for center origin
                    annotation.x1 = obj.left - halfWidth;
                    annotation.y1 = obj.top - halfHeight;
                    annotation.x2 = obj.left + halfWidth;
                    annotation.y2 = obj.top + halfHeight;

                    console.log("Adjusted stamp coordinates:",
                        "x1:", annotation.x1,
                        "y1:", annotation.y1,
                        "x2:", annotation.x2,
                        "y2:", annotation.y2);
                }

                annotation.width = obj.width || 0;
                annotation.height = obj.height || 0;
            } else if (type === "signature") {
                annotation.title = "Signature Annotation";
                annotation.subject = "Signature Subject";
                annotation.content = "This is a signature annotation.";
                annotation.dataURL = obj.dataURL || "";
                if (obj.originX === 'center' && obj.originY === 'center') {
                    const halfWidth = (obj.width || 0) / 2;
                    const halfHeight = (obj.height || 0) / 2;

                    // Adjust coordinates to account for center origin
                    annotation.x1 = obj.left - halfWidth;
                    annotation.y1 = obj.top - halfHeight;
                    annotation.x2 = obj.left + halfWidth;
                    annotation.y2 = obj.top + halfHeight;

                    console.log("Adjusted stamp coordinates:",
                        "x1:", annotation.x1,
                        "y1:", annotation.y1,
                        "x2:", annotation.x2,
                        "y2:", annotation.y2);
                }

                annotation.width = obj.width || 0;
                annotation.height = obj.height || 0;

            } else if (type === "textCallout") {
                annotation.title = "Text Callout";
                annotation.subject = "Text with Arrow";
                annotation.content = obj.text || "";
                annotation.arrowStart = obj.arrowStart;
                annotation.arrowEnd = obj.arrowEnd;
                annotation.textLeft = obj.textLeft;
                annotation.textTop = obj.textTop;
                annotation.textWidth = obj.textWidth;
                annotation.textHeight = obj.textHeight;
                annotation.textColor = 'red';
                annotation.arrowColor = 'red';
                annotation.borderColor = 'red';
            }

            annotationsByPage[pageNum].push(annotation);
            console.log("Page Number:", pageNum, "Current Page:", currentPageNum);

            //             const sessionDocumentId = generateGuid();
            // const sessionUserId = generateGuid();
            const sessionCommentId = generateGuid();

            let objData;
            if (typeof obj.toObject === 'function') {
                objData = obj.toObject();
            } else {
                objData = {
                    ...obj,
                    type: type,
                    originX: 'center',
                    originY: 'center',
                    selectable: true,
                    evented: true
                };
            }
            objData.id = annotation.id;
            console.log("sessionUserId", sessionUserId);
            objData.annotationType = type;

            const undoAction = {
                type: 'fabric',
                page: pageNum,
                object: objData,
                annotationData: annotation,
                timestamp: Date.now()
            };

            console.log("Adding fabric annotation to undo stack:", undoAction);
            addToUndoStack(undoAction)


            console.log("Stored Annotation:", annotation);
            updateSidebar(annotation);

            //         const backendData = {
            //     DocumentId: sessionDocumentId, 
            //     CommentList: [
            //         {
            //             UserId: sessionUserId, 
            //             Comments: annotation.content,
            //             Remark: "Empty",
            //             CommentDate: new Date().toISOString(),
            //             AnnotationType: annotation.type,
            //             PageNumber: annotation.page.toString(),
            //             Id:sessionCommentId,
            //             UserName: annotation.userName
            //         }
            //     ]
            // };510119807266

            // console.log("Backend Data:", backendData);

            // sendAnnotationToBackend(backendData);
        }


        function addArrowTextCallout() {
            console.log("Adding Arrow Text Callout Annotation");

            if (isDrawing) {
                console.log("Already in drawing mode, ignoring duplicate click.");
                return;
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;
            currentAnnotationType = 'arrowTextCallout';

            let eventHandlers = {};

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];

                if (!fabricCanvas) {
                    console.error("Fabric.js canvas is not initialized for this page.");
                    return;
                }

                fabricCanvas.isDrawingMode = false;
                fabricCanvas.selection = true;

                let startPoint = null;
                let previewArrow = null;  // For preview only
                let previewTextBox = null;  // For preview text box
                let finalArrow = null;   // Track the final arrow reference
                let isMouseDown = false;

                eventHandlers[pageNumber] = {
                    onMouseDown(e) {
                        isMouseDown = true;
                        const pointer = fabricCanvas.getPointer(e.e);
                        startPoint = { x: pointer.x, y: pointer.y };
                    },

                    onMouseMove(e) {
                        if (!isMouseDown || !startPoint) return;

                        const pointer = fabricCanvas.getPointer(e.e);

                        // Remove previous preview elements
                        if (previewArrow) {
                            fabricCanvas.remove(previewArrow);
                        }
                        if (previewTextBox) {
                            fabricCanvas.remove(previewTextBox);
                        }

                        // Create preview text box at current mouse position
                        const textBoxX = pointer.x;
                        const textBoxY = pointer.y;

                        previewTextBox = new fabric.Textbox(' ', {
                            left: textBoxX,
                            top: textBoxY,
                            fontSize: 13,
                            fill: 'red',
                            backgroundColor: 'white',
                            strokeWidth: 1,
                            stroke: 'red',
                            strokeUniform: true,  // Keep border width consistent regardless of scaling
                            padding: 5,
                            width: 75,
                            editable: true,
                            opacity: 0.7,
                            borderColor: 'red',
                            showTextBoxBorder: true, // Custom property to track that we want border always visible
                            hasControls: true
                        });

                        fabricCanvas.add(previewTextBox);
                        previewTextBox.setCoords();

                        // Calculate text box center point
                        const textCenterX = textBoxX + previewTextBox.width / 2;
                        const textCenterY = textBoxY + previewTextBox.height / 2;

                        // Calculate angle between start point and text box center
                        const angle = Math.atan2(textCenterY - startPoint.y, textCenterX - startPoint.x);
                        const angleDeg = angle * 180 / Math.PI;

                        // Determine which side of the text box to connect to based on angle
                        // Determine which side of the text box to connect to based on angle
                        let connectX, connectY;

                        // Right side: -45 to 45 degrees
                        if (angleDeg >= -45 && angleDeg < 45) {
                            connectX = textBoxX - (previewTextBox.strokeWidth / 2); // Connect to left border
                            connectY = textBoxY + previewTextBox.height / 2;
                        }
                        // Bottom side: 45 to 135 degrees
                        else if (angleDeg >= 45 && angleDeg < 135) {
                            connectX = textBoxX + previewTextBox.width / 2;
                            connectY = textBoxY - (previewTextBox.strokeWidth / 2); // Connect to top border
                        }
                        // Left side: 135 to -135 degrees
                        else if ((angleDeg >= 135 && angleDeg <= 180) || (angleDeg >= -180 && angleDeg < -135)) {
                            connectX = textBoxX + previewTextBox.width + (previewTextBox.strokeWidth / 2); // Connect to right border
                            connectY = textBoxY + previewTextBox.height / 2;
                        }
                        // Top side: -135 to -45 degrees
                        else {
                            connectX = textBoxX + previewTextBox.width / 2;
                            connectY = textBoxY + previewTextBox.height + (previewTextBox.strokeWidth / 2); // Connect to bottom border
                        }


                        // Create preview arrow
                        previewArrow = createArrow([
                            startPoint.x,
                            startPoint.y,
                            connectX,
                            connectY
                        ], {
                            stroke: 'red',
                            strokeWidth: 1.5,
                            fill: 'red'
                        });

                        previewArrow.set({
                            opacity: 0.7,
                            id: 'preview_arrow',
                            selectable: false
                        });

                        fabricCanvas.add(previewArrow);
                        fabricCanvas.renderAll();
                    },

                    onMouseUp(e) {
                        if (!isMouseDown || !startPoint) return;

                        // Remove preview elements
                        if (previewArrow) {
                            fabricCanvas.remove(previewArrow);
                            previewArrow = null;
                        }
                        if (previewTextBox) {
                            fabricCanvas.remove(previewTextBox);
                            previewTextBox = null;
                        }

                        const pointer = fabricCanvas.getPointer(e.e);

                        // Check if the mouse moved enough to create an annotation
                        const dx = Math.abs(pointer.x - startPoint.x);
                        const dy = Math.abs(pointer.y - startPoint.y);
                        if (dx < 5 && dy < 5) {
                            // Too small movement, ignore
                            isMouseDown = false;
                            return;
                        }

                        // Create final text box
                        const textBoxX = pointer.x;
                        const textBoxY = pointer.y;

                        const textBox = new fabric.Textbox('', {
                            left: textBoxX,
                            top: textBoxY,
                            fontSize: 13,
                            fill: 'red',
                            backgroundColor: 'white',
                            strokeWidth: 0.5,
                            stroke: 'red',
                            strokeUniform: true,  // Keep border width consistent
                            padding: 5,
                            width: 75,
                            editable: true,
                            // borderColor: 'red',
                            showTextBoxBorder: true, // Custom property to track that we want border always visible
                            hasControls: true
                        });
                        fabricCanvas.on('after:render', function () {
                            fabricCanvas.forEachObject(function (obj) {
                                if (obj.showTextBoxBorder && !obj.isControlVisible('mtr')) {
                                    const ctx = fabricCanvas.getContext();
                                    const bound = obj.getBoundingRect();

                                    ctx.save();
                                    ctx.strokeStyle = 'red';
                                    ctx.lineWidth = 2;
                                    ctx.strokeRect(
                                        bound.left,
                                        bound.top,
                                        bound.width,
                                        bound.height
                                    );
                                    ctx.restore();
                                }
                            });
                        });


                        fabricCanvas.add(textBox);
                        textBox.setCoords();

                        // Calculate text box center point
                        const textCenterX = textBoxX + textBox.width / 2;
                        const textCenterY = textBoxY + textBox.height / 2;

                        // Calculate angle between start point and text box center
                        const angle = Math.atan2(textCenterY - startPoint.y, textCenterX - startPoint.x);
                        const angleDeg = angle * 180 / Math.PI;

                        // ... existing code ...
                        // Determine which side of the text box to connect to based on angle
                        let connectX, connectY;

                        // Right side: -45 to 45 degrees
                        if (angleDeg >= -45 && angleDeg < 45) {
                            connectX = textBox.left; // Connect exactly to left border
                            connectY = textBox.top + textBox.height / 2;
                        }
                        // Bottom side: 45 to 135 degrees
                        else if (angleDeg >= 45 && angleDeg < 135) {
                            connectX = textBox.left + textBox.width / 2;
                            connectY = textBox.top; // Connect exactly to top border
                        }
                        // Left side: 135 to -135 degrees
                        else if ((angleDeg >= 135 && angleDeg <= 180) || (angleDeg >= -180 && angleDeg < -135)) {
                            connectX = textBox.left + textBox.width; // Connect exactly to right border
                            connectY = textBox.top + textBox.height / 2;
                        }
                        // Top side: -135 to -45 degrees
                        else {
                            connectX = textBox.left + textBox.width / 2;
                            connectY = textBox.top + textBox.height; // Connect exactly to bottom border
                        }

                        // ... and in the updateCalloutArrow function, update the same logic:
                        if (angleDeg >= -45 && angleDeg < 45) {
                            newConnectX = textBox.left; // Connect exactly to left border
                            newConnectY = textBox.top + textBox.height / 2;
                        }
                        // Bottom side: 45 to 135 degrees
                        else if (angleDeg >= 45 && angleDeg < 135) {
                            newConnectX = textBox.left + textBox.width / 2;
                            newConnectY = textBox.top; // Connect exactly to top border
                        }
                        // Left side: 135 to -135 degrees
                        else if ((angleDeg >= 135 && angleDeg <= 180) || (angleDeg >= -180 && angleDeg < -135)) {
                            newConnectX = textBox.left + textBox.width; // Connect exactly to right border
                            newConnectY = textBox.top + textBox.height / 2;
                        }
                        // Top side: -135 to -45 degrees
                        else {
                            newConnectX = textBox.left + textBox.width / 2;
                            newConnectY = textBox.top + textBox.height; // Connect exactly to bottom border
                        }

                        // Create the final arrow
                        finalArrow = createArrow([
                            startPoint.x,
                            startPoint.y,
                            connectX,
                            connectY
                        ], {
                            stroke: 'red',
                            strokeWidth: 1.5,
                            fill: 'red'
                        });

                        fabricCanvas.add(finalArrow);

                        // Generate unique ID for the annotation
                        const calloutId = generateUniqueId();

                        // Set annotation properties
                        finalArrow.set({
                            id: calloutId + '_arrow',
                            calloutId: calloutId,
                            annotationType: 'textCallout',
                            startX: startPoint.x,
                            startY: startPoint.y,
                            endX: connectX,
                            endY: connectY,
                            selectable: false,
                            hasControls: false,

                        });

                        textBox.set({
                            id: calloutId + '_text',
                            calloutId: calloutId,
                            annotationType: 'textCallout',
                            selectable: true
                        });

                        // Create the connection data
                        const calloutData = {
                            id: calloutId,
                            type: 'textCallout',
                            arrowStart: [startPoint.x, startPoint.y],
                            arrowEnd: [connectX, connectY],
                            textLeft: textBoxX,
                            textTop: textBoxY,
                            text: '',
                            textWidth: textBox.width,
                            textHeight: textBox.height
                        };

                        // Store reference to the callout elements in the canvas
                        fabricCanvas.calloutElements = fabricCanvas.calloutElements || {};
                        fabricCanvas.calloutElements[calloutId] = {
                            textBox: textBox,
                            arrow: finalArrow,
                            startPoint: startPoint
                        };

                        // When the text box moves, update the arrow
                        textBox.on('moving', function () {
                            updateCalloutArrow(fabricCanvas, calloutId);
                        });

                        textBox.on('moved', function () {
                            updateCalloutArrow(fabricCanvas, calloutId, true);
                        });

                        textBox.on('editing:exited', function () {
                            console.log("Text editing completed:", textBox.text);
                            updateTextCalloutContent(calloutId, textBox.text);

                        });

                        textBox.on('changed', function () {
                            console.log("Text changed:", textBox.text);
                            updateTextCalloutContent(calloutId, textBox.text);
                        });

                        // Store annotation
                        storeAnnotation('textCallout', calloutData, pageNumber);

                        // Reset and exit drawing mode
                        isMouseDown = false;
                        isDrawing = false;
                        currentAnnotationType = null;

                        // Remove event handlers
                        Object.keys(fabricCanvases).forEach((page) => {
                            let canvas = fabricCanvases[page];
                            if (canvas && eventHandlers[page]) {
                                canvas.off('mouse:down', eventHandlers[page].onMouseDown);
                                canvas.off('mouse:move', eventHandlers[page].onMouseMove);
                                canvas.off('mouse:up', eventHandlers[page].onMouseUp);
                            }
                        });

                        enableTextLayer();
                    }
                };

                setAlwaysVisibleBorders();


                fabricCanvas.on('mouse:down', eventHandlers[pageNumber].onMouseDown);
                fabricCanvas.on('mouse:move', eventHandlers[pageNumber].onMouseMove);
                fabricCanvas.on('mouse:up', eventHandlers[pageNumber].onMouseUp);
            });
        }

        // Add this function to ensure text box borders are always visible
        function setAlwaysVisibleBorders() {
            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];
                if (!fabricCanvas) return;

                // Remove any existing after:render handlers to avoid duplicates
                fabricCanvas.off('after:render');

                // Add handler to draw borders for objects that need them
                fabricCanvas.on('after:render', function () {
                    fabricCanvas.forEachObject(function (obj) {
                        if (obj.showTextBoxBorder && !obj.active) {
                            const ctx = fabricCanvas.getContext();
                            const bound = obj.getBoundingRect();

                            ctx.save();
                            ctx.strokeStyle = 'red';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(
                                bound.left + 5,
                                bound.top + 5,
                                bound.width - 6,
                                bound.height - 6
                            );
                            ctx.restore();
                        }
                    });
                });
            });
        }

        // Call this at the end of your initialization

        // Helper function to update the arrow when the text box moves
        function updateCalloutArrow(canvas, calloutId, isCompleted = false) {
            if (!canvas.calloutElements || !canvas.calloutElements[calloutId]) {
                console.error("Cannot find callout elements for ID:", calloutId);
                return;
            }

            const elements = canvas.calloutElements[calloutId];
            const textBox = elements.textBox;
            const oldArrow = elements.arrow;
            const startPoint = elements.startPoint;

            // Calculate text box center point
            const textCenterX = textBox.left + textBox.width / 2;
            const textCenterY = textBox.top + textBox.height / 2;

            // Calculate angle between start point and text box center
            const angle = Math.atan2(textCenterY - startPoint.y, textCenterX - startPoint.x);
            const angleDeg = angle * 180 / Math.PI;

            // Determine which side of the text box to connect to based on angle
            // Determine which side of the text box to connect to based on angle
            let newConnectX, newConnectY;

            // Right side: -45 to 45 degrees
            if (angleDeg >= -45 && angleDeg < 45) {
                newConnectX = textBox.left - (textBox.strokeWidth / 2); // Left border
                newConnectY = textBox.top + textBox.height / 2;
            }
            // Bottom side: 45 to 135 degrees
            else if (angleDeg >= 45 && angleDeg < 135) {
                newConnectX = textBox.left + textBox.width / 2;
                newConnectY = textBox.top - (textBox.strokeWidth / 2); // Top border
            }
            // Left side: 135 to -135 degrees
            else if ((angleDeg >= 135 && angleDeg <= 180) || (angleDeg >= -180 && angleDeg < -135)) {
                newConnectX = textBox.left + textBox.width + (textBox.strokeWidth / 2); // Right border
                newConnectY = textBox.top + textBox.height / 2;
            }
            // Top side: -135 to -45 degrees
            else {
                newConnectX = textBox.left + textBox.width / 2;
                newConnectY = textBox.top + textBox.height + (textBox.strokeWidth / 2); // Bottom border
            }


            // Remove old arrow
            canvas.remove(oldArrow);

            // Create new arrow
            const newArrow = createArrow([
                startPoint.x,
                startPoint.y,
                newConnectX,
                newConnectY
            ], {
                stroke: 'red',
                strokeWidth: 1.5,
                fill: 'red'
            });

            newArrow.set({
                id: oldArrow.id, // Keep same ID
                calloutId: oldArrow.calloutId,
                annotationType: 'textCallout',
                startX: startPoint.x,
                startY: startPoint.y,
                endX: newConnectX,
                endY: newConnectY,
                selectable: false,
                hasControls: false,
                lockMovementX: true,
                lockMovementY: true,
                hoverCursor: 'default'
            });

            canvas.add(newArrow);
            canvas.renderAll();

            // Update the saved reference
            canvas.calloutElements[calloutId].arrow = newArrow;
            // canvas.calloutElements[calloutId].startPoint = startPoint; // Preserve original start point


            // Only update stored annotation when move is complete to avoid excessive storage updates
            if (isCompleted) {
                updateStoredAnnotation(calloutId, {
                    arrowEnd: [newConnectX, newConnectY],
                    textLeft: textBox.left,
                    textTop: textBox.top
                });
            }
        }

        // Improved arrow creation function to better match the image
        function createArrow(coords, options) {
            const x1 = coords[0], y1 = coords[1], x2 = coords[2], y2 = coords[3];

            // Calculate angle for arrowhead
            const angle = Math.atan2(y2 - y1, x2 - x1);

            // Create the line
            const arrowLine = new fabric.Line([x1, y1, x2, y2], {
                stroke: options.stroke || 'red',
                strokeWidth: options.strokeWidth || 2,
                selectable: false,
                lockMovementX: true,
                lockMovementY: true
            });

            // Create arrowhead triangle - smaller to match image
            const arrowHeadSize = 10;
            const arrowHead = new fabric.Triangle({
                width: arrowHeadSize,
                height: arrowHeadSize,
                fill: options.fill || 'red',
                left: x1,
                top: y1,
                originX: 'center',
                originY: 'center',
                angle: (angle * 180 / Math.PI) - 90, // Angle to point away from line
                selectable: false,
                lockMovementX: true,
                lockMovementY: true
            });

            // Group the line and arrowhead
            return new fabric.Group([arrowLine, arrowHead], {
                selectable: false,
                hasControls: false,
                hasBorders: false,
                lockScalingX: true,
                lockScalingY: true,
                lockRotation: true,
                lockMovementX: true,
                lockMovementY: true,
                hoverCursor: 'default'
            });
        }


        // Function to update text in text callout annotation
        function updateTextCalloutContent(calloutId, newText) {
            console.log("Updating text callout content:", calloutId, newText);

            // First update in the fabric object reference
            let canvasWithCallout = null;
            let pageWithCallout = null;

            // Find which canvas contains this callout
            Object.keys(fabricCanvases).forEach(pageNumber => {
                const canvas = fabricCanvases[pageNumber];
                if (!canvas || !canvas.calloutElements || !canvas.calloutElements[calloutId]) return;

                // Found the canvas with our callout
                const textBox = canvas.calloutElements[calloutId].textBox;
                if (textBox) {
                    canvasWithCallout = canvas;
                    pageWithCallout = pageNumber;

                    // Make sure the text is updated in the Fabric object
                    textBox.set('text', newText);
                    canvas.renderAll();
                    console.log("Updated textbox text:", newText);
                }
            });

            // If we found the canvas with the callout, we can use it to find the actual annotation ID
            if (canvasWithCallout && pageWithCallout) {
                // Next, update in all stored annotations for this page
                const annotations = annotationsByPage[pageWithCallout] || [];

                // First try to find by exact ID
                let annotation = annotations.find(ann => ann.id === calloutId);

                // If not found by exact ID, try to search by related attribute
                if (!annotation) {
                    // Search for annotations that match our text callout type
                    const possibleAnnotations = annotations.filter(ann =>
                        ann.type === 'textCallout' &&
                        (ann.textLeft !== undefined || ann.arrowEnd !== undefined)
                    );

                    // Log for debugging
                    console.log("Possible annotations:", possibleAnnotations.length);

                    if (possibleAnnotations.length > 0) {
                        // Use the most recently created annotation (assuming it's the current one)
                        annotation = possibleAnnotations[possibleAnnotations.length - 1];
                        console.log("Selected annotation by position:", annotation);
                    }
                }

                // Update the annotation if found
                if (annotation) {
                    // Update both content and text fields to ensure consistency
                    annotation.content = newText;
                    annotation.text = newText;
                    console.log("Updated annotation in page " + pageWithCallout + ":", annotation);
                    return true;
                }
            }

            console.error("Failed to find annotation with ID:", calloutId);

            // As a last resort, try to update any text callout annotation on the current page
            const currentPage = currentPageNum.toString();
            if (annotationsByPage[currentPage]) {
                const annotations = annotationsByPage[currentPage];
                // Find the most recent text callout annotation
                const textCallouts = annotations.filter(ann => ann.type === 'textCallout');

                if (textCallouts.length > 0) {
                    const lastTextCallout = textCallouts[textCallouts.length - 1];
                    lastTextCallout.content = newText;
                    lastTextCallout.text = newText;
                    console.log("Updated latest text callout as fallback:", lastTextCallout);
                    return true;
                }
            }

            return false;
        }




        // let currentAnnotationType = null;
        function addStamp(stampType) {
            if (currentAnnotationType !== null) {
                stopStampProcess();
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;
            currentAnnotationType = 'stamp';

            const stamps = {
                approve: 'static/images/Approved.png',
                notApprove: '/static/images/Rejected.png',
            };

            const selectedStamp = stamps[stampType];
            if (!selectedStamp) {
                console.error("Invalid stamp type selected!");
                isDrawing = false;
                enableTextLayer();
                return;
            }

            document.addEventListener('click', handleGlobalClick, true);
            document.addEventListener('keydown', escHandler);

            // Create preview stamp once for all pages
            let previewStamp = null;

            // Load the stamp image
            fabric.Image.fromURL(selectedStamp, function (loadedImg) {
                // Set up the preview stamp
                loadedImg.scale(0.6);
                loadedImg.set({
                    opacity: 0.4,
                    selectable: false,
                    evented: false,
                    originX: 'left',
                    originY: 'top'
                });
                previewStamp = loadedImg;

                // Now set up handlers for each canvas
                Object.keys(fabricCanvases).forEach((pageNumber) => {
                    let fabricCanvas = fabricCanvases[pageNumber];
                    if (!fabricCanvas) return;

                    fabricCanvas.isDrawingMode = false;
                    fabricCanvas.selection = true;

                    // Remove default cursor as we'll show the stamp as cursor
                    fabricCanvas.defaultCursor = 'default';

                    // Clean up existing handlers if any
                    if (fabricCanvas._stampMouseDownHandler) {
                        fabricCanvas.off('mouse:down', fabricCanvas._stampMouseDownHandler);
                    }
                    if (fabricCanvas._stampMouseMoveHandler) {
                        fabricCanvas.off('mouse:move', fabricCanvas._stampMouseMoveHandler);
                    }

                    // Preview handler - shows stamp following mouse
                    const onMouseMove = function (e) {
                        const pointer = fabricCanvas.getPointer(e.e);

                        // Remove previous preview from any canvas
                        Object.keys(fabricCanvases).forEach(pgNum => {
                            const canvas = fabricCanvases[pgNum];
                            if (!canvas) return;

                            // Find and remove any preview stamp
                            const existingPreviews = canvas.getObjects().filter(obj =>
                                obj.previewStamp === true);
                            existingPreviews.forEach(prev => canvas.remove(prev));
                        });

                        // Clone the preview stamp for this specific position
                        const clonedPreview = fabric.util.object.clone(previewStamp);
                        clonedPreview.set({
                            left: pointer.x,
                            top: pointer.y,
                            previewStamp: true  // Mark as preview for identification
                        });

                        // Add to canvas and render
                        fabricCanvas.add(clonedPreview);
                        fabricCanvas.renderAll();
                    };

                    // Actual placement handler
                    const onMouseDown = function (e) {
                        const pointer = fabricCanvas.getPointer(e.e);

                        // Remove preview stamps from all canvases
                        Object.keys(fabricCanvases).forEach(pgNum => {
                            const canvas = fabricCanvases[pgNum];
                            if (!canvas) return;

                            const existingPreviews = canvas.getObjects().filter(obj =>
                                obj.previewStamp === true);
                            existingPreviews.forEach(prev => canvas.remove(prev));
                            canvas.renderAll();
                        });

                        // Create the actual stamp with full opacity
                        fabric.Image.fromURL(selectedStamp, function (img) {
                            const uniqueId = generateUniqueId();
                            img.scale(0.6);
                            img.set({
                                id: uniqueId,
                                left: pointer.x,
                                top: pointer.y,
                                originX: 'left',
                                originY: 'top',
                                selectable: true,
                                evented: true
                            });

                            fabricCanvas.add(img);
                            fabricCanvas.renderAll();
                            fabricUndoStack.push(img);

                            storeAnnotation('stamp', {
                                id: uniqueId,
                                left: img.left,
                                top: img.top,
                                width: img.getScaledWidth(),
                                height: img.getScaledHeight(),
                                imgSrc: selectedStamp
                            }, pageNumber);
                        });
                    };

                    // Attach the handlers
                    fabricCanvas.on('mouse:move', onMouseMove);
                    fabricCanvas.on('mouse:down', onMouseDown);

                    // Store references for later cleanup
                    fabricCanvas._stampMouseMoveHandler = onMouseMove;
                    fabricCanvas._stampMouseDownHandler = onMouseDown;
                });
            });
        }

        function stopStampProcess() {
            document.removeEventListener('click', handleGlobalClick, true);
            document.removeEventListener('keydown', escHandler);

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];
                if (!fabricCanvas) return;

                // Remove event handlers
                if (fabricCanvas._stampMouseDownHandler) {
                    fabricCanvas.off('mouse:down', fabricCanvas._stampMouseDownHandler);
                    delete fabricCanvas._stampMouseDownHandler;
                }
                if (fabricCanvas._stampMouseMoveHandler) {
                    fabricCanvas.off('mouse:move', fabricCanvas._stampMouseMoveHandler);
                    delete fabricCanvas._stampMouseMoveHandler;
                }

                // Remove any preview stamps
                const previewStamps = fabricCanvas.getObjects().filter(obj =>
                    obj.previewStamp === true);
                previewStamps.forEach(preview => fabricCanvas.remove(preview));

                fabricCanvas.defaultCursor = 'default';
                fabricCanvas.renderAll();
            });

            isDrawing = false;
            currentAnnotationType = null;
            enableTextLayer();
        }

        function handleGlobalClick(event) {
            if (event.target.closest('button') &&
                !event.target.closest('[onclick*="addSelectedStamp"]') &&
                !event.target.closest('#stampSelect')) {
                stopStampProcess();
                enableSelectMode();
            }
        }

        // function stopStampProcess() {
        //     document.removeEventListener('click', handleGlobalClick, true);

        //     document.removeEventListener('keydown', escHandler);

        //     Object.keys(fabricCanvases).forEach((pageNumber) => {
        //         let fabricCanvas = fabricCanvases[pageNumber];
        //         if (fabricCanvas && fabricCanvas._stampMouseDownHandler) {
        //             fabricCanvas.off('mouse:down', fabricCanvas._stampMouseDownHandler);
        //             delete fabricCanvas._stampMouseDownHandler;
        //             fabricCanvas.defaultCursor = 'default';
        //         }
        //     });

        //     isDrawing = false;
        //     currentAnnotationType = null;
        //     enableTextLayer();
        // }

        function escHandler(event) {
            if (event.key === 'Escape') {
                stopStampProcess();
                enableSelectMode();
            }
        }

        function cancelAnnotation() {
            console.log("Canceling annotation...");
            window.getSelection().removeAllRanges();

            if (currentAnnotationType === 'stamp') {
                stopStampProcess();
            }

            annotationMode = null;
            fabricCanvas.isDrawingMode = false;
            isDrawing = false;
            currentAnnotationType = null;
            enableSelectMode();
        }

        function addSelectedStamp() {
            const stampType = document.getElementById('stampSelect').value;
            addStamp(stampType);
        }

        function openSignatureCanvas() {
            let canvasContainer = document.createElement('div');
            canvasContainer.id = 'signatureCanvasContainer';
            canvasContainer.className = 'signature-canvas-container';

            let canvas = document.createElement('canvas');
            canvas.id = 'signatureCanvas';
            canvas.className = 'signature-canvas';
            canvas.width = 1000;
            canvas.height = 400;
            canvasContainer.appendChild(canvas);

            let buttonContainer = document.createElement('div');
            buttonContainer.id = 'buttonContainer';
            buttonContainer.className = 'signature-buttons';

            let doneButton = document.createElement('button');
            doneButton.innerHTML = 'Done';
            doneButton.id = 'signature-done-btn';
            doneButton.name = 'signature-done';
            doneButton.onclick = function () {
                console.log("Done button clicked");
                placeSignatureOnPDF(canvas);
                document.body.removeChild(canvasContainer);
            };
            buttonContainer.appendChild(doneButton);

            let cancelButton = document.createElement('button');
            cancelButton.innerHTML = 'Cancel';
            cancelButton.id = 'signature-cancel-btn';
            cancelButton.name = 'signature-cancel';
            cancelButton.onclick = function () {
                document.body.removeChild(canvasContainer);
            };
            buttonContainer.appendChild(cancelButton);

            let clearButton = document.createElement('button');
            clearButton.innerHTML = 'Clear';
            clearButton.id = 'signature-clear-btn';
            clearButton.name = 'signature-clear';
            clearButton.onclick = function () {
                clearSignature(canvas);
            };
            buttonContainer.appendChild(clearButton);

            let saveButton = document.createElement('button');
            saveButton.innerHTML = 'Save Signature';
            saveButton.id = 'signature-save-btn';
            saveButton.name = 'signature-save';
            saveButton.onclick = function () {
                saveSignature(canvas);
            };
            buttonContainer.appendChild(saveButton);

            let uploadButton = document.createElement('button');
            uploadButton.innerHTML = 'Upload Signature';
            uploadButton.id = 'signature-upload-btn';
            uploadButton.name = 'signature-upload';
            uploadButton.onclick = function () {
                let input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.id = 'signature-file-input';
                input.name = 'signature-file';

                input.onchange = function (e) {
                    let file = e.target.files[0];
                    if (file) {
                        let reader = new FileReader();
                        reader.onload = function (event) {
                            let img = new Image();
                            img.onload = function () {
                                let ctx = canvas.getContext('2d');
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            };
                            img.src = event.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                };
                input.click();
            };
            buttonContainer.appendChild(uploadButton);

            let colorSelect = document.createElement('select');
            colorSelect.id = 'signature-color-select';
            colorSelect.name = 'signature-color';
            colorSelect.innerHTML = `<option value="black">Black</option>
                     <option value="red">Red</option>
                     <option value="blue">Blue</option>`;
            colorSelect.onchange = function () {
                ctx.strokeStyle = colorSelect.value;
            };
            buttonContainer.appendChild(colorSelect);

            let thicknessSelect = document.createElement('select');
            thicknessSelect.id = 'signature-thickness-select';
            thicknessSelect.name = 'signature-thickness';
            thicknessSelect.innerHTML = `<option value="5">5px</option>
                         <option value="10">10px</option>
                         <option value="15">15px</option>`;
            thicknessSelect.onchange = function () {
                ctx.lineWidth = parseInt(thicknessSelect.value, 10);
            };
            buttonContainer.appendChild(thicknessSelect);

            canvasContainer.appendChild(buttonContainer);
            document.body.appendChild(canvasContainer);

            let ctx = canvas.getContext('2d');
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 5;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            let isDrawing = false;

            canvas.addEventListener('mousedown', function (e) {
                isDrawing = true;
                ctx.moveTo(e.offsetX, e.offsetY);
                ctx.beginPath();
            });

            canvas.addEventListener('mousemove', function (e) {
                if (isDrawing) {
                    ctx.lineTo(e.offsetX, e.offsetY);
                    ctx.stroke();
                }
            });

            canvas.addEventListener('mouseup', function () {
                isDrawing = false;
            });

            canvas.addEventListener('mouseout', function () {
                isDrawing = false;
            });
        }
        function clearSignature(canvas) {
            let ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        function resetSignature(canvas) {
            clearSignature(canvas);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 5;
        }

        function saveSignature(canvas) {
            const dataURL = canvas.toDataURL();
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'signature.png';
            a.click();
        }



        function placeSignatureOnPDF(signatureCanvas) {
            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];
                disableTextLayer();
                resetDrawingState();
                const signatureDataURL = signatureCanvas.toDataURL();

                // Create the signature image first
                fabric.Image.fromURL(signatureDataURL, function (img) {
                    const SigniturescaleFactor = 0.4;
                    const uniqueId = generateUniqueId();
                    img.scale(SigniturescaleFactor);

                    // Create a preview version with low opacity
                    let previewImg = fabric.util.object.clone(img);
                    previewImg.set({
                        opacity: 0.4,
                        selectable: false,
                        evented: false,
                        hoverCursor: 'default'
                    });

                    let isSignaturePlaced = false;

                    // Handle mouse movement to show preview
                    fabricCanvas.on('mouse:move', function (event) {
                        if (!isSignaturePlaced) {
                            const pointer = fabricCanvas.getPointer(event.e);

                            // Remove previous preview if exists
                            if (fabricCanvas.getObjects().includes(previewImg)) {
                                fabricCanvas.remove(previewImg);
                            }

                            // Position the preview at cursor
                            previewImg.set({
                                left: pointer.x,
                                top: pointer.y,
                                originX: 'left',
                                originY: 'top'
                            });

                            // Add preview to canvas
                            fabricCanvas.add(previewImg);
                            fabricCanvas.renderAll();
                        }
                    });

                    // Handle actual placement on click
                    fabricCanvas.on('mouse:down', function (event) {
                        if (!isSignaturePlaced && !event.target) {
                            const pointer = fabricCanvas.getPointer(event.e);

                            // Remove the preview
                            fabricCanvas.remove(previewImg);

                            // Set up the actual signature image
                            img.set({
                                id: uniqueId,
                                left: pointer.x,
                                top: pointer.y,
                                originX: 'left',
                                originY: 'top',
                                selectable: true,
                                evented: true,
                                opacity: 1
                            });

                            fabricCanvas.add(img);
                            fabricCanvas.renderAll();
                            isSignaturePlaced = true;
                            fabricUndoStack.push(img);

                            // Store the annotation
                            storeAnnotation('signature', {
                                id: uniqueId,
                                left: img.left,
                                top: img.top,
                                width: img.getScaledWidth(),
                                height: img.getScaledHeight(),
                                dataURL: signatureDataURL
                            }, pageNumber);

                            console.log("Signature placed on PDF at:", pointer);

                            // Remove the mouse:move event handler
                            fabricCanvas.off('mouse:move');
                            fabricCanvas.off('mouse:down');
                        }
                    });

                    // Add escape key handler
                    const escSignatureHandler = function (event) {
                        if (event.key === 'Escape') {
                            // Remove preview and cleanup
                            if (fabricCanvas.getObjects().includes(previewImg)) {
                                fabricCanvas.remove(previewImg);
                                fabricCanvas.renderAll();
                            }
                            fabricCanvas.off('mouse:move');
                            fabricCanvas.off('mouse:down');
                            document.removeEventListener('keydown', escSignatureHandler);
                            isSignaturePlaced = true; // Prevent further placement
                            enableTextLayer();
                        }
                    };

                    document.addEventListener('keydown', escSignatureHandler);

                    console.log("Move your cursor to see a preview, and click to place the signature.");
                });
            });
        }
        function addCloudAnnotation() {
            console.log("Activating Cloud Annotation Mode");

            if (isDrawing) {
                console.log("Already in drawing mode, ignoring duplicate click.");
                return;
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;

            let eventHandlers = {};

            const cloudColor = 'red';
            const cloudStrokeWidth = 2;
            const cloudRadius = 20;
            const humpSize = 30;

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];

                if (!fabricCanvas) {
                    console.error("Fabric.js canvas is not initialized for this page.");
                    return;
                }

                let polygonPoints = [];
                let tempPath = null;

                function cleanupListeners(canvas, pageNum) {
                    canvas.off('mouse:down', eventHandlers[pageNum]?.onMouseDown);
                    canvas.off('mouse:move', eventHandlers[pageNum]?.onMouseMove);
                    canvas.off('mouse:dblclick', eventHandlers[pageNum]?.onMouseDblClick);
                    enableTextLayer();
                }

                eventHandlers[pageNumber] = {
                    onMouseDown(e) {
                        const pointer = fabricCanvas.getPointer(e.e);
                        if (polygonPoints.length === 0) {
                            polygonPoints.push(new Point(pointer.x, pointer.y));
                        } else {
                            polygonPoints.push(new Point(pointer.x, pointer.y));
                        }
                        updateCloudPreview();
                    },

                    onMouseMove(e) {
                        if (polygonPoints.length < 1) return;

                        const pointer = fabricCanvas.getPointer(e.e);
                        const lastPoint = polygonPoints[polygonPoints.length - 1];

                        if (pointer.x !== lastPoint.x || pointer.y !== lastPoint.y) {
                            updateCloudPreview(pointer.x, pointer.y);
                        }
                    },

                    onMouseDblClick() {
                        if (polygonPoints.length < 2) return;

                        polygonPoints.push(polygonPoints[0]);
                        const cloudids = generateGuid();
                        console.log("cloudids", cloudids);


                        const finalPath = generateCloudPath(polygonPoints, cloudRadius, humpSize);
                        const cloudPath = new fabric.Path(finalPath, {
                            fill: 'transparent',
                            stroke: cloudColor,
                            strokeWidth: cloudStrokeWidth,
                            selectable: true,
                            annotationType: 'cloud',
                            perPixelTargetFind: true,
                            objectCaching: false,
                            strokeLineJoin: 'round',
                            strokeLineCap: 'round',
                            cloudPoints: polygonPoints,
                            cloudRadius: cloudRadius,
                            cloudHumpSize: humpSize,
                            id: cloudids
                        });
                        console.log("cloudPath", cloudPath);

                        fabricCanvas.add(cloudPath);

                        if (tempPath) fabricCanvas.remove(tempPath);
                        tempPath = null;
                        polygonPoints = [];

                        storeAnnotation("cloud", {
                            ...cloudPath.toObject(),
                            cloudPoints: polygonPoints,
                            pathData: finalPath,
                            type: 'cloud',
                            id: cloudids
                        }, pageNumber);
                        console

                        isDrawing = false;

                        Object.keys(fabricCanvases).forEach((page) => {
                            let canvas = fabricCanvases[page];
                            if (canvas) cleanupListeners(canvas, page);
                        });
                    }
                };


                function updateCloudPreview(tempX, tempY) {
                    if (polygonPoints.length < 1) return;

                    const previewPoints = [...polygonPoints];
                    if (tempX !== undefined && tempY !== undefined) {
                        previewPoints.push(new Point(tempX, tempY));
                    }

                    const pathData = generateCloudPath(previewPoints, cloudRadius, humpSize);
                    if (tempPath) fabricCanvas.remove(tempPath);

                    tempPath = new fabric.Path(pathData, {
                        fill: 'transparent',
                        stroke: cloudColor,
                        strokeWidth: cloudStrokeWidth,
                        selectable: false,
                    });

                    fabricCanvas.add(tempPath);
                }

                fabricCanvas.on('mouse:down', eventHandlers[pageNumber].onMouseDown);
                fabricCanvas.on('mouse:move', eventHandlers[pageNumber].onMouseMove);
                fabricCanvas.on('mouse:dblclick', eventHandlers[pageNumber].onMouseDblClick);
            });

            function generateCloudPath(points, cloudRadius, humpSize) {
                if (points.length < 2) return '';
                const pathData = [];
                let prev = points[points.length - 1];
                const delta = 2 * cloudRadius * 0.7;
                const circlePoints = [];
                for (let i = 0; i < points.length; i++) {
                    const curr = points[i];
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const n = Math.max(1, Math.floor(len / delta));
                    for (let j = 0; j <= n; j++) {
                        circlePoints.push(new Point(prev.x + j * (dx / n), prev.y + j * (dy / n)));
                    }
                    prev = curr;
                }
                prev = circlePoints[circlePoints.length - 1];
                for (let i = 0; i < circlePoints.length; i++) {
                    const curr = circlePoints[i];
                    pathData.push(`M ${prev.x} ${prev.y}`);
                    pathData.push(`A ${cloudRadius},${cloudRadius} 0 0,1 ${curr.x},${curr.y}`);
                    prev = curr;
                }
                return pathData.join(' ');
            }

            function Point(x, y) {
                this.x = x;
                this.y = y;
            }
        }





        function addSquare() {
            console.log("Current Page:", pageNum);
            console.log("Available Fabric Canvases:", fabricCanvases);

            if (isDrawing) {
                console.log("Already in drawing mode, ignoring duplicate click.");
                return;
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;

            let eventHandlers = {};

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];
                console.log("Fabric Canvas for Page:", pageNumber);

                if (!fabricCanvas) {
                    console.error("Fabric.js canvas is not initialized for this page.");
                    return;
                }

                fabricCanvas.isDrawingMode = false;
                fabricCanvas.selection = true;

                let rect = null;
                let origX, origY;

                eventHandlers[pageNumber] = {
                    onMouseDown(e) {
                        const pointer = fabricCanvas.getPointer(e.e);
                        origX = pointer.x;
                        origY = pointer.y;

                        rect = new fabric.Rect({
                            left: origX,
                            top: origY,
                            width: 0,
                            height: 0,
                            fill: '',
                            stroke: 'red',
                            strokeWidth: 2,
                            annotationType: 'square',
                            id: Date.now() + Math.random().toString(36).substr(2, 9),
                        });
                        fabricCanvas.add(rect);
                    },

                    onMouseMove(e) {
                        if (!rect) return;
                        const pointer = fabricCanvas.getPointer(e.e);

                        // Calculate width and height based on mouse position
                        let width = pointer.x - origX;
                        let height = pointer.y - origY;

                        // Update left and top if drawing in negative direction
                        if (width < 0) {
                            rect.set('left', origX + width);
                            width = Math.abs(width);
                        }
                        if (height < 0) {
                            rect.set('top', origY + height);
                            height = Math.abs(height);
                        }

                        rect.set({
                            width: width,
                            height: height
                        });

                        fabricCanvas.renderAll();
                    },

                    onMouseUp() {
                        if (!rect) return;
                        console.log(`Square drawn on page ${pageNumber}:`, rect);

                        storeAnnotation('square', rect, pageNumber);

                        isDrawing = false;

                        Object.keys(fabricCanvases).forEach((page) => {
                            let canvas = fabricCanvases[page];
                            if (canvas && eventHandlers[page]) {
                                canvas.off('mouse:down', eventHandlers[page].onMouseDown);
                                canvas.off('mouse:move', eventHandlers[page].onMouseMove);
                                canvas.off('mouse:up', eventHandlers[page].onMouseUp);
                            }
                        });

                        enableTextLayer();
                    }
                };

                fabricCanvas.on('mouse:down', eventHandlers[pageNumber].onMouseDown);
                fabricCanvas.on('mouse:move', eventHandlers[pageNumber].onMouseMove);
                fabricCanvas.on('mouse:up', eventHandlers[pageNumber].onMouseUp);
            });
        }


        function addLine() {
            console.log("Adding Line Annotations");

            if (isDrawing) {
                console.log("Already in drawing mode, ignoring duplicate click.");
                return;
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;

            let eventHandlers = {};

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];

                if (!fabricCanvas) {
                    console.error("Fabric.js canvas is not initialized for this page.");
                    return;
                }

                fabricCanvas.isDrawingMode = false;
                fabricCanvas.selection = false;

                let line = null;
                let startX, startY;

                eventHandlers[pageNumber] = {
                    onMouseDown(e) {
                        const pointer = fabricCanvas.getPointer(e.e);
                        startX = pointer.x;
                        startY = pointer.y;

                        line = new fabric.Line([startX, startY, startX, startY], {
                            stroke: 'red',
                            strokeWidth: 2,
                            selectable: true,
                            evented: true,
                            annotationType: 'line',
                            id: Date.now() + Math.random().toString(36).substr(2, 9),
                        });

                        fabricCanvas.add(line);
                    },

                    onMouseMove(e) {
                        if (!line) return;
                        const pointer = fabricCanvas.getPointer(e.e);

                        line.set({ x2: pointer.x, y2: pointer.y });
                        fabricCanvas.renderAll();
                    },

                    onMouseUp() {
                        if (!line) return;

                        line.set({ selectable: true, evented: true });
                        line.setCoords();

                        console.log(`Line drawn on page ${pageNumber}:`, line);

                        storeAnnotation('line', line, pageNumber);

                        isDrawing = false;

                        Object.keys(fabricCanvases).forEach((page) => {
                            let canvas = fabricCanvases[page];
                            if (canvas && eventHandlers[page]) {
                                canvas.off('mouse:down', eventHandlers[page].onMouseDown);
                                canvas.off('mouse:move', eventHandlers[page].onMouseMove);
                                canvas.off('mouse:up', eventHandlers[page].onMouseUp);
                            }
                        });

                        enableTextLayer();
                    }
                };

                fabricCanvas.on('mouse:down', eventHandlers[pageNumber].onMouseDown);
                fabricCanvas.on('mouse:move', eventHandlers[pageNumber].onMouseMove);
                fabricCanvas.on('mouse:up', eventHandlers[pageNumber].onMouseUp);
            });
        }


        function addCircle() {
            console.log("Adding Circle Annotations");

            if (isDrawing) {
                console.log("Already in drawing mode, ignoring duplicate click.");
                return;
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;

            let eventHandlers = {};

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];

                if (!fabricCanvas) {
                    console.error("Fabric.js canvas is not initialized for this page.");
                    return;
                }

                fabricCanvas.isDrawingMode = false;
                fabricCanvas.selection = true;

                let circle = null;
                let originX, originY;

                eventHandlers[pageNumber] = {
                    onMouseDown(e) {
                        const pointer = fabricCanvas.getPointer(e.e);
                        originX = pointer.x;
                        originY = pointer.y;

                        circle = new fabric.Circle({
                            left: originX,
                            top: originY,
                            radius: 0,
                            fill: '',
                            stroke: 'red',
                            strokeWidth: 2,
                            annotationType: 'circle',
                            id: Date.now() + Math.random().toString(36).substr(2, 9),
                            selectable: true,
                            evented: true,
                        });

                        fabricCanvas.add(circle);
                    },

                    onMouseMove(e) {
                        if (!circle) return;
                        const pointer = fabricCanvas.getPointer(e.e);

                        const radius = Math.sqrt(
                            Math.pow(pointer.x - originX, 2) + Math.pow(pointer.y - originY, 2)
                        ) / 2;

                        const centerX = (pointer.x + originX) / 2;
                        const centerY = (pointer.y + originY) / 2;

                        circle.set({
                            radius: radius,
                            left: centerX - radius,
                            top: centerY - radius,
                        });

                        fabricCanvas.renderAll();
                    },

                    onMouseUp() {
                        if (!circle) return;

                        circle.setCoords();
                        console.log(`Circle drawn on page ${pageNumber}:`, circle);

                        storeAnnotation('circle', circle, pageNumber);

                        isDrawing = false;

                        Object.keys(fabricCanvases).forEach((page) => {
                            let canvas = fabricCanvases[page];
                            if (canvas && eventHandlers[page]) {
                                canvas.off('mouse:down', eventHandlers[page].onMouseDown);
                                canvas.off('mouse:move', eventHandlers[page].onMouseMove);
                                canvas.off('mouse:up', eventHandlers[page].onMouseUp);
                            }
                        });

                        enableTextLayer();
                    }
                };

                fabricCanvas.on('mouse:down', eventHandlers[pageNumber].onMouseDown);
                fabricCanvas.on('mouse:move', eventHandlers[pageNumber].onMouseMove);
                fabricCanvas.on('mouse:up', eventHandlers[pageNumber].onMouseUp);
            });
        }

        function addText() {
            console.log("Adding Text Annotation");

            if (isDrawing) {
                console.log("Already in drawing mode, ignoring duplicate click.");
                return;
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;

            let eventHandlers = {};

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];

                if (!fabricCanvas) {
                    console.error("Fabric.js canvas is not initialized for this page.");
                    return;
                }

                fabricCanvas.isDrawingMode = false;
                fabricCanvas.selection = true;

                let textObj = null;
                let startX = 0, startY = 0;

                eventHandlers[pageNumber] = {
                    onMouseDown(e) {
                        const pointer = fabricCanvas.getPointer(e.e);
                        startX = pointer.x;
                        startY = pointer.y;

                        textObj = new fabric.Textbox('Enter Text ', {
                            left: startX,
                            top: startY,
                            fontSize: 14,
                            fill: 'black',
                            editable: true,
                            id: `text-${Date.now()}`,
                        });

                        fabricCanvas.add(textObj);
                    },

                    onMouseMove(e) {
                        if (!textObj) return;
                        const pointer = fabricCanvas.getPointer(e.e);

                        const distance = Math.sqrt(
                            Math.pow(pointer.x - startX, 2) + Math.pow(pointer.y - startY, 2)
                        );

                        const newFontSize = Math.max(10, Math.min(50, distance / 2));
                        textObj.set({ fontSize: newFontSize });
                        fabricCanvas.renderAll();
                    },

                    onMouseUp() {
                        if (!textObj) return;

                        console.log(`Text annotation added on page ${pageNumber}:`, textObj);

                        storeAnnotation('text', textObj, pageNumber);

                        textObj.on('changed', () => {
                            updateStoredAnnotation(textObj.id, { text: textObj.text });
                        });

                        isDrawing = false;

                        Object.keys(fabricCanvases).forEach((page) => {
                            let canvas = fabricCanvases[page];
                            if (canvas && eventHandlers[page]) {
                                canvas.off('mouse:down', eventHandlers[page].onMouseDown);
                                canvas.off('mouse:move', eventHandlers[page].onMouseMove);
                                canvas.off('mouse:up', eventHandlers[page].onMouseUp);
                            }
                        });

                        enableTextLayer();
                    }
                };

                fabricCanvas.on('mouse:down', eventHandlers[pageNumber].onMouseDown);
                fabricCanvas.on('mouse:move', eventHandlers[pageNumber].onMouseMove);
                fabricCanvas.on('mouse:up', eventHandlers[pageNumber].onMouseUp);
            });
        }


        function updateStoredAnnotation(id, updates) {
            for (let page in annotationsByPage) {
                const annotation = annotationsByPage[page].find(ann => ann.id === id);
                if (annotation) {
                    Object.assign(annotation, updates);

                    if (updates.text) {
                        annotation.content = updates.text;
                    }

                    console.log("Updated Annotation:", annotation);
                    break;
                }
            }
        }

        function addFreeDraw() {
            console.log("Activating Free Draw Mode");

            if (isDrawing) {
                console.log("Already in drawing mode, ignoring duplicate click.");
                return;
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;

            let eventHandlers = {};

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];

                if (!fabricCanvas) {
                    console.error("Fabric.js canvas is not initialized for this page.");
                    return;
                }

                fabricCanvas.isDrawingMode = true;
                fabricCanvas.freeDrawingBrush.color = "red";
                fabricCanvas.freeDrawingBrush.width = 2;

                eventHandlers[pageNumber] = {
                    onPathCreated(e) {
                        const path = e.path;


                        console.log(`Free draw annotation added on page ${pageNumber}:`, path);

                        storeAnnotation("freeDraw", path, pageNumber);

                        isDrawing = false;

                        Object.keys(fabricCanvases).forEach((page) => {
                            let canvas = fabricCanvases[page];
                            if (canvas) {
                                canvas.isDrawingMode = false;
                                canvas.off("path:created", eventHandlers[page]?.onPathCreated);
                            }
                        });

                        enableTextLayer();
                    }
                };

                fabricCanvas.on("path:created", eventHandlers[pageNumber].onPathCreated);
            });
        }



        //     function setupAnnotationPositionUpdaters() {
        //         Object.keys(fabricCanvases).forEach((pageNumber) => {
        //             const fabricCanvas = fabricCanvases[pageNumber];
        //             if (!fabricCanvas) return;

        //             // Store page number on the canvas for reference
        //             fabricCanvas.pageNumber = pageNumber;

        //             // Add event handlers for position tracking
        //             fabricCanvas.on('object:modified', handleAnnotationUpdate);
        //             fabricCanvas.on('object:moved', handleAnnotationUpdate);
        //         });
        //     }

        //     function handleAnnotationUpdate(e) {
        //         const obj = e.target;
        //         if (!obj || !obj.id) {
        //             console.log("No valid target object found for position update");
        //             return;
        //         }

        //         console.log("Object being moved/modified:", obj);
        //         const annotationType = obj.annotationType || obj.type;
        //         const pageNum = parseInt(this.pageNumber || currentPageNum, 10);

        //         if (!annotationsByPage[pageNum]) {
        //             console.log("No annotations found for page:", pageNum);
        //             return;
        //         }

        //         let searchId = obj.id;
        // if (obj.id.includes('_text') || obj.id.includes('_arrow')) {
        //     searchId = obj.id.split('_')[0]; // Get base ID without suffix
        // }

        // // Find the annotation using the correct ID
        // const annotation = annotationsByPage[pageNum].find(ann => ann.id === searchId);
        // if (!annotation) {
        //     console.log("Annotation not found in storage:", searchId);
        //     return;
        // }


        //         const scaleFactor = getScaleFactor();

        //         // Base position updates
        //         annotation.x1 = obj.left;
        //         annotation.y1 = obj.top;
        //         switch (annotationType) {
        //             case 'text':
        //             case 'textbox':
        //                 annotation.x2 = obj.left + obj.width;
        //                 annotation.y2 = obj.top + obj.height;
        //                 annotation.text = obj.text;
        //                 break;

        //             case 'textCallout':
        //                 annotation.textLeft = obj.left;
        //                 annotation.textTop = obj.top;
        //                 annotation.textWidth = obj.width;
        //                 annotation.textHeight = obj.height;

        //                 // If this is a text box with an arrow, update the arrow separately
        //                 if (this.calloutElements && this.calloutElements[obj.calloutId]) {
        //                     updateCalloutArrow(this, obj.calloutId, true);
        //                 }
        //                 break;

        //             case 'square':
        //             case 'rect':
        //                 annotation.x2 = obj.left + obj.width;
        //                 annotation.y2 = obj.top + obj.height;
        //                 annotation.width = obj.width;
        //                 annotation.height = obj.height;
        //                 break;

        //             case 'circle':
        //                 annotation.radius = obj.radius / scaleFactor.x;
        //                 annotation.x2 = obj.left + obj.radius * 2;
        //                 annotation.y2 = obj.top + obj.radius * 2;
        //                 break;

        //             case 'line':
        //                 // For lines, calculate endpoints based on the line's actual points
        //                 const points = obj.calcLinePoints();
        //                 const matrix = obj.calcTransformMatrix();

        //                 // Transform the endpoints using the fabric.js utility
        //                 const start = fabric.util.transformPoint({ x: points.x1, y: points.y1 }, matrix);
        //                 const end = fabric.util.transformPoint({ x: points.x2, y: points.y2 }, matrix);

        //                 annotation.x1 = start.x;
        //                 annotation.y1 = start.y;
        //                 annotation.x2 = end.x;
        //                 annotation.y2 = end.y;
        //                 break;



        //             case 'freeDraw':
        //                 // For free draw, update the path data if available
        //                 if (obj.path) {
        //                     annotation.path = obj.path;
        //                 }
        //                 annotation.width = obj.width;
        //                 annotation.height = obj.height;
        //                 break;

        //             case 'stamp':
        //             case 'signature':
        //                 // For images like stamps and signatures
        //                 annotation.width = obj.getScaledWidth();
        //                 annotation.height = obj.getScaledHeight();
        //                 annotation.scaleX = obj.scaleX;
        //                 annotation.scaleY = obj.scaleY;
        //                 annotation.angle = obj.angle || 0;
        //                 break;

        //                 case 'cloud':
        // // Store the original position before updating
        // const origX = annotation.x1;
        // const origY = annotation.y1;

        // // Update position properties
        // annotation.x1 = obj.left;
        // annotation.y1 = obj.top;
        // annotation.x2 = obj.left + obj.width;
        // annotation.y2 = obj.top + obj.height;

        // // Calculate movement delta (how far the object moved)
        // const deltaX = annotation.x1 - origX;
        // const deltaY = annotation.y1 - origY;

        // // Only transform the path if the object actually moved
        // if (deltaX !== 0 || deltaY !== 0) {
        //     if (annotation.path) {
        //         const transformedPath = [];

        //         // Apply the translation to each point in the path
        //         for (let i = 0; i < annotation.path.length; i++) {
        //             const cmd = [...annotation.path[i]]; // Clone the command

        //             if (cmd[0] === 'M' || cmd[0] === 'L') {
        //                 // For move and line commands, transform the single point
        //                 cmd[1] += deltaX;
        //                 cmd[2] += deltaY;
        //             } 
        //             else if (cmd[0] === 'C') {
        //                 // For cubic curve commands, transform all three points
        //                 cmd[1] += deltaX; cmd[2] += deltaY; // First control point
        //                 cmd[3] += deltaX; cmd[4] += deltaY; // Second control point
        //                 cmd[5] += deltaX; cmd[6] += deltaY; // End point
        //             }

        //             transformedPath.push(cmd);
        //         }

        //         // Update the annotation with the transformed path
        //         annotation.path = transformedPath;
        //     }
        // }

        // // Store the transform matrix for reference
        // annotation.transformMatrix = obj.calcTransformMatrix();
        // break;

        //         }

        //         console.log("Updated annotation position:", annotation);
        //         try {
        //             localStorage.setItem('pdfAnnotations', JSON.stringify(annotationsByPage));
        //         } catch (error) {
        //             console.error('Error saving updated annotations to storage:', error);
        //         }
        //     }

//The Perfect Once is above code for annotation position updaters

        // ==========================================================================================================================

        // Add this function to initialize event listeners for each canvas
        // function initializeCanvasEventListeners(fabricCanvas) {
        //     // Handle both moving and scaling/rotating
        //     fabricCanvas.on('object:modified', handleAnnotationUpdate);
        //     fabricCanvas.on('object:moved', handleAnnotationUpdate);
        //     fabricCanvas.on('object:scaled', handleAnnotationUpdate);
        //     fabricCanvas.on('object:rotated', handleAnnotationUpdate);

        //     function handleAnnotationUpdate(e) {
        //     const obj = e.target;
        //     if (!obj) {
        //         console.log("No target object found");
        //         return;
        //     }

        //     // Ensure the object has an ID
        //     if (!obj.id) {
        //         console.log("Object does not have an ID:", obj);
        //         return;
        //     }

        //     // Determine the annotation type from the object
        //     let annotationType = obj.annotationType || (obj.type === 'rect' ? 'square' : obj.type);

        //     // Get the page number from the canvas or use current page
        //     const pageNum = parseInt(fabricCanvas.pageNumber || currentPageNum, 10);

        //     if (!annotationsByPage[pageNum]) {
        //         console.log("No annotations found for page:", pageNum);
        //         return;
        //     }
        //         // Find the annotation in our stored collection
        //         const pageAnnotations = annotationsByPage[pageNum];
        //         const annotationIndex = pageAnnotations.findIndex(ann => ann.id === obj.id);

        //         console.log("Object modified:", obj.id, "on page", pageNum, "- Found annotation index:", annotationIndex);

        //         if (annotationIndex !== -1) {
        //             const annotation = pageAnnotations[annotationIndex];
        //             const scaleFactor = getScaleFactor();

        //             // Store original values for debugging
        //             const originalX1 = annotation.x1;
        //             const originalY1 = annotation.y1;

        //             // Base position updates for all types
        //             annotation.x1 = obj.left;
        //             annotation.y1 = obj.top;

        //             // Type-specific updates
        //             switch (annotationType) {
        //                 case 'text':
        //                     annotation.text = obj.text || annotation.text;
        //                     annotation.x2 = obj.left + obj.width;
        //                     annotation.y2 = obj.top + obj.height;
        //                     annotation.fontSize = obj.fontSize / Math.min(scaleFactor.x, scaleFactor.y);
        //                     break;

        //                 case 'textCallout':
        //                     annotation.text = obj.text || annotation.text;
        //                     annotation.content = obj.text || annotation.content;
        //                     annotation.textLeft = obj.left;
        //                     annotation.textTop = obj.top;
        //                     annotation.textWidth = obj.width || annotation.textWidth;
        //                     annotation.textHeight = obj.height || annotation.textHeight;

        //                     // If this is a text box with a linked arrow, update the arrow too
        //                     if (obj.calloutId) {
        //                         updateCalloutArrow(fabricCanvas, obj.calloutId, true);
        //                     }
        //                     break;

        //                 case 'square':
        //                 case 'rect':
        //                     annotation.x2 = obj.left + obj.width;
        //                     annotation.y2 = obj.top + obj.height;
        //                     annotation.width = obj.width;
        //                     annotation.height = obj.height;
        //                     break;

        //                 case 'circle':
        //                     annotation.radius = obj.radius / scaleFactor.x;
        //                     annotation.x2 = obj.left + obj.radius * 2;
        //                     annotation.y2 = obj.top + obj.radius * 2;
        //                     break;

        //                     case 'line': {
        //     // For fabric.Line, use points and transform
        //     const points = obj.calcLinePoints();
        //     const matrix = obj.calcTransformMatrix();

        //     // Get transformed endpoints
        //     const start = fabric.util.transformPoint({ x: points.x1, y: points.y1 }, matrix);
        //     const end = fabric.util.transformPoint({ x: points.x2, y: points.y2 }, matrix);

        //     annotation.x1 = start.x;
        //     annotation.y1 = start.y;
        //     annotation.x2 = end.x;
        //     annotation.y2 = end.y;

        //     annotation.strokeWidth = obj.strokeWidth / scaleFactor.x;

        //     break;
        // }





        //                 case 'cloud':
        //                     // Update position
        //                     annotation.y1 = obj.top;
        //                     // Update path and dimensions
        //                     if (obj.path) annotation.path = obj.path;
        //                     if (obj.pathData) annotation.pathData = obj.pathData;
        //                     if (obj.stroke) annotation.stroke = obj.stroke;
        //                     if (obj.strokeWidth) annotation.strokeWidth = obj.strokeWidth / scaleFactor.x;
        //                     break;

        //                 case 'stamp':
        //                 case 'signature':
        //                     // Update position
        //                     annotation.x1 = obj.left;
        //                     annotation.y1 = obj.top;
        //                     // Update dimensions
        //                     if (obj.getScaledWidth && obj.getScaledHeight) {
        //                         annotation.width = obj.getScaledWidth();
        //                         annotation.height = obj.getScaledHeight();
        //                     } else {
        //                         annotation.width = obj.width || annotation.width;
        //                         annotation.height = obj.height || annotation.height;
        //                     }
        //                     break;
        //             }

        //             console.log(`Updated annotation position from (${originalX1}, ${originalY1}) to (${annotation.x1}, ${annotation.y1})`);

        //             // Update the sidebar if needed
        //             updateSidebar(annotation);
        //         }
        //     }
        // }

        // // Add this in your initialization code
        // function setupAnnotationUpdateListeners() {
        //     Object.keys(fabricCanvases).forEach((pageNumber) => {
        //         let fabricCanvas = fabricCanvases[pageNumber];
        //         if (fabricCanvas) {
        //             fabricCanvas.pageNumber = pageNumber; // Add page number to canvas
        //             initializeCanvasEventListeners(fabricCanvas);
        //         }
        //     });
        // }



        //Shows error 
        // document.getElementById('toggle-free-draw').addEventListener('click', enableFreeDraw);

        // Add this function to initialize event listeners for each canvas
        // function initializeCanvasEventListeners(fabricCanvas) {
        //     // Handle both moving and scaling/rotating
        //     fabricCanvas.on('object:modified', handleAnnotationUpdate);
        //     fabricCanvas.on('object:moved', handleAnnotationUpdate);
        //     fabricCanvas.on('object:scaled', handleAnnotationUpdate);
        //     fabricCanvas.on('object:rotated', handleAnnotationUpdate);

        //     function handleAnnotationUpdate(e) {
        //         const obj = e.target;
        //         if (!obj) {
        //             console.log("No target object found");
        //             return;
        //         }

        //         console.log("Object being modified:", obj);
        //         console.log("Object ID:", obj.id);
        //         let annotationType = obj.annotationType;
        //     if (!annotationType) {
        //         if (obj.type === 'path') {
        //             // For paths, check if it's a cloud or free draw
        //             annotationType = obj.cloudPoints ? 'cloud' : 'freeDraw';
        //         } else if (obj.type === 'image') {
        //             // For images, check if it's a stamp or signature
        //             annotationType = obj.dataURL ? 'signature' : 'stamp';
        //         } else {
        //             annotationType = obj.type;
        //         }
        //     }

        //     console.log("Determined annotation type:", annotationType);

        //         const pageNum = parseInt(fabricCanvas.pageNumber || currentPageNum, 10);
        //         if (!annotationsByPage[pageNum]) {
        //             console.log("No annotations found for page:", pageNum);
        //             return;
        //         }

        //         const pageAnnotations = annotationsByPage[pageNum];
        //         const annotationIndex = pageAnnotations.findIndex(ann => ann.id === obj.id);

        //         console.log("Found annotation index:", annotationIndex);

        //         if (annotationIndex !== -1) {
        //             const annotation = pageAnnotations[annotationIndex];
        //             const scaleFactor = getScaleFactor();

        //              // Store the original values for debugging
        //         const originalX1 = annotation.x1;
        //         const originalY1 = annotation.y1;
        //         const originalX2 = annotation.x2;
        //         const originalY2 = annotation.y2;

        //         console.log(`Original coords: x1=${originalX1}, y1=${originalY1}, x2=${originalX2}, y2=${originalY2}`);


        //             // Base position updates
        //             annotation.x1 = obj.left;
        //             annotation.y1 = obj.top;

        //             console.log(`[${annotation.type}] Base coords updated: x1=${annotation.x1}, y1=${annotation.y1}`);

        //             // Type-specific updates
        //             switch (obj.annotationType || annotation.type) {
        //                 case 'text':
        //                 case 'textCallout':
        //                     annotation.text = obj.text;
        //                     annotation.x2 = obj.left + obj.width;
        //                     annotation.y2 = obj.top + obj.height;
        //                     if (obj.annotationType === 'textCallout') {
        //                         annotation.arrowStart = obj.arrowStart;
        //                         annotation.arrowEnd = obj.arrowEnd;
        //                         annotation.textLeft = obj.left;
        //                         annotation.textTop = obj.top;
        //                         annotation.textWidth = obj.width;
        //                         annotation.textHeight = obj.height;
        //                     }
        //                     break;

        //                 case 'square':
        //                 case 'rect':
        //                     annotation.x2 = obj.left + obj.width;
        //                     annotation.y2 = obj.top + obj.height;
        //                     annotation.width = obj.width;
        //                     annotation.height = obj.height;
        //                     break;

        //                 case 'circle':
        //                     annotation.radius = obj.radius / scaleFactor.x;
        //                     annotation.x2 = obj.left + obj.width;
        //                     annotation.y2 = obj.top + obj.height;
        //                     break;

        //                 case 'line':
        //                     // For lines, we need to calculate the actual endpoints
        //                     const points = obj.calcLinePoints();
        //                     annotation.x1 = obj.left + points.x1;
        //                     annotation.y1 = obj.top + points.y1;
        //                     annotation.x2 = obj.left + points.x2;
        //                     annotation.y2 = obj.top + points.y2;
        //                     break;

        //                     case 'freeDraw':
        //     // Update base position from the object's current position
        //     annotation.x1 = obj.left;
        //     annotation.y1 = obj.top;

        //     // Calculate the offset from original position
        //     const offsetX = obj.left - annotation.x1;
        //     const offsetY = obj.top - annotation.y1;

        //     // Transform the path coordinates relative to new position
        //     if (obj.path && Array.isArray(obj.path)) {
        //         annotation.path = obj.path.map(pathCmd => {
        //             if (pathCmd[0] === 'M' || pathCmd[0] === 'L') {
        //                 return [
        //                     pathCmd[0],
        //                     pathCmd[1] + offsetX,  // Apply x offset
        //                     pathCmd[2] + offsetY   // Apply y offset
        //                 ];
        //             } else if (pathCmd[0] === 'Q') {
        //                 return [
        //                     pathCmd[0],
        //                     pathCmd[1] + offsetX,
        //                     pathCmd[2] + offsetY,
        //                     pathCmd[3] + offsetX,
        //                     pathCmd[4] + offsetY
        //                 ];
        //             }
        //             return pathCmd;
        //         });
        //     }

        //     // Update dimensions and transformation properties
        //     annotation.width = obj.width;
        //     annotation.height = obj.height;
        //     annotation.scaleX = obj.scaleX || 1;
        //     annotation.scaleY = obj.scaleY || 1;
        //     annotation.angle = obj.angle || 0;

        //     // Update x2/y2 based on the bounds
        //     annotation.x2 = annotation.x1 + obj.width;
        //     annotation.y2 = annotation.y1 + obj.height;

        //     console.log(`Updated freeDraw annotation position and path:`, {
        //         left: annotation.x1,
        //         top: annotation.y1,
        //         width: annotation.width,
        //         height: annotation.height,
        //         pathLength: annotation.path.length
        //     });
        //     break;

        //                     case 'stamp':
        //                 case 'signature':
        //                     // Update position (handled by base x1/y1)
        //                     annotation.width = obj.getScaledWidth();
        //                     annotation.height = obj.getScaledHeight();
        //                      // Store scale if needed for re-rendering
        //                      annotation.scaleX = obj.scaleX; 
        //                      annotation.scaleY = obj.scaleY;
        //                     console.log(`Updated ${annotationType} annotation dimensions/scale`); // Added log
        //                     break;
        //             }

        //             console.log(`Updated annotation:`, annotation);
        //         }
        //     }
        // }
        document.addEventListener('keydown', function (event) {
            if (event.ctrlKey || event.metaKey) {
                switch (event.key.toLowerCase()) {
                    case 'z':
                        event.preventDefault();
                        if (event.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                        break;

                    case 'y':
                        event.preventDefault();
                        redo();
                        break;
                }
            }
        });


        let fabricUndoStack = [];
        let fabricRedoStack = [];
        let textUndoStack = [];
        let textRedoStack = [];
        let undoStack = [];
        // let redoStack = [];

        function addToUndoStack(action) {
            if (!action || !action.type || !action.timestamp) {
                console.error("Invalid action format:", action);
                return;
            }

            undoStack.push(action);
            redoStack = [];
            console.log("Successfully added to undo stack:", action);
            console.log("Current undo stack:", undoStack);
            console.log("Current undo stack size:", undoStack.length);
        }


        function undo() {
            console.log("Current undo stack before undo:", undoStack);

            if (undoStack.length === 0) {
                console.log("Nothing to undo");
                showToast('Nothing to undo');
                return;
            }

            const lastAction = undoStack.pop();
            console.log("Undoing action:", lastAction);
            redoStack.push(lastAction);

            if (lastAction.type === 'fabric') {
                const pageNum = lastAction.page;
                const canvas = fabricCanvases[pageNum];

                if (canvas) {
                    const objectToRemove = canvas.getObjects().find(obj => obj.id === lastAction.annotationData.id);
                    if (objectToRemove) {
                        canvas.remove(objectToRemove);
                        canvas.renderAll();
                    }

                    if (annotationsByPage[pageNum]) {
                        annotationsByPage[pageNum] = annotationsByPage[pageNum].filter(
                            ann => ann.id !== lastAction.annotationData.id
                        );
                    }
                }
                renderPage(pageNum);
            } else if (lastAction.type === 'text') {
                lastAction.annotations.forEach(annotation => {
                    const pageNum = annotation.page;

                    if (annotationsByPage[pageNum]) {
                        annotationsByPage[pageNum] = annotationsByPage[pageNum].filter(
                            ann => ann.id !== annotation.id
                        );
                    }

                    renderPageAnnotations(pageNum);
                });
            }

            refreshSidebar();
            showToast('Undo successful');

            // updatePDFAnnotations();
        }

        function redo() {
            if (redoStack.length === 0) {
                console.log("Nothing to redo");
                showToast('Nothing to redo');

                return;
            }

            const lastAction = redoStack.pop();
            console.log("Redoing action:", lastAction);
            undoStack.push(lastAction);

            if (lastAction.type === 'fabric') {
                const pageNum = lastAction.page;
                const canvas = fabricCanvases[pageNum];

                if (canvas) {
                    let newObj;
                    const objData = lastAction.object;

                    switch (objData.type) {
                        case 'rect':
                            newObj = new fabric.Rect(objData);
                            break;
                        case 'circle':
                            newObj = new fabric.Circle(objData);
                            break;
                        case 'line':
                            newObj = new fabric.Line([objData.x1, objData.y1, objData.x2, objData.y2], objData);
                            break;
                        case 'path':
                            newObj = new fabric.Path(objData.path, objData);
                            break;
                        case 'textbox':
                            newObj = new fabric.Textbox(objData.text || '', objData);
                            break;
                        case 'cloud':
                            // Create new cloud path with stored data
                            newObj = new fabric.Path(objData.path || objData.pathData, {
                                fill: 'transparent',
                                stroke: objData.stroke || 'red',
                                strokeWidth: objData.strokeWidth || 2,
                                selectable: true,
                                evented: true,
                                id: objData.id,
                                annotationType: 'cloud',
                                perPixelTargetFind: true,
                                objectCaching: false,
                                strokeLineJoin: 'round',
                                strokeLineCap: 'round',
                                cloudPoints: objData.cloudPoints,
                                cloudRadius: objData.cloudRadius,
                                cloudHumpSize: objData.cloudHumpSize
                            });
                            break;
                        case 'stamp':
                            fabric.Image.fromURL(objData.imgSrc, function (img) {
                                img.set({
                                    left: objData.left,
                                    top: objData.top,
                                    scaleX: 0.6,
                                    scaleY: 0.6,
                                    originX: 'center',
                                    originY: 'center',
                                    selectable: true,
                                    evented: true,
                                    id: objData.id,
                                    annotationType: objData.annotationType
                                });
                                canvas.add(img);
                                canvas.renderAll();

                                if (!annotationsByPage[pageNum]) {
                                    annotationsByPage[pageNum] = [];
                                }
                                annotationsByPage[pageNum].push(lastAction.annotationData);
                                updateSidebar(lastAction.annotationData);
                            });
                            return;
                        case 'signature':
                            fabric.Image.fromURL(objData.dataURL, function (img) {
                                img.set({
                                    left: objData.left,
                                    top: objData.top,
                                    scaleX: 0.4,
                                    scaleY: 0.4,
                                    originX: 'center',
                                    originY: 'center',
                                    selectable: true,
                                    evented: true,
                                    id: objData.id,
                                    annotationType: objData.annotationType
                                });
                                canvas.add(img);
                                canvas.renderAll();

                                if (!annotationsByPage[pageNum]) {
                                    annotationsByPage[pageNum] = [];
                                }
                                annotationsByPage[pageNum].push(lastAction.annotationData);
                                updateSidebar(lastAction.annotationData);
                            });
                            return;
                        // Modify the redo function to properly handle textCallout annotations
                        // Add this case after the 'cloud' case in the switch statement (around line 9103)

                        case 'textCallout':
                            // For text callout, we need to create both the text box and the arrow
                            const calloutData = lastAction.annotationData;

                            // 1. Create the text box
                            const textBox = new fabric.Textbox(calloutData.text || '', {
                                left: calloutData.textLeft,
                                top: calloutData.textTop,
                                fontSize: 13,
                                fill: 'red',
                                backgroundColor: 'white',
                                strokeWidth: 0.5,
                                stroke: 'red',
                                strokeUniform: true,
                                padding: 5,
                                width: calloutData.textWidth || 75,
                                height: calloutData.textHeight || 20,
                                editable: true,
                                showTextBoxBorder: true,
                                hasControls: true
                            });

                            // 2. Create the arrow
                            const arrowStart = calloutData.arrowStart;
                            const arrowEnd = calloutData.arrowEnd;

                            const arrow = createArrow([
                                arrowStart[0],
                                arrowStart[1],
                                arrowEnd[0],
                                arrowEnd[1]
                            ], {
                                stroke: 'red',
                                strokeWidth: 1.5,
                                fill: 'red'
                            });

                            // 3. Set properties for both elements
                            const calloutId = calloutData.id;

                            arrow.set({
                                id: calloutId + '_arrow',
                                calloutId: calloutId,
                                annotationType: 'textCallout',
                                startX: arrowStart[0],
                                startY: arrowStart[1],
                                endX: arrowEnd[0],
                                endY: arrowEnd[1],
                                selectable: false,
                                hasControls: false,
                                lockMovementX: true,
                                lockMovementY: true,
                                hoverCursor: 'default'
                            });

                            textBox.set({
                                id: calloutId + '_text',
                                calloutId: calloutId,
                                annotationType: 'textCallout',
                                selectable: true
                            });

                            // 4. Add both elements to canvas
                            canvas.add(arrow);
                            canvas.add(textBox);

                            // 5. Store reference for future updates
                            canvas.calloutElements = canvas.calloutElements || {};
                            canvas.calloutElements[calloutId] = {
                                textBox: textBox,
                                arrow: arrow,
                                startPoint: { x: arrowStart[0], y: arrowStart[1] }
                            };

                            // 6. Add event listeners for the text box
                            textBox.on('moving', function () {
                                updateCalloutArrow(canvas, calloutId);
                            });

                            textBox.on('moved', function () {
                                updateCalloutArrow(canvas, calloutId, true);
                            });

                            textBox.on('editing:exited', function () {
                                updateTextCalloutContent(calloutId, textBox.text);
                            });

                            textBox.on('changed', function () {
                                updateTextCalloutContent(calloutId, textBox.text);
                            });

                            // 7. Store the annotation in the page
                            if (!annotationsByPage[pageNum]) {
                                annotationsByPage[pageNum] = [];
                            }
                            annotationsByPage[pageNum].push(calloutData);
                            updateSidebar(calloutData);

                            // We've handled everything manually, so return to skip the default object handling
                            return;
                        default:
                            console.error('Unknown object type:', objData.type);
                            return;
                    }
                    if (newObj) {
                        newObj.id = objData.id;
                        newObj.annotationType = objData.annotationType;
                        canvas.add(newObj);
                        canvas.renderAll();

                        if (!annotationsByPage[pageNum]) {
                            annotationsByPage[pageNum] = [];
                        }
                        annotationsByPage[pageNum].push(lastAction.annotationData);
                    }
                }
            }

            else if (lastAction.type === 'text') {
                lastAction.annotations.forEach(annotation => {
                    const pageNum = annotation.page;

                    if (!annotationsByPage[pageNum]) {
                        annotationsByPage[pageNum] = [];
                    }
                    annotationsByPage[pageNum].push(annotation);

                    renderPageAnnotations(pageNum);
                });
            }

            refreshSidebar();
            // updatePDFAnnotations();
            showToast('Redo successful');

        }

        function showToast(message) {
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                document.body.appendChild(toastContainer);
            }

            const toast = document.createElement('div');
            toast.className = 'toast';

            const icon = message.toLowerCase().includes('success') ? '✓' :
                message.toLowerCase().includes('nothing') ? 'ℹ' : '!';

            toast.innerHTML = `
        <span class="toast-icon">${icon}</span>
        <span class="toast-message">${message}</span>
    `;

            toastContainer.appendChild(toast);

            requestAnimationFrame(() => {
                toast.classList.add('show');
            });

            setTimeout(() => {
                toast.classList.add('fade-out');
                setTimeout(() => {
                    if (toastContainer.contains(toast)) {
                        toastContainer.removeChild(toast);
                    }
                }, 500);
            }, 3000);
        }

        function renderPageAnnotations(pageNum) {
            const pageWrapper = document.querySelector(`[data-page-number="${pageNum}"]`);
            if (pageWrapper) {
                const annotationCanvas = pageWrapper.querySelector('.annotation-canvas');
                if (annotationCanvas) {
                    const ctx = annotationCanvas.getContext('2d');
                    const viewport = {
                        width: annotationCanvas.width,
                        height: annotationCanvas.height
                    };
                    renderAnnotations(pageNum, ctx, viewport);
                }
            }
        }

        // function addToUndoStack(fabricObject, pageNumber) {
        //     if (!fabricUndoStack[pageNumber]) {
        //         fabricUndoStack[pageNumber] = [];
        //     }

        //     // Add timestamp to the object
        //     fabricObject.timestamp = Date.now();

        //     fabricUndoStack[pageNumber].push({
        //         object: fabricObject,
        //         page: pageNumber,
        //         timestamp: fabricObject.timestamp
        //     });

        //     // Clear redo stack for this page
        //     fabricRedoStack[pageNumber] = [];
        // }

        // function updatePDFAnnotations() {
        //     // Combine Fabric.js and text-layer annotations

        //     if (annotationsByPage[currentPageNum]) {
        //         console.log("Annotations By Page after Redo:", annotationsByPage[currentPageNum]);
        //         allAnnotations.push(...annotationsByPage[currentPageNum]);
        //     }

        //     console.log("Annotations for PDF:", allAnnotations);
        //     saveAnnotationsToPDF(allAnnotations);
        // }

        function saveAnnotationsToPDF(annotations) {
            if (annotations.length === 0) {
                console.warn("No annotations to save!");
                return;
            }
            console.log("Saving Annotations:", annotations);
        }


        function refreshSidebar() {
            const annotationList = document.getElementById("annotationList");
            annotationList.innerHTML = "";

            Object.values(annotationsByPage).flat().forEach(annotation => {
                updateSidebar(annotation);
            });
        }


        // function save() {
        //     // showToast('Saving annotations...');

        //     const annotations = [];
        //     Object.keys(annotationsByPage).forEach(pageNum => {
        //         annotations.push(...annotationsByPage[pageNum]);
        //     });

        //     fabricCanvas.getObjects().forEach(obj => {
        //         if (!obj.id || annotations.find(ann => ann.id === obj.id)) {
        //             return; 
        //         }

        //         console.log("Object on canvas:", obj); 
        //         if (obj.type === 'textbox') {
        //             console.log("Saving textbox object:", obj); 
        //             annotations.push({
        //         id: obj.id,
        //         type: 'text',
        //         page: pageNum,
        //         x1: obj.left,
        //         y1: obj.top,
        //         x2: obj.left + obj.width * obj.scaleX,  
        //         y2: obj.top + obj.height * obj.scaleY,  
        //         text: obj.text || "Enter Text",
        //         fontSize: obj.fontSize,
        //         fontFamily: obj.fontFamily || 'Arial',
        //         fill: obj.fill || 'black',
        //         title: "Text Annotation",
        //         subject: "Text",
        //         content: obj.text || "Enter Text",
        //         strokeWidth: obj.strokeWidth || 1,
        //         selectable: true,
        //         evented: true
        //     });
        //         } else if (obj.annotationType === 'highlight') {
        //             annotations.push({
        //                 type: 'highlight',
        //                 page: pageNum,
        //                 x1: obj.left,
        //                 y1: obj.top,
        //                 x2: obj.left + obj.width,
        //                 y2: obj.top + obj.height,
        //                 fill: obj.fill,
        //             });
        //         } else if (obj.annotationType === 'underline') {
        //             annotations.push({
        //                 type: 'underline',
        //                 page: pageNum,
        //                 x1: obj.left,
        //                 y1: obj.top,
        //                 x2: obj.left + obj.width,
        //                 y2: obj.top + obj.height,
        //             });
        //         } else if (obj.annotationType === 'strikeout') {
        //             annotations.push({
        //                 type: 'strikeout',
        //                 page: pageNum,
        //                 x1: obj.left,
        //                 y1: obj.top,
        //                 x2: obj.left + obj.width,
        //                 y2: obj.top + obj.height,
        //                 stroke: obj.stroke,
        //                 strokeWidth: obj.strokeWidth,

        //             });
        //         }
        //         else if (obj.annotationType === 'square') {
        //             annotations.push({
        //                 id: obj.id,
        //                 type: 'square',
        //                 page: pageNum,
        //                 x1: obj.left,
        //                 y1: obj.top,
        //                 x2: obj.left + obj.width,
        //                 y2: obj.top + obj.height,
        //                 stroke: obj.stroke,
        //                 strokeWidth: obj.strokeWidth,
        //                 title: "Square Annotation",
        //                 subject: "Square Subject",
        //                 content: "This is a square annotation."
        //             });
        //         } else if (obj.type === 'circle') {
        //             annotations.push({
        //                 type: 'circle',
        //                 page: pageNum, 
        //                 x1: obj.left,
        //                 y1: obj.top,
        //                 radius: obj.radius,
        //                 fill: obj.fill,
        //                 stroke: obj.stroke,
        //                 strokeWidth: obj.strokeWidth,
        //                 title: "Circle ",  
        //                 subject: "Circle Subject",  
        //                 content: "This is a circle annotation."  
        //             });
        //         } else if (obj.type === 'line') {
        //             annotations.push({
        //                 type: 'line',
        //                 page: pageNum, 
        //                 x1: obj.x1,
        //                 y1: obj.y1,
        //                 x2: obj.x2,
        //                 y2: obj.y2,
        //                 stroke: obj.stroke,
        //                 strokeWidth: obj.strokeWidth,
        //                 title: "Line ",  
        //                 subject: "Line Subject",  
        //                 content: "This is a line annotation."  
        //             });
        //         } else if (obj.type === 'path') {
        //             if (obj.annotationType === 'cloud') { 
        //                 annotations.push({
        //                     type: 'cloud',
        //                     page: pageNum,
        //                     path: obj.path,
        //                     cloudPoints: obj.cloudPoints,
        //                     cloudRadius: obj.cloudRadius,
        //                     cloudHumpSize: obj.cloudHumpSize,   
        //                     stroke: obj.stroke,
        //                     strokeWidth: obj.strokeWidth,
        //                     title: "Cloud Annotation",
        //                     subject: "Cloud Subject",
        //                     content: "This is a cloud annotation.",
        //                 });
        //             } else if (obj.annotationType === 'stamp') {
        //                 annotations.push({
        //                     type: 'stamp',
        //                     page: pageNum,
        //                     x1: obj.left,
        //                     y1: obj.top,
        //                     x2: obj.left + obj.width,
        //                     y2: obj.top + obj.height,
        //                     imgSrc: obj.imgSrc, 
        //                     width: obj.width,
        //                     height: obj.height,
        //                     title: "Stamp",
        //                     subject: "Stamp Subject",
        //                     content: "This is a stamp annotation.",
        //                 });
        //             } else if (obj.annotationType === 'signature') {
        //                 annotations.push({
        //                     type: 'signature',
        //                     page: pageNum,
        //                     x1: obj.left,
        //                     y1: obj.top,
        //                     width: obj.getScaledWidth(),
        //                     height: obj.getScaledHeight(),
        //                     dataURL: obj.dataURL, 
        //                     title: "Signature",
        //                     subject: "Signature Subject",
        //                     content: "This is a signature annotation.",
        //                 });
        //             } else {
        //                 annotations.push({
        //                     type: 'freeDraw',
        //                     page: pageNum,
        //                     path: obj.path,
        //                     stroke: obj.stroke,
        //                     strokeWidth: obj.strokeWidth,
        //                     title: "Free Draw",
        //                     subject: "Free Draw Subject",
        //                     content: "This is a free draw annotation.",
        //                 });
        //             }
        //         }
        //     });
        //     console.log("Annotations Saved:", annotations);

        //     const fileInput = document.getElementById('file-input');
        //     const reader = new FileReader();
        //     reader.onload = function (e) {
        //         const pdfData = e.target.result.split(',')[1];
        //         fetch('http://127.0.0.1:5000/save', {  
        //             method: 'POST',
        //             body: JSON.stringify({ pdf: pdfData, annotations }),
        //             headers: { 'Content-Type': 'application/json' },
        //         })
        //             .then(response => response.blob())
        //             .then(blob => {
        //                 const url = window.URL.createObjectURL(blob);
        //                 const a = document.createElement('a');
        //                 a.href = url;
        //                 a.download = 'Annotated.pdf';
        //                 a.click();
        //                 window.URL.revokeObjectURL(url);
        //                 showToast('PDF saved successfully');
        //             })
        //             .catch(error => {
        //                 showToast('Error saving PDF');
        //                 console.error("Error saving PDF:", error);
        //             });
        //     };
        //     if (fileInput.files.length > 0) {
        //         reader.readAsDataURL(fileInput.files[0]);
        //     } else {
        //         showToast('Error saving PDF');
        //     }
        // }



        function save11() {

            try {

                showToast('Processing PDF for download...');

                if (!cleanedPdfData) {
                    throw new Error('Cleaned PDF data is not available');
                }

                // showToast('Saving annotations...');

                const annotations = [];
                Object.keys(annotationsByPage).forEach(pageNum => {
                    annotations.push(...annotationsByPage[pageNum]);
                });

                fabricCanvas.getObjects().forEach(obj => {
                    if (!obj.id || annotations.find(ann => ann.id === obj.id)) {
                        return;
                    }

                    console.log("Object on canvas:", obj);
                    if (obj.type === 'textbox') {
                        console.log("Saving textbox object:", obj);
                        annotations.push({
                            UserName: "Anurag Sable",
                            DocumentId: sessionDocumentId,
                            UserId: sessionUserId,
                            id: obj.id,
                            type: 'text',
                            page: pageNum,
                            x1: obj.left,
                            y1: obj.top,
                            x2: obj.left + obj.width * obj.scaleX,
                            y2: obj.top + obj.height * obj.scaleY,
                            text: obj.text || "Enter Text",
                            fontSize: obj.fontSize,
                            fontFamily: obj.fontFamily || 'Arial',
                            fill: obj.fill || 'black',
                            title: "Text Annotation",
                            subject: "Text",
                            content: obj.text || "Enter Text",
                            strokeWidth: obj.strokeWidth || 1,
                            selectable: true,
                            evented: true
                        });
                    } else if (obj.annotationType === 'highlight') {
                        annotations.push({
                            type: 'highlight',
                            page: pageNum,
                            x1: obj.left,
                            y1: obj.top,
                            x2: obj.left + obj.width,
                            y2: obj.top + obj.height,
                            fill: obj.fill,
                        });
                    } else if (obj.annotationType === 'underline') {
                        annotations.push({
                            type: 'underline',
                            page: pageNum,
                            x1: obj.left,
                            y1: obj.top,
                            x2: obj.left + obj.width,
                            y2: obj.top + obj.height,
                        });
                    } else if (obj.annotationType === 'strikeout') {
                        annotations.push({
                            type: 'strikeout',
                            page: pageNum,
                            x1: obj.left,
                            y1: obj.top,
                            x2: obj.left + obj.width,
                            y2: obj.top + obj.height,
                            stroke: obj.stroke,
                            strokeWidth: obj.strokeWidth,

                        });
                    }
                    else if (obj.annotationType === 'square') {
                        annotations.push({
                            id: obj.id,
                            type: 'square',
                            page: pageNum,
                            x1: obj.left,
                            y1: obj.top,
                            x2: obj.left + obj.width,
                            y2: obj.top + obj.height,
                            stroke: obj.stroke,
                            strokeWidth: obj.strokeWidth,
                            title: "Square Annotation",
                            subject: "Square Subject",
                            content: "This is a square annotation."
                        });
                    } else if (obj.type === 'circle') {
                        annotations.push({
                            type: 'circle',
                            page: pageNum,
                            x1: obj.left,
                            y1: obj.top,
                            radius: obj.radius,
                            fill: obj.fill,
                            stroke: obj.stroke,
                            strokeWidth: obj.strokeWidth,
                            title: "Circle ",
                            subject: "Circle Subject",
                            content: "This is a circle annotation."
                        });
                    } else if (obj.type === 'line') {
                        annotations.push({
                            type: 'line',
                            page: pageNum,
                            x1: obj.x1,
                            y1: obj.y1,
                            x2: obj.x2,
                            y2: obj.y2,
                            stroke: obj.stroke,
                            strokeWidth: obj.strokeWidth,
                            title: "Line ",
                            subject: "Line Subject",
                            content: "This is a line annotation."
                        });
                    } else if (obj.type === 'path') {
                        if (obj.annotationType === 'cloud') {
                            annotations.push({
                                type: 'cloud',
                                page: pageNum,
                                path: obj.path,
                                cloudPoints: obj.cloudPoints,
                                cloudRadius: obj.cloudRadius,
                                cloudHumpSize: obj.cloudHumpSize,
                                stroke: obj.stroke,
                                strokeWidth: obj.strokeWidth,
                                title: "Cloud Annotation",
                                subject: "Cloud Subject",
                                content: "This is a cloud annotation.",
                            });
                        } else if (obj.annotationType === 'stamp') {
                            annotations.push({
                                type: 'stamp',
                                page: pageNum,
                                x1: obj.left,
                                y1: obj.top,
                                x2: obj.left + obj.width,
                                y2: obj.top + obj.height,
                                imgSrc: obj.imgSrc,
                                width: obj.width,
                                height: obj.height,
                                title: "Stamp",
                                subject: "Stamp Subject",
                                content: "This is a stamp annotation.",
                            });
                        } else if (obj.annotationType === 'signature') {
                            annotations.push({
                                type: 'signature',
                                page: pageNum,
                                x1: obj.left,
                                y1: obj.top,
                                width: obj.getScaledWidth(),
                                height: obj.getScaledHeight(),
                                dataURL: obj.dataURL,
                                title: "Signature",
                                subject: "Signature Subject",
                                content: "This is a signature annotation.",
                            });
                        } else {
                            annotations.push({
                                type: 'freeDraw',
                                page: pageNum,
                                path: obj.path,
                                stroke: obj.stroke,
                                strokeWidth: obj.strokeWidth,
                                title: "Free Draw",
                                subject: "Free Draw Subject",
                                content: "This is a free draw annotation.",
                            });
                        }
                    }
                });
                console.log("Collected annotations:", annotations);


                if (!sessionUserId) {
                    showToast('Error: User ID is not set');
                    console.error('sessionUserId is not set');
                    return;
                }

                if (!sessionDocumentId) {
                    showToast('Error: Document ID is not set');
                    console.error('sessionDocumentId is not set');
                    return;
                }

                const formData = new FormData();
                const pdfBlob = new Blob([cleanedPdfData], { type: 'application/pdf' });
                formData.append('file', pdfBlob, 'cleaned.pdf');
                formData.append('DocumentId', sessionDocumentId);
                formData.append('UserId', sessionUserId);
                formData.append('userId', sessionUserId);
                formData.append('annotations', JSON.stringify(annotations));

                console.log("Sending DocumentId:", sessionDocumentId);
                console.log("Sending UserId:", sessionUserId);

                const commentList = annotations.map(annotation => ({
                    UserId: sessionUserId,
                    Comments: annotation.content || "No content",
                    Remark: "Empty",
                    CommentDate: new Date().toISOString(),
                    AnnotationType: annotation.type,
                    PageNumber: annotation.page,
                    Id: generateGuid(),
                    UserName: "Anurag Sable"
                }));

                const backendData = {
                    DocumentId: sessionDocumentId,
                    CommentList: commentList
                };

                console.log("Backend Data to be sent:", backendData);
                sendAnnotationToBackend(backendData);


                const urlParams = new URLSearchParams(window.location.search);
                const pdfUrl = urlParams.get('pdf');

                if (!pdfUrl) {
                    throw new Error('No PDF URL found');
                }

                // Show loading toast
                showToast('Processing PDF...');


                // For IIS 


                const base64Url = btoa(pdfUrl);

                fetch(`/load-pdf/${base64Url}`)
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(error => {
                                throw new Error(error.error || 'Failed to load PDF');
                            });
                        }
                        return response.arrayBuffer();
                    }).then(pdfData => {


                        // Convert PDF data to base64
                        // const base64pdf = btoa(
                        //     new Uint8Array(pdfData)
                        //         .reduce((data, byte) => data + String.fromCharCode(byte), '')
                        // );

                        // Create the exact JSON format required
                        // const formData = new FormData();

                        // // Create Blob from base64 PDF
                        // const pdfBlob = new Blob([pdfData], { type: 'application/pdf' });


                        // formData.append('file', pdfBlob, 'annotated.pdf');
                        // formData.append('DocumentId', sessionDocumentId);
                        // formData.append('annotations', JSON.stringify(annotations));  


                        // Send to backend
                        return fetch('/api/comment/Pdf', {
                            method: 'POST',
                            body: formData
                        });
                    })



                //for local server


                // // First fetch the PDF
                // fetch(`/load-pdf/${encodeURIComponent(pdfUrl)}`)
                // .then(response => {
                // if (!response.ok) {
                // throw new Error('Failed to load PDF');
                // }
                // return response.arrayBuffer();
                // })
                // .then(pdfData => {
                // Convert ArrayBuffer to Base64
                // const base64pdf = btoa(
                // new Uint8Array(pdfData)
                //     .reduce((data, byte) => data + String.fromCharCode(byte), '')
                // );


                // // Send to backend
                // return fetch('http://127.0.0.1:80/save', {
                //         method: 'POST',
                //         headers: {
                //             'Content-Type': 'application/json',
                //         },
                //         body: JSON.stringify({
                //             pdf: base64pdf,
                //             annotations: annotations,
                //             savePath:'D:/Publish Code/PdfAnnotation'
                //         })
                //     });
                // })



            } catch (error) {
                console.error("Error in save function:", error);
                showToast(`Error: ${error.message}`);
            }
        }


        // ===================================================================================


        function save111() {
            try {
                showToast('Processing PDF for download...');

                if (!cleanedPdfData) {
                    throw new Error('Cleaned PDF data is not available');
                }

                const annotations = [];
                console.log("Annotations by page at save function:", annotationsByPage);
                Object.keys(annotationsByPage).forEach(pageNum => {
                    annotations.push(...annotationsByPage[pageNum]);
                });


                // Create form data
                const formData = new FormData();
                const pdfBlob = new Blob([cleanedPdfData], { type: 'application/pdf' });
                formData.append('file', pdfBlob, 'cleaned.pdf');
                formData.append('annotations', JSON.stringify(annotations));

                formData.append('DocumentId', sessionDocumentId);
                formData.append('userId', sessionUserId);

                // Send request to download endpoint
                fetch('/api/download/annotated-pdf', {
                    method: 'POST',
                    body: formData
                })

                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Failed to download PDF');
                        }
                        return response.blob();
                    })
                    // .then(blob => {
                    // Create a new FormData for the merge operation
                    //             const mergeFormData = new FormData();
                    //             const annotatedBlob = new Blob([blob], { type: 'application/pdf' });
                    // mergeFormData.append('file', annotatedBlob, 'annotated_document.pdf');

                    //             mergeFormData.append('annotations', JSON.stringify(annotations)); 
                    //             mergeFormData.append('DocumentId', sessionDocumentId);
                    //             mergeFormData.append('userId', sessionUserId);
                    //             console.log("Sending merge request with annotations:", annotations);

                    //             // Second API call to merge PDFs
                    //             return fetch('/api/download/merge-annotated-pdf', {
                    //                 method: 'POST',
                    //                 body: mergeFormData
                    //             });
                    //         })
                    //         .then(response => {
                    //     console.log("Merge response content-type:", response.headers.get("Content-Type"));
                    //     if (!response.ok) {
                    //         throw new Error('Failed to merge PDF');
                    //     }
                    //     return response.blob();
                    // })

                    .then(blob => {
                        // Create download link
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'annotated_document.pdf';
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        a.remove();
                        showToast('Download complete!');
                    })
                    .catch(error => {
                        console.error("Error downloading PDF:", error);
                        showToast(`Error: ${error.message}`);
                    });

            } catch (error) {
                console.error("Error in download function:", error);
                showToast(`Error: ${error.message}`);
            }
        }





        function save() {
            try {
                showToast('Processing PDF for backend...');

                if (!cleanedPdfData) {
                    throw new Error('Cleaned PDF data is not available');
                }

                const annotations = [];
                console.log("Annotations by page at save function:", annotationsByPage);
                Object.keys(annotationsByPage).forEach(pageNum => {
                    annotations.push(...annotationsByPage[pageNum]);
                });

                const formData = new FormData();
                const pdfBlob = new Blob([cleanedPdfData], { type: 'application/pdf' });
                formData.append('file', pdfBlob, 'cleaned.pdf');
                formData.append('annotations', JSON.stringify(annotations));
                formData.append('DocumentId', sessionDocumentId);
                formData.append('userId', sessionUserId);

                const commentList = annotations.map(annotation => ({
                    UserId: sessionUserId,
                    Comments: annotation.content || "No content",
                    Remark: "Empty",
                    CommentDate: new Date().toISOString(),
                    AnnotationType: annotation.type,
                    PageNumber: annotation.page,
                    Id: generateGuid(),
                    UserName: "Anurag Sable"
                }));

                const backendData = {
                    DocumentId: sessionDocumentId,
                    CommentList: commentList
                };

                console.log("Backend Data to be sent:", backendData);
                sendAnnotationToBackend(backendData);

                console.log("Sending request with annotations:", annotations);

                fetch('/api/download/merge-annotated-pdf', {
                    method: 'POST',
                    body: formData
                })
                    .then(response => {
                        console.log("Response content-type:", response.headers.get("Content-Type"));
                        if (!response.ok) {
                            throw new Error('Failed to send PDF to backend');
                        }
                        showToast('PDF sent to backend successfully!');
                    })
                    .catch(error => {
                        console.error("Error processing PDF:", error);
                        showToast(`Error: ${error.message}`);
                    });

            } catch (error) {
                console.error("Error in save function:", error);
                showToast(`Error: ${error.message}`);
            }
        }

        function sendPDFLinksToBackend() {
            const currentUrl = window.location.href;
            console.log("Current URL:", currentUrl);

            const userNameKey = '&UserName=';
            const userNamePos = currentUrl.indexOf(userNameKey);
            if (userNamePos === -1) {
                console.error('UserName parameter not found in URL');
                return;
            }

            const startAfterUserName = currentUrl.indexOf('&', userNamePos + userNameKey.length);
            if (startAfterUserName === -1) {
                console.error('No content found after UserName');
                return;
            }

            const afterUserNameSection = currentUrl.substring(startAfterUserName + 1);
            console.log("Section after UserName:", afterUserNameSection);

            const parts = afterUserNameSection.split('&');

            const pdfUrls = parts
                .filter(p => p.startsWith('http') && p.toLowerCase().includes('.pdf'))

            if (pdfUrls.length === 0) {
                console.log('No PDF links found after UserName, skipping backend call');
                return;
            }


            console.log('PDF URLs to send:', pdfUrls);

            fetch('http://localhost/api/receive-pdf-links', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ pdfUrls })
            })
                .then(async response => {
                    const contentType = response.headers.get("content-type");
                    if (contentType && contentType.includes("application/json")) {
                        const data = await response.json();
                        console.log('Server response:', data);
                    } else {
                        const text = await response.text();
                        console.warn('Non-JSON response:', text);
                    }
                })
                .catch(error => {
                    console.error('Error sending PDF links:', error);
                });
        }

        sendPDFLinksToBackend();







        fabricCanvasElement.addEventListener('mousedown', (e) => {
            isDrawing = true;
            pdfContext.beginPath();
            pdfContext.moveTo(e.offsetX, e.offsetY);
        });
        fabricCanvasElement.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                pdfContext.lineTo(e.offsetX, e.offsetY);
                pdfContext.stroke();
            }
        });
        fabricCanvasElement.addEventListener('mouseup', () => {
            isDrawing = false;
            pdfContext.closePath();
        });
        // console.log("Annotations to be sent:", annotations);

    </script>


    <script src="../assets/plugins/jquery/jquery.min.js"></script>
    <!-- Bootstrap 4 -->
    <script src="../assets/plugins/bootstrap/js/bootstrap.bundle.min.js"></script>

    <script src="../assets/plugins/bs-custom-file-input/bs-custom-file-input.min.js"></script>

    <!-- AdminLTE App -->
    <script src="../assets/js/main.js"></script>
    <!-- AdminLTE for demo purposes -->
    <script src="../assets/js/demo.js"></script>
    <!-- Page specific script -->

    <script>
        $(function () {
            bsCustomFileInput.init();
        });
    </script>
    <script>
        $(document).ready(function () {
            $('[data-toggle="tooltip"]').tooltip();
        });
    </script>

</body>

</html>
