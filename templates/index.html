<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>PDF Annotations | Dashboard</title>
    <!-- Google Font: Source Sans Pro -->
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="../assets/plugins/fontawesome-free/css/all.min.css">

    <!-- Tempusdominus Bootstrap 4 -->
    <link rel="stylesheet" href="../assets/plugins/tempusdominus-bootstrap-4/css/tempusdominus-bootstrap-4.min.css">
    <!-- Theme style -->
    <link rel="stylesheet" href="../assets/css/main.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.2.4/fabric.min.js"></script>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .content-wrapper {
            height: 100%;
            overflow-y: auto;
            position: relative;
        }

        #sidebar {
            width: 300px;
            position: fixed;
            top: 74px;
            right: 44px;
            background-color: #ffffff;
            padding: 20px;
            height: 78vh;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        #sidebar h2 {
            color: #2c3e50;
            font-size: 1.5rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .annotation-item {
            background-color: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 15px;
            transition: all 0.2s ease;
            border: 1px solid #e9ecef;
        }

        .annotation-box {
            padding: 15px;
            position: relative;
        }

        .annotation-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e9ecef;
        }

        .annotation-type {
            background-color: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            margin-right: 10px;
        }

        .annotation-timestamp {
            color: #6c757d;
            font-size: 0.8rem;
            margin-left: auto;
        }

        .annotation-content {
            color: #495057;
            font-size: 0.95rem;
            line-height: 1.5;
            margin: 10px 0;
        }

        .annotation-actions {
            display: flex;
            gap: 8px;
            padding: 8px 15px;
            background-color: #f8f9fa;
            border-top: 1px solid #e9ecef;
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
        }

        .btn-action {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            transition: all 0.2s ease;
        }

        .btn-edit {
            background-color: #e3f2fd;
            color: #1976d2;
        }

        .btn-edit:hover {
            background-color: #bbdefb;
        }

        .btn-delete {
            background-color: #fee2e2;
            color: #dc2626;
        }

        .btn-delete:hover {
            background-color: #fecaca;
        }

        .annotation-empty {
            text-align: center;
            padding: 30px 20px;
            color: #6c757d;
        }

        /* Scrollbar styling */
        #sidebar::-webkit-scrollbar {
            width: 6px;
        }

        #sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        #sidebar::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        #sidebar::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Animation for new annotations */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .annotation-item {
            animation: slideIn 0.3s ease-out;
        }

        .annotation-box strong {
            color: #333;
            display: inline-block;
            width: 80px;
        }

        .annotation-item {
            cursor: pointer;
            margin-bottom: 10px;
        }

        .annotation-item:hover {
            background-color: #e9e9e9;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            overflow: auto;
        }

        .modal-content {
            background-color: #fff;
            margin: 15% auto;
            padding: 15px;
            border-radius: 8px;
            width: 80%;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
        }

        input[type="text"],
        textarea {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button[type="submit"] {
            background-color: #007BFF;
            color: #fff;
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button[type="submit"]:hover {
            background-color: #0056b3;
        }

        button:hover {
            background-color: #45a049;
        }

        body {
            background-color: #e0e0e0;
        }

        .content-wrapper {
            background-color: #e0e0e0;
        }

        .btn-default {
            background-color: #f7f7f7;
            border-color: #f5f5f5;
            color: #5d5d5d;
        }

        .upper-canvas {
            height: 66vh;
        }

        #pdf-container {
            position: relative;
            height: 580px;
            overflow: auto;
        }

        #page-num,
        #page-count {
            font-size: 18px;
            font-weight: bold;
        }

        .fabric-circle {
            background-color: rgba(244, 67, 54, 0.4);
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.3);
        }

        .fabric-line {
            stroke: #4caf50;
            stroke-width: 2;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.2);
        }

        .fabric-textbox {
            color: #1976d2;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 0 5px rgba(25, 118, 210, 0.4);
        }

        #pdf-container canvas {
            transition: all 0.3s ease-in-out;
            position: absolute;
        }

        #pdf-container canvas:hover {
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }

        #text-layer {
            position: absolute;
            top: 0;
            left: 0;
            overflow: visible;
            pointer-events: auto;
            transform-origin: 0 0;
            background: rgba(255, 255, 255, 0.01);
        }

        #text-layer span {
            pointer-events: all;
            position: absolute;
            white-space: pre;
            color: transparent;
            background: transparent;
            transform-origin: 0 0;
            user-select: text;
            /* ✅ Allow text selection */
        }

        #text-layer span::selection {
            background: rgba(0, 120, 215, 0.3);
            color: transparent;
        }

        .text-annotation {
            pointer-events: none;
            z-index: 1000;
        }

        #thumbnail-container {
            width: 245px;
            background-color: #ffffff;
            padding: 20px;
            z-index: 100;
            height: 78vh;
            overflow: auto;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            position: relative;
        }

        #thumbnails {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 4px;
        }

        #thumbnails canvas {
            margin-bottom: 0;
            cursor: pointer;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        #thumbnails canvas:hover {
            border-color: #4a90e2;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(74, 144, 226, 0.15);
        }

        /* Thumbnail page number indicator */
        #thumbnails .thumbnail-wrapper {
            position: relative;
            width: fit-content;
        }

        #thumbnails .page-number {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }

        #thumbnails .thumbnail-wrapper:hover .page-number {
            opacity: 1;
        }

        /* Scrollbar styling */
        #thumbnail-container::-webkit-scrollbar {
            width: 6px;
        }

        #thumbnail-container::-webkit-scrollbar-track {
            background: #f5f5f5;
            border-radius: 3px;
        }

        #thumbnail-container::-webkit-scrollbar-thumb {
            background: #dadada;
            border-radius: 3px;
            transition: background-color 0.2s ease;
        }

        #thumbnail-container::-webkit-scrollbar-thumb:hover {
            background: #b0b0b0;
        }

        /* Active thumbnail styling */
        #thumbnails .thumbnail-active {
            border-color: #4a90e2 !important;
            transform: scale(1.02);
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2),
                0 8px 16px rgba(74, 144, 226, 0.15);
            z-index: 1;
        }

        /* Loading skeleton animation */
        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }

            100% {
                background-position: 200% 0;
            }
        }

        .thumbnail-loading {
            background: linear-gradient(90deg,
                    #f0f0f0 25%,
                    #f8f8f8 50%,
                    #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        /* Fullscreen styles */
        #pdf-container:fullscreen,
        #pdf-container:-webkit-full-screen,
        #pdf-container:-moz-full-screen,
        #pdf-container:-ms-fullscreen {
            width: 100vw;
            height: 100vh;
            background-color: #f5f5f5;
            padding: 0;
            box-sizing: border-box;
            overflow: auto;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Center content horizontally */
        }

        /* Center content wrapper */
        #pdf-container:fullscreen .pdf-content-wrapper {
            max-width: 1200px;
            /* Adjust based on your needs */
            width: 100%;
            margin: 0 auto;
            padding: 60px 20px 20px;
            /* Added top padding for toolbar */
        }

        /* Toolbar in fullscreen */
        #pdf-container:fullscreen .toolbar,
        #pdf-container:-webkit-full-screen .toolbar,
        #pdf-container:-moz-full-screen .toolbar,
        #pdf-container:-ms-fullscreen .toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            backdrop-filter: blur(10px);
            transition: opacity 0.3s;
            display: flex;
            justify-content: center;
            /* Center toolbar content */
        }

        /* Hide toolbar when not hovering in fullscreen */
        #pdf-container:fullscreen .toolbar {
            opacity: 0;
        }

        #pdf-container:fullscreen:hover .toolbar {
            opacity: 1;
        }

        /* Fullscreen mode content adjustments */
        .fullscreen-mode .pdf-page {
            margin: 8px auto;
            /* Reduced margin between pages */
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            background: white;
            border-radius: 4px;
            max-width: 100%;
            display: block;
        }

        /* Adjust page container in fullscreen */
        .fullscreen-mode .page-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            /* Small gap between pages */
            width: 100%;
            max-width: 1000px;
            /* Adjust based on your needs */
            margin: 0 auto;
        }

        /* Text layer adjustments */
        .fullscreen-mode #text-layer {
            margin: 8px auto;
            max-width: 100%;
        }

        /* Fullscreen button styles */
        .fullscreen-btn {
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #ddd;
            background: white;
        }

        .fullscreen-btn:hover {
            background-color: #f8f8f8 !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .fullscreen-btn:active {
            transform: translateY(0);
        }

        /* Keyboard shortcut hint */
        [data-shortcut]::after {
            content: attr(data-shortcut);
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            opacity: 0;
            transition: all 0.3s;
        }

        [data-shortcut]:hover::after {
            opacity: 1;
            bottom: -25px;
        }

        /* Smooth transitions */
        .fullscreen-mode {
            transition: all 0.3s ease-in-out;
        }

        /* Scrollbar styling for fullscreen */
        #pdf-container:fullscreen::-webkit-scrollbar {
            width: 8px;
        }

        #pdf-container:fullscreen::-webkit-scrollbar-track {
            background: transparent;
        }

        #pdf-container:fullscreen::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        #pdf-container:fullscreen::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        .bgPDFViewer {
            background-color: #e0e0e0;
        }

        .annotation-item.selected {
            background-color: #d3e0ea;
            border: 2px solid #4a90e2;
            cursor: pointer;
        }

        .annotation-item:hover {
            background-color: #f0f4f8;
        }

        .btn-default:hover {
            background-color: #f0f0f0;
            /* Example hover effect */
            cursor: pointer;
        }

        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
        }

        .toast {
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 4px;
            margin: 8px;
            font-size: 14px;
            animation: slideIn 0.3s ease-out;
            transition: opacity 0.3s ease-out;
        }

        .toast.fade-out {
            opacity: 0;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Optional: Add keyboard shortcut hints to buttons */
        [data-shortcut]::after {
            content: attr(data-shortcut);
            margin-left: 8px;
            font-size: 0.8em;
            color: #666;
            padding: 2px 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }


        /* .btn.active {
    background-color: #007bff !important; /* Highlight active button */
        /* color: white !important; */
        /* } */
    </style>
</head>

<body class="hold-transition sidebar-collapse layout-footer-fixed">
    <div class="wrapper">

        <!-- Navbar -->
        <nav class="main-header navbar navbar-expand navbar-white navbar-light text-sm">
            <!-- Left navbar links -->
            <ul class="navbar-nav">

                <li class="nav-item">
                    <a href="" class=""><img src="../assets/img/ann-Gray-logo.png" alt="img" height="40"></a>
                </li>

            </ul>

            <!-- Right navbar links -->
            <ul class="navbar-nav ml-auto">

                <li class="nav-item">
                    <a class="nav-link" data-widget="fullscreen" href="#" role="button">
                        <i class="fas fa-expand-arrows-alt"></i>
                    </a>
                </li>

            </ul>
        </nav>
        
        <!-- /.navbar -->

        <!-- Main Sidebar Container -->
        <aside class="main-sidebar elevation-4 sidebar-light-navy">
            <!-- Brand Logo -->
            <a href="" class="brand-link">
                <img src="../assets/img/logo.png" alt="Logo" class="brand-image img-circle elevation-3"
                    style="opacity: .8">
                <span class="brand-text font-weight-light">PDF</span>
            </a>

            <!-- Sidebar -->
            <div class="sidebar">
                <!-- Sidebar user panel (optional) -->
                <div class="user-panel mt-3 pb-3 mb-3 d-flex">
                    <div class="image">
                        <img src="../assets/img/user2-160x160.jpg" class="img-circle elevation-2" alt="User Image">
                    </div>
                    <div class="info">
                        <a href="#" class="d-block">Vaibhav Barsagade</a>
                    </div>
                </div>



                <!-- Sidebar Menu -->
                <nav class="mt-2">
                    <ul class="nav nav-pills nav-sidebar flex-column nav-compact" data-widget="treeview" role="menu"
                        data-accordion="false">
                        <!-- Add icons to the links using the .nav-icon class
                         with font-awesome or any other icon font library -->

                        <li class="nav-item menu-open">
                            <a href="#" class="nav-link active">
                                <i class="nav-icon fas fa-tachometer-alt"></i>
                                <p>
                                    Admin Menu
                                    <i class="right fas fa-angle-left"></i>
                                </p>
                            </a>
                            <ul class="nav nav-treeview">
                                <li class="nav-item">
                                    <a href="index.html" class="nav-link active">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>Create Employee</p>
                                    </a>
                                </li>
                                <li class="nav-item">
                                    <a href="starter.html" class="nav-link">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>View Employee</p>
                                    </a>
                                </li>
                                <li class="nav-item">
                                    <a href="" class="nav-link">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>Follow Up Check</p>
                                    </a>
                                </li>
                            </ul>
                        </li>

                        <li class="nav-item">
                            <a href="#" class="nav-link">
                                <i class="nav-icon fas fa-chart-pie"></i>
                                <p>
                                    Road Services
                                    <i class="right fas fa-angle-left"></i>
                                </p>
                            </a>
                            <ul class="nav nav-treeview">
                                <li class="nav-item">
                                    <a href="" class="nav-link">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>HighTea</p>
                                    </a>
                                </li>
                                <li class="nav-item">
                                    <a href="" class="nav-link">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>SideHigh</p>
                                    </a>
                                </li>
                                <li class="nav-item">
                                    <a href="" class="nav-link">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>Inline</p>
                                    </a>
                                </li>
                                <li class="nav-item">
                                    <a href="" class="nav-link">
                                        <i class="far fa-circle nav-icon"></i>
                                        <p>uPlot</p>
                                    </a>
                                </li>
                            </ul>
                        </li>

                    </ul>
                </nav>
                <!-- /.sidebar-menu -->
            </div>
            <!-- /.sidebar -->
        </aside>

        <!-- Content Wrapper. Contains page content -->
        <div class="content-wrapper">
            <section class="content mt-2">
                <div class="container-fluid">

                    <div class="row">
                        <div class="col-md-12">
                            <div class="card shadow-none mb-1">
                                <div class="card-body p-2">
                                    <div class="row">
                                        <div class="col-lg-2">
                                            <div class="custom-file">
                                                <input type="file" id="file-input" class="custom-file-input"
                                                    accept="application/pdf" />
                                                <label class="custom-file-label" for="customFile">Choose file</label>
                                            </div>
                                        </div>
                                        <div class="col-lg-10">
                                            <div class="btn-group">

                                                <button onclick="toggleThumbnails()" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="ThumbNail!">
                                                    <i class="fas fa-list"></i>
                                                </button>

                                                <button onclick="prevPage()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="ThumbNail!">
                                                    <i class="fas fa-step-backward"></i>
                                                </button>
                                                <button type="button" class="btn btn-default" data-toggle="tooltip"
                                                    data-placement="top" title="ThumbNail!">
                                                    <i class="fas fa-chevron-left"></i>
                                                </button>
                                                <button type="button" class="btn btn-default" data-toggle="tooltip"
                                                    data-placement="top" title="ThumbNail!">
                                                    <i class="fas fa-chevron-right"></i>
                                                </button>
                                                <button onclick="nextPage()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="ThumbNail!">
                                                    <i class="fas fa-step-forward"></i>
                                                </button>
                                                <div id="page-num" class="btn btn-default"
                                                    style="pointer-events: none;">1</div>

                                            </div>
                                            <div class="btn-group">
                                                <button onclick="zoomOut()" id="zoom-out" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="Zoom In">
                                                    <i class="fas fa-search-minus"></i>
                                                </button>
                                                <button type="button" class="btn btn-default">
                                                    <div id="zoom-percent">0</div>
                                                </button>
                                                <button onclick="zoomIn()" id="zoom-in" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="Zoom Out">
                                                    <i class="fas fa-search-plus"></i>
                                                </button>
                                                <button onclick="zoomReset()" id="zoom-reset" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="Zoom Reset">
                                                    <i class="fas fa-sync-alt"></i>
                                                </button>
                                            </div>
                                            <div class="btn-group">
                                                <button onclick="addSquare()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Draw Square">
                                                    <i class="far fa-square"></i>
                                                </button>
                                                <button onclick="addLine()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Draw Line">
                                                    <i class="fas fa-slash"></i>
                                                </button>
                                                <button onclick="addCircle()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Draw Circle">
                                                    <i class="far fa-circle"></i>
                                                </button>
                                                <button onclick="addFreeDraw()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Free Draw">
                                                    <i class="fas fa-edit"></i>
                                                </button>
                                                <button onclick="addCloudAnnotation()" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="Draw Cloud">
                                                    <i class="fas fa-cloud"></i>
                                                </button>
                                                <button onclick="addText()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Add Text">
                                                    <i class="fas fa-text-width"></i>
                                                </button>
                                                <select id="stampSelect" class="">
                                                    <option value="approve">Approve</option>
                                                    <option value="notApprove">Rejected</option>
                                                    <!-- <option value="right">Right</option>
                                                    <option value="wrong">Wrong</option> -->
                                                </select>
                                                <button onclick="addSelectedStamp()" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="Add Stamp">
                                                    <i class="fas fa-stamp"></i>
                                                </button>
                                                <button onclick="openSignatureCanvas()" type="button"
                                                    class="btn btn-default" data-toggle="tooltip" data-placement="top"
                                                    title="Draw Signature">
                                                    <i class="fas fa-signature"></i>
                                                </button>
                                                <button id="highlight" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Add Highlighter">
                                                    <i class="fas fa-highlighter"></i>
                                                </button>
                                                <button id="underline" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Add Underline">
                                                    <i class="fas fa-underline"></i>
                                                </button>
                                                <button id="strikeout" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top"
                                                    title="Add strikethrough">
                                                    <i class="fas fa-strikethrough"></i>
                                                </button>
                                                <button onclick="toggleFullScreen()" type="button"
                                                    class="btn btn-default fullscreen-btn" data-toggle="tooltip"
                                                    data-placement="top" title="Enter full-screen (F11)"
                                                    data-shortcut="F11">
                                                    <i class="fas fa-expand"></i>
                                                </button>
                                            </div>
                                            <div class="btn-group">
                                                <button onclick="undo()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Undo">
                                                    <i class="fas fa-undo"></i>
                                                </button>
                                                <button onclick="redo()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Redu">
                                                    <i class="fas fa-redo"></i>
                                                </button>
                                                <!-- <button id="delete-annotation-btn" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Delete">
                                                    <i class="fas fa-trash"></i>
                                                </button> -->

                                            </div>
                                            <div class="btn-group">
                                                <!-- <button type="button" class="btn btn-default" data-toggle="tooltip"
                                                    data-placement="top" title="Expand">
                                                    <i class="fas fa-expand"></i>
                                                </button> -->
                                            </div>
                                            <div class="btn-group">
                                                <!-- <button type="button" class="btn btn-default" data-toggle="tooltip"
                                                    data-placement="top" title="Print">
                                                    <i class="fas fa-print"></i>
                                                </button> -->
                                                <button onclick="save()" type="button" class="btn btn-default"
                                                    data-toggle="tooltip" data-placement="top" title="Save PDF">
                                                    <i class="fas fa-download"></i>
                                                </button>
                                            </div>
                                            <div class="btn-group">
                                                <button onclick="fitToWidth()" title="Fit to Width" type="button"
                                                    class="btn btn-default">
                                                    <i class="fas fa-arrows-alt-h"></i>
                                                </button>
                                                <button onclick="fitToHeight()" title="Fit to Height" type="button"
                                                    class="btn btn-default">
                                                    <i class="fas fa-arrows-alt-v"></i>
                                                </button>
                                                <div class="btn-group">
                                                    <button id="select-mode" type="button" class="btn btn-default"
                                                        data-toggle="tooltip" title="Select Mode">
                                                        <i class="fas fa-mouse-pointer"></i>
                                                    </button>
                                                    <button id="pan-mode" type="button" class="btn btn-default"
                                                        data-toggle="tooltip" title="Pan Mode">
                                                        <i class="fas fa-hand-paper"></i>
                                                    </button>
                                                </div>
                                                <button id="toggleSidebarBtn" title="Comments" type="button"
                                                    class="btn btn-default">
                                                    <i class="fas fa-comments"></i>
                                                </button>
                                                
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="card bgPDFViewer shadow-none">
                                <div class="card-body p-0">

                                    <div class="row">
                                        <div class="col-lg-3">
                                            <div class="card-body p-1">
                                                <div id="thumbnail-container" style="display: none;">
                                                    <div id="thumbnails"></div>
                                                </div>

                                                <div id="thumbnail-container" style="display: none;">
                                                    <div id="thumbnails"></div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="col-lg-9">
                                            <div class="card-body p-1">
                                                <div id="pdf-container">
                                                    <canvas id="pdf-canvas"></canvas>
                                                    <canvas id="fabric-canvas"></canvas>
                                                    <canvas id="annotation-canvas"></canvas>
                                                    <!-- Canvas for annotations -->
                                                    <div id="text-layer"></div>
                                                </div>

                                                <!-- <div class="row ">
                                                    <div class="col-lg-12">
                                                        <input type="checkbox" id="toggle-selection"> Enable Annotation
                                                        Selection <span>Page: <span id="page-num">1</span> / <span
                                                                id="page-count">0</span></span>
                                                    </div>
                                                </div> -->

                                            </div>

                                        </div>
                                    </div>

                                </div>
                            </div>
                        </div>

                    </div>

                </div>

            </section>
            <section>
                <div id="annotationModal" class="modal">
                    <div class="modal-content">
                        <span class="close-button">&times;</span>
                        <h2>Add Annotation Details</h2>
                        <form id="annotationForm">
                            <label for="content">Content:</label>
                            <textarea id="content" name="content" placeholder="Enter content" required></textarea>
                            <button type="submit">Save</button>
                        </form>
                    </div>
                </div>
            </section>

            <div id="sidebar"
                style="display: none; width: 250px; position: absolute; top: 127; right: 39; background-color: #f1f1f1; padding: 15px; height: 100%; overflow-y: auto; box-shadow: -2px 0px 5px rgba(0, 0, 0, 0.2);">
                <h2>Annotations</h2>
                <div id="annotationList"></div>
            </div>

        </div>
        <!-- /.content-wrapper -->
        <footer class="main-footer text-sm">
            <strong>&copy; 2023 <a href="">PDF System</a>.</strong>
            All rights reserved.
            <div class="float-right d-none d-sm-inline-block">
                <b>Version</b> 3.2.0
            </div>
        </footer>

        <!-- Control Sidebar -->
        <aside class="control-sidebar control-sidebar-dark">
            <div class="p-3 control-sidebar-content">

            </div>
        </aside>
        <!-- /.control-sidebar -->
    </div>

    
    <!-- ./wrapper -->


    <script>
        let pdfDoc = null;
        let pageNum = 1;
        const pdfCanvas = document.getElementById('pdf-canvas');
        const fabricCanvasElement = document.getElementById('fabric-canvas');
        const textLayer = document.getElementById('text-layer');
        const pdfContext = pdfCanvas.getContext('2d');
        const fabricCanvas = new fabric.Canvas(fabricCanvasElement, {
            selection: true,
            selectionColor: 'rgba(0, 0, 0, 0)',
            selectionBorderColor: 'rgba(0, 0, 0, 0)',
            selectionLineWidth: 0
        });
        let redoStack = [];
        let annotationsByPage = {};
        let isDrawing = false;
        let startX, startY;
        let currentAnnotation = null;
        let isFreeDrawEnabled = false;
        const textLayerAdjustments = {};
        const thumbnailsContainer = document.getElementById("thumbnails");
        const thumbnailContainer = document.getElementById("thumbnail-container");
        let currentPageNum = 1;

        let isPanning = false;
        let scrollLeft, scrollTop;
        let velocityX = 0, velocityY = 0;
        let momentumActive = false;

        document.getElementById('select-mode').addEventListener('click', enableSelectMode);
        document.getElementById('pan-mode').addEventListener('click', enablePanMode);

        const pdfContainer = document.getElementById('pdf-container');
        const handCursor = document.createElement("div");
        handCursor.classList.add("hand-cursor");
        document.body.appendChild(handCursor);

        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                cancelAnnotation();
            }
        });

        function cancelAnnotation() {
            console.log("ESC pressed! Switching to Select Mode.");
            window.getSelection().removeAllRanges();
            annotationMode = null;
            
            fabricCanvas.isDrawingMode = false;
            isDrawing = false;
            enableSelectMode();
        }

        function enableSelectMode() {
            showToast('Select mode enabled');
            enableTextLayer();
            isPanning = false;
            fabricCanvas.selection = true;
            fabricCanvas.forEachObject(obj => obj.selectable = true);
            fabricCanvas.defaultCursor = 'default';
            console.log("Entered Select Mode");
            pdfContainer.style.cursor = 'default';
            handCursor.style.display = "none";
        }

        function enablePanMode() {
            showToast('Pan mode enabled');
            disableTextLayer();
            isPanning = true;

            Object.values(fabricCanvases).forEach(canvas => {
                disableTextLayer();
                canvas.selection = false;
                canvas.forEachObject(obj => obj.selectable = false);
                canvas.defaultCursor = 'grab';
            });

            pdfContainer.style.cursor = 'grab';
            document.querySelectorAll('.pdf-canvas, .fabric-canvas, .annotation-canvas').forEach(canvas => {
                canvas.style.cursor = 'grab';
            });

            console.log("Entered Pan Mode");
        }




        pdfContainer.addEventListener('mousedown', (e) => {

            if (!isPanning) return;

            startX = e.clientX;
            startY = e.clientY;
            scrollLeft = pdfContainer.scrollLeft;
            scrollTop = pdfContainer.scrollTop;
            pdfContainer.style.cursor = 'grabbing';
            document.querySelectorAll('.pdf-canvas, .fabric-canvas, .annotation-canvas').forEach(canvas => {
                canvas.style.cursor = 'grabbing';
            });

            Object.values(fabricCanvases).forEach(canvas => {
                canvas.defaultCursor = 'grabbing';
            });

            let lastX = startX;
            let lastY = startY;
            velocityX = 0;
            velocityY = 0;
            momentumActive = false;

            function onMouseMove(e) {

                if (!isPanning) return;

                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;

                velocityX = dx * 0.7;
                velocityY = dy * 0.7;

                pdfContainer.scrollLeft -= dx;
                pdfContainer.scrollTop -= dy;

                lastX = e.clientX;
                lastY = e.clientY;
            }

            function onMouseUp() {

                pdfContainer.style.cursor = 'grab';
                document.querySelectorAll('.pdf-canvas, .fabric-canvas, .annotation-canvas').forEach(canvas => {
                    canvas.style.cursor = 'grab';
                });
                Object.values(fabricCanvases).forEach(canvas => {
                    canvas.defaultCursor = 'grab';
                });
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                applyMomentum();
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        function applyMomentum() {

            if (momentumActive) return;
            momentumActive = true;

            function step() {
                if (Math.abs(velocityX) < 0.1 && Math.abs(velocityY) < 0.1) {
                    momentumActive = false;
                    return;
                }

                pdfContainer.scrollLeft -= velocityX;
                pdfContainer.scrollTop -= velocityY;

                velocityX *= 0.95;
                velocityY *= 0.95;

                requestAnimationFrame(step);
            }

            requestAnimationFrame(step);
        }


        fabricCanvas.on('mouse:down', function () {
            if (isDrawing) {
                document.addEventListener('keydown', function (event) {
                    if (event.key === 'Escape') {
                        cancelAnnotation();
                    }
                });
            }
        });


        const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
        const sidebar = document.getElementById('sidebar');

        toggleSidebarBtn.addEventListener('click', () => {
            if (sidebar.style.display === 'none' || sidebar.style.display === '') {
                sidebar.style.display = 'block';
            } else {
                sidebar.style.display = 'none';
            }
        });

        function openAnnotationModal(annotation) {
            if (!annotation) {
                console.error("Invalid annotation passed to openAnnotationModal.");
                return;
            }
            currentAnnotation = annotation;

            // document.getElementById('title').value = annotation.title || '';
            // document.getElementById('subject').value = annotation.subject || '';
            // document.getElementById('content').value = annotation.content || '';

            document.getElementById('content').value = '';


            console.log("Opening modal with annotation:", annotation);

            document.getElementById('annotationModal').style.display = "block";
        }

        function closeAnnotationModal() {
            // Send default content when modal is closed without saving
            // if (currentAnnotation) {
            //     const defaultContent = `This is a ${currentAnnotation.type} annotation`;
            //     currentAnnotation.content = defaultContent;

            //     const sessionCommentId = generateGuid();
            //     const backendData = {
            //         DocumentId: sessionDocumentId,
            //         CommentList: [{
            //             UserId: sessionUserId,
            //             Comments: defaultContent,
            //             Remark: "Empty",
            //             CommentDate: new Date().toISOString(),
            //             AnnotationType: currentAnnotation.type,
            //             PageNumber: currentAnnotation.page.toString(),
            //             Id: sessionCommentId,
            //             UserName: "Anurag Sable"
            //         }]
            //     };

            //     console.log("Sending default annotation to backend:", backendData);
            //     sendAnnotationToBackend(backendData);
                updateSidebar(currentAnnotation);
            // }

            document.getElementById('annotationModal').style.display = "none";
            currentAnnotation = null;
        }

        function saveAnnotationDetails(event) {
            event.preventDefault();

            if (!currentAnnotation) {
                console.error("currentAnnotation is null or undefined!");
                return;
            }

            // const title = document.getElementById('title').value;
            // const subject = document.getElementById('subject').value;
            const content = document.getElementById('content').value;

            console.log("Content:", content);

            const finalContent = content.trim() || `This is a ${currentAnnotation.type} annotation`;
            currentAnnotation.content = finalContent;

            // currentAnnotation.title = title;
            // currentAnnotation.subject = subject;
            currentAnnotation.content = content;

            console.log("Updated Annotation:", currentAnnotation);

            //For Send Annotation to Backend directly after adding annotations 

            // if (!currentAnnotation.id) {
            //     console.error("Annotation ID is missing!");
            //     return;
            // }
            // const sessionCommentId = generateGuid();
            // const backendData = {
            //     DocumentId: sessionDocumentId,
            //     CommentList: [{
            //         UserId: sessionUserId,
            //         Comments: content,
            //         Remark: "Empty",
            //         CommentDate: new Date().toISOString(),
            //         AnnotationType: currentAnnotation.type,
            //         PageNumber: currentAnnotation.page.toString(),
            //         Id: sessionCommentId,
            //         UserName: "Anurag Sable"
            //     }]
            // };

            // console.log("Sending updated annotation to backend:", backendData);
            // sendAnnotationToBackend(backendData);

                        //For Send Annotation to Backend directly after adding annotations 


            updateSidebar(currentAnnotation);
            document.getElementById('annotationModal').style.display = "none";
            currentAnnotation = null;
        }

        document.querySelector('.close-button').addEventListener('click', function (event) {
            event.preventDefault();
            closeAnnotationModal();
        });
        document.getElementById('annotationForm').addEventListener('submit', saveAnnotationDetails);

        function updateSidebar(annotation) {
            console.log("Updating Sidebar with Annotation:", annotation);

            if (!annotation || !annotation.id) {
                console.error("Invalid annotation passed to updateSidebar.");
                return;
            }

            const annotationList = document.getElementById("annotationList");
            let annotationItem = document.getElementById(`annotation-${annotation.id}`);

            if (!annotationItem) {
                annotationItem = document.createElement("div");
                annotationItem.id = `annotation-${annotation.id}`;
                annotationItem.classList.add("annotation-item");
                annotationList.appendChild(annotationItem);

                // annotationItem.addEventListener("click", function(event) {
                //     if (!event.target.matches('.btn-delete, .btn-edit')) {
                //         if (annotation.type === 'highlight' || annotation.type === 'underline' || annotation.type === 'strikeout') {
                //             selectTextAnnotation(annotation);
                //         } else {
                //             selectAnnotation(annotation);
                //         }
                //     }
                // });
            }
            const timestamp = new Date().toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });

            annotationItem.innerHTML = `
        <div class="annotation-box">
            <div class="annotation-header">
                <span class="annotation-type">${annotation.type}</span>
                <span class="annotation-timestamp">${timestamp}</span>
            </div>
            <div class="annotation-content">
                ${annotation.content || 'No content added'}
            </div>
            <div class="annotation-actions">
                <button class="btn-action btn-edit" data-id="${annotation.id}">
                    <i class="fas fa-edit"></i>
                    Edit
                </button>
                <button class="btn-action btn-delete" data-id="${annotation.id}">
                    <i class="fas fa-trash-alt"></i>
                    Delete
                </button>
            </div>
        </div>
    `;

            if (annotationList.children.length === 0) {
                annotationList.innerHTML = `
            <div class="annotation-empty">
                <i class="fas fa-comment-alt fa-2x mb-3"></i>
                <p>No annotations yet</p>
                <p class="text-sm">Start adding annotations to your document</p>
            </div>
        `;
            }

            const deleteBtn = annotationItem.querySelector('.btn-delete');
            const editBtn = annotationItem.querySelector('.btn-edit');

            deleteBtn.addEventListener('click', function (event) {
                event.stopPropagation();
                deleteAnnotations(annotation.id);
            });

            editBtn.addEventListener('click', function (event) {
                event.stopPropagation();
                openAnnotationModal(annotation);
            });
        }

//         function updateSidebar(annotationInput) {
//     console.log("Updating Sidebar with:", annotationInput);

//     // Handle both single annotation and array of annotations
//     const annotations = Array.isArray(annotationInput) ? annotationInput : [annotationInput];
//     const annotationList = document.getElementById("annotationList");

//     // Clear existing annotations if passing an array
//     if (Array.isArray(annotationInput)) {
//         annotationList.innerHTML = '';
//     }

//     // Handle empty annotations list
//     if (annotations.length === 0) {
//         annotationList.innerHTML = `
//             <div class="annotation-empty">
//                 <i class="fas fa-comment-alt fa-2x mb-3"></i>
//                 <p>No annotations yet</p>
//                 <p class="text-sm">Start adding annotations to your document</p>
//             </div>
//         `;
//         return;
//     }

//     // Process each annotation
//     annotations.forEach(annotation => {
//         if (!annotation || !annotation.id) {
//             console.error("Invalid annotation:", annotation);
//             return;
//         }

//         let annotationItem = document.getElementById(`annotation-${annotation.id}`);

//         // Create new item if it doesn't exist
//         if (!annotationItem) {
//             annotationItem = document.createElement("div");
//             annotationItem.id = `annotation-${annotation.id}`;
//             annotationItem.classList.add("annotation-item");
//             annotationList.appendChild(annotationItem);
//         }

//         const timestamp = new Date(annotation.createdAt || new Date()).toLocaleString('en-US', {
//             month: 'short',
//             day: 'numeric',
//             hour: '2-digit',
//             minute: '2-digit'
//         });

//         annotationItem.innerHTML = `
//             <div class="annotation-box">
//                 <div class="annotation-header">
//                     <span class="annotation-type">${annotation.type}</span>
//                     <span class="annotation-timestamp">${timestamp}</span>
//                 </div>
//                 <div class="annotation-content">
//                     ${annotation.content || 'No content added'}
//                 </div>
//                 <div class="annotation-actions">
//                     <button class="btn-action btn-edit" data-id="${annotation.id}">
//                         <i class="fas fa-edit"></i>
//                         Edit
//                     </button>
//                     <button class="btn-action btn-delete" data-id="${annotation.id}">
//                         <i class="fas fa-trash-alt"></i>
//                         Delete
//                     </button>
//                 </div>
//             </div>
//         `;

//         // Add event listeners
//         const deleteBtn = annotationItem.querySelector('.btn-delete');
//         const editBtn = annotationItem.querySelector('.btn-edit');

//         deleteBtn.addEventListener('click', function(event) {
//             event.stopPropagation();
//             deleteAnnotations(annotation.id);
//         });

//         editBtn.addEventListener('click', function(event) {
//             event.stopPropagation();
//             openAnnotationModal(annotation);
//         });
//     });
// }


function updateSidebar(annotationInput) {
    console.log("Updating Sidebar with:", annotationInput);
    
    try {
        // Get the annotation list element
        const annotationList = document.getElementById("annotationList");
        if (!annotationList) {
            console.error("Annotation list element not found in the DOM");
            return;
        }
        
        // Handle both single annotation and array of annotations
        const annotations = Array.isArray(annotationInput) ? annotationInput : [annotationInput];
        
        // Clear existing annotations if passing an array
        if (Array.isArray(annotationInput)) {
            annotationList.innerHTML = '';
        }
        
        // Handle empty annotations list
        if (annotations.length === 0) {
            annotationList.innerHTML = `
                <div class="annotation-empty">
                    <i class="fas fa-comment-alt fa-2x mb-3"></i>
                    <p>No annotations yet</p>
                    <p class="text-sm">Start adding annotations to your document</p>
                </div>
            `;
            return;
        }
        
        // Process each annotation
        annotations.forEach(annotation => {
            if (!annotation) {
                console.error("Null annotation found in list");
                return;
            }
            
            if (!annotation.id) {
                console.error("Annotation without ID found:", annotation);
                return;
            }
            
            let annotationItem = document.getElementById(`annotation-${annotation.id}`);
            
            // Create new item if it doesn't exist
            if (!annotationItem) {
                annotationItem = document.createElement("div");
                annotationItem.id = `annotation-${annotation.id}`;
                annotationItem.classList.add("annotation-item");
                annotationList.appendChild(annotationItem);
            }
            
            // Generate a safe timestamp
            let timestamp;
            try {
                timestamp = new Date(annotation.createdAt || new Date()).toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                timestamp = new Date().toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }
            
            // Create sanitized content
            const content = annotation.content || annotation.text || 'No content added';
            const sanitizedContent = content.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            
            // Update item content
            annotationItem.innerHTML = `
                <div class="annotation-box">
                    <div class="annotation-header">
                        <span class="annotation-type">${annotation.type || 'unknown'}</span>
                        <span class="annotation-timestamp">${timestamp}</span>
                    </div>
                    <div class="annotation-content">
                        ${sanitizedContent}
                    </div>
                    <div class="annotation-actions">
                        <button class="btn-action btn-edit" data-id="${annotation.id}">
                            <i class="fas fa-edit"></i>
                            Edit
                        </button>
                        <button class="btn-action btn-delete" data-id="${annotation.id}">
                            <i class="fas fa-trash-alt"></i>
                            Delete
                        </button>
                    </div>
                </div>
            `;
            
            // Safely add event listeners
            try {
                const deleteBtn = annotationItem.querySelector('.btn-delete');
                if (deleteBtn) {
                    // Remove any existing listeners to prevent duplicates
                    const newDeleteBtn = deleteBtn.cloneNode(true);
                    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
                    
                    newDeleteBtn.addEventListener('click', function(event) {
                        event.stopPropagation();
                        deleteAnnotations(annotation.id);
                    });
                }
                
                const editBtn = annotationItem.querySelector('.btn-edit');
                if (editBtn) {
                    // Remove any existing listeners to prevent duplicates
                    const newEditBtn = editBtn.cloneNode(true);
                    editBtn.parentNode.replaceChild(newEditBtn, editBtn);
                    
                    newEditBtn.addEventListener('click', function(event) {
                        event.stopPropagation();
                        openAnnotationModal(annotation);
                    });
                }
            } catch (error) {
                console.error("Error setting up annotation item event listeners:", error);
            }
        });
    } catch (error) {
        console.error("Error updating sidebar:", error);
        // Create a minimal fallback display if the main update fails
        try {
            const annotationList = document.getElementById("annotationList");
            if (annotationList) {
                annotationList.innerHTML = `
                    <div class="annotation-error">
                        <p>Error displaying annotations</p>
                        <p class="text-sm">Please refresh the page and try again</p>
                    </div>
                `;
            }
        } catch (e) {
            // Last resort
            console.error("Fatal error updating sidebar:", e);
        }
    }
}



// // Function for deleting annotations
// function deleteAnnotation(id) {
//     try {
//         // Confirm before deleting
//         if (confirm("Are you sure you want to delete this annotation?")) {
//             // Find the annotation in the array
//             const index = annotations.findIndex(a => a.id === id);
//             if (index !== -1) {
//                 // Remove from main array
//                 const annotation = annotations.splice(index, 1)[0];
                
//                 // Remove from page-specific array
//                 const pageNum = annotation.page.toString();
//                 if (annotationsByPage[pageNum]) {
//                     const pageIndex = annotationsByPage[pageNum].findIndex(a => a.id === id);
//                     if (pageIndex !== -1) {
//                         annotationsByPage[pageNum].splice(pageIndex, 1);
//                     }
//                 }
                
//                 // Remove from DOM
//                 const element = document.getElementById(`annotation-${id}`);
//                 if (element) {
//                     element.remove();
//                 }
                
//                 // Re-render annotations for current page
//                 renderAnnotationsForPage(currentPageNum, annotations);
                
//                 // Update sidebar if needed
//                 if (annotations.length === 0) {
//                     updateSidebar([]);
//                 }
                
//                 showToast("Annotation deleted successfully");
//             }
//         }
//     } catch (error) {
//         console.error("Error deleting annotation:", error);
//         showToast("Error deleting annotation");
//     }
// }

        function deleteAnnotations(annotationId) {
            console.log("Deleting Annotation with ID:", annotationId);

            const annotationItem = document.getElementById(`annotation-${annotationId}`);
            if (annotationItem) {
                annotationItem.remove();
            }

            const annotationOnCanvas = fabricCanvas.getObjects().find(obj => obj.id === annotationId);
            if (annotationOnCanvas) {
                if (annotationOnCanvas.type === "image") {
                    console.log("Removing image annotation (signature/stamp):", annotationId);
                }

                fabricCanvas.remove(annotationOnCanvas);
                fabricCanvas.renderAll();
            } else {
                console.log("Annotation not found on canvas:", annotationId);
            }


            for (let page in annotationsByPage) {
                const index = annotationsByPage[page].findIndex(anno => anno.id === annotationId);
                if (index !== -1) {
                    annotationsByPage[page].splice(index, 1);
                    console.log("Annotation removed from annotationsByPage for page:", page);
                }
            }

            const index = annotations.findIndex(anno => anno.id === annotationId);
            if (index !== -1) {
                annotations.splice(index, 1);
                console.log("Annotation removed from array:", annotationId);
            } else {
                console.log("Annotation not found in annotations array:", annotationId);
            }

            renderAllPages();

            // console.log("Annotation deleted:", annotation);
            console.log("Annotation deleted:", annotationId);
            showToast('Annotation deleted');

        }


        function selectAnnotation(annotation) {
            console.log("Attempting to select annotation:", annotation);  //1 

            const pageNum = annotation.page || 1;
            const canvas = fabricCanvases[pageNum];

            if (!canvas) {
                console.error("No canvas found for page:", pageNum);
                return;
            }

            console.log(`Looking for annotation on page ${pageNum}, canvas objects:`, canvas.getObjects()); //2

            let annotationOnCanvas = canvas.getObjects().find(obj => {
                console.log("Checking object:", obj.id, obj.type, "against:", annotation.id, annotation.type);//3 

                if (obj.id === annotation.id) return true;

                switch (annotation.type) {
                    case 'square':
                        return obj.type === 'rect' && obj.left === annotation.x1 && obj.top === annotation.y1;
                    case 'circle':
                        return obj.type === 'circle' && obj.left === annotation.x1 && obj.top === annotation.y1;
                    case 'line':
                        return obj.type === 'line' && obj.left === annotation.x1 && obj.top === annotation.y1;
                    case 'text':
                        return obj.type === 'textbox' && obj.left === annotation.x1 && obj.top === annotation.y1;
                    case 'stamp':
                    case 'signature':
                        return obj.type === 'image' && obj.left === annotation.x1 && obj.top === annotation.y1;
                    case 'freeDraw':
                    case 'cloud':
                        return obj.type === 'path' &&
                            ((obj.path && annotation.path && obj.path.toString() === annotation.path.toString()) ||
                                (obj.left === annotation.x1 && obj.top === annotation.y1));
                    default:
                        return false;
                }
            });

            if (annotationOnCanvas) {
                console.log("Found annotation on canvas:", annotationOnCanvas); // 4 

                if (!annotationOnCanvas.originalProperties) {
                    annotationOnCanvas.originalProperties = {
                        stroke: annotationOnCanvas.stroke,
                        strokeWidth: annotationOnCanvas.strokeWidth,
                        fill: annotationOnCanvas.fill,
                        opacity: annotationOnCanvas.opacity
                    };
                }

                if (annotationOnCanvas.selected) {

                    console.log("Annotation is already selected, deselecting it");
                    annotationOnCanvas.set({
                        selected: false,
                        stroke: annotationOnCanvas.originalProperties.stroke,
                        strokeWidth: annotationOnCanvas.originalProperties.strokeWidth,
                        fill: annotationOnCanvas.originalProperties.fill,
                        opacity: annotationOnCanvas.originalProperties.opacity
                    });
                    canvas.discardActiveObject();
                    console.log("Deselected annotation on canvas");
                    updateSidebarSelection(null);
                } else {

                    console.log("Annotation is not selected, selecting it");//5




                    Object.values(fabricCanvases).forEach(c => {
                        c.getObjects().forEach(obj => {
                            if (obj.originalProperties) {
                                obj.set({
                                    selected: false,
                                    stroke: obj.originalProperties.stroke,
                                    strokeWidth: obj.originalProperties.strokeWidth,
                                    fill: obj.originalProperties.fill,
                                    opacity: obj.originalProperties.opacity
                                });
                            }
                        });
                        c.renderAll();
                    });

                    annotationOnCanvas.set({
                        selected: true,
                        strokeWidth: 5,
                        stroke: '#4a90e2',
                        opacity: 0.8
                    });
                    console.log("Applied new selection properties to annotation on canvas"); //6

                    canvas.setActiveObject(annotationOnCanvas);
                    updateSidebarSelection(annotation.id);

                }

                const pageWrapper = document.querySelector(`[data-page-number="${pageNum}"]`);
                if (pageWrapper) {
                    console.log("Scrolling to page:", pageNum); //7
                    pageWrapper.scrollIntoView({ behavior: 'smooth' });
                }

                canvas.renderAll();
                // updateSidebarSelection(annotation.id);
            } else {
                console.log("No fabric annotation found, trying text annotation");
                selectTextAnnotation(annotation);
            }
        }

        function selectTextAnnotation(annotation) {
            annotation.selected = !annotation.selected;

            Object.keys(fabricCanvases).forEach(pageNum => {
                const pageWrapper = document.querySelector(`[data-page-number="${pageNum}"]`);
                const annotationCanvas = pageWrapper?.querySelector('.annotation-canvas');
                if (annotationCanvas) {
                    const ctx = annotationCanvas.getContext('2d');
                    ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

                    const pageAnnotations = annotationsByPage[pageNum] || [];
                    pageAnnotations.forEach(anno => {
                        if (anno.lineAnnotations) {
                            anno.lineAnnotations.forEach(rect => {
                                switch (anno.type) {
                                    case 'highlight':
                                        ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                                        ctx.fillRect(
                                            rect.left * currentScale,
                                            rect.top * currentScale,
                                            rect.width * currentScale,
                                            rect.height * currentScale
                                        );
                                        break;
                                    case 'underline':
                                    case 'strikeout':
                                        ctx.strokeStyle = 'red';
                                        ctx.lineWidth = 1;
                                        const y = anno.type === 'underline'
                                            ? rect.top * currentScale + (rect.height * currentScale) - 3
                                            : rect.top * currentScale + (rect.height * currentScale / 2) - 4;
                                        ctx.beginPath();
                                        ctx.moveTo(rect.left * currentScale, y);
                                        ctx.lineTo((rect.left + rect.width) * currentScale, y);
                                        ctx.stroke();
                                        break;
                                }

                                if (anno.id === annotation.id && annotation.selected) {
                                    ctx.strokeStyle = '#4a90e2';
                                    ctx.lineWidth = 2;
                                    ctx.strokeRect(
                                        rect.left * currentScale,
                                        rect.top * currentScale,
                                        rect.width * currentScale,
                                        rect.height * currentScale
                                    );
                                }
                            });
                        }
                    });
                }
            });

            updateSidebarSelection(annotation.selected ? annotation.id : null);

            if (annotation.selected) {
                const pageWrapper = document.querySelector(`[data-page-number="${annotation.page}"]`);
                if (pageWrapper) {
                    pageWrapper.scrollIntoView({ behavior: 'smooth' });
                }
            }
        }

        document.getElementById('annotationList').addEventListener('click', event => {
            const target = event.target.closest('.annotation-item');
            if (target && !event.target.matches('.btn-delete, .btn-edit')) {
                event.stopPropagation();
                const annotationId = target.id.replace('annotation-', '');
                console.log("🎯 Sidebar click - Looking for annotation with ID:", annotationId);

                let foundAnnotation = null;
                for (const pageNum in annotationsByPage) {
                    console.log(`🔍 Checking page ${pageNum} for annotation`);
                    const annotation = annotationsByPage[pageNum].find(anno => anno.id === annotationId);
                    if (annotation) {
                        foundAnnotation = annotation;
                        console.log("✅ Found annotation in annotationsByPage:", annotation);

                        if (!fabricCanvases[pageNum] || fabricCanvases[pageNum].getObjects().length === 0) {
                            console.log("⚠️ Canvas for page not ready, rendering page:", pageNum);
                            renderPage(parseInt(pageNum)).then(() => {
                                console.log("🎨 Page rendered, now selecting annotation");
                                selectAnnotation(foundAnnotation);
                            });
                        } else {

                            selectAnnotation(foundAnnotation);
                        }
                        break;
                    }
                }

                if (!foundAnnotation) {
                    console.error("❌ Annotation not found in annotationsByPage:", annotationId);
                }
            }
        });


        function updateSidebarSelection(selectedId) {
            const annotationItems = document.querySelectorAll('.annotation-item');
            annotationItems.forEach(item => {
                const annotationId = item.id.replace('annotation-', '');
                if (annotationId === selectedId) {
                    item.classList.add('selected');
                    item.style.backgroundColor = 'rgba(74, 144, 226, 0.2)';
                    item.style.borderLeft = '3px solid #4a90e2';
                } else {
                    item.classList.remove('selected');
                    item.style.backgroundColor = '';
                    item.style.borderLeft = '';
                }
            });
        }


        


        function generateUniqueId() {
            return 'id-' + Math.random().toString(36).substr(2, 9);
        }


        function fitToWidth() {
            const containerWidth = document.getElementById('pdf-container').offsetWidth;

            pdfDoc.getPage(currentPageNum).then(page => {
                const pageWidth = page.getViewport({ scale: 1 }).width;
                const scaleFactor = containerWidth / pageWidth;

                setScale(scaleFactor);
                updateZoomPercent();

            });
        }

        function fitToHeight() {
            const containerHeight = document.getElementById('pdf-container').offsetHeight;

            pdfDoc.getPage(currentPageNum).then(page => {
                const pageHeight = page.getViewport({ scale: 1 }).height;
                const scaleFactor = containerHeight / pageHeight;

                setScale(scaleFactor);
                updateZoomPercent();

            });
        }

        function toggleFullScreen() {
            const pdfContainer = document.getElementById('pdf-container');
            const fullScreenButton = document.querySelector('button[onclick="toggleFullScreen()"]');
            const icon = fullScreenButton.querySelector('i');

            if (!document.fullscreenElement) {
                if (pdfContainer.requestFullscreen) {
                    pdfContainer.requestFullscreen();
                } else if (pdfContainer.mozRequestFullScreen) {
                    pdfContainer.mozRequestFullScreen();
                } else if (pdfContainer.webkitRequestFullscreen) {
                    pdfContainer.webkitRequestFullscreen();
                } else if (pdfContainer.msRequestFullscreen) {
                    pdfContainer.msRequestFullscreen();
                }

                icon.classList.remove('fa-expand');
                icon.classList.add('fa-compress');
                fullScreenButton.setAttribute('title', 'Exit full-screen');

                pdfContainer.classList.add('fullscreen-mode');
                ensureContentWrapper();

            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }

                icon.classList.remove('fa-compress');
                icon.classList.add('fa-expand');
                fullScreenButton.setAttribute('title', 'Enter full-screen');

                pdfContainer.classList.remove('fullscreen-mode');
            }
        }

        function ensureContentWrapper() {
            const pdfContainer = document.getElementById('pdf-container');
            let wrapper = pdfContainer.querySelector('.pdf-content-wrapper');

            if (!wrapper) {
                wrapper = document.createElement('div');
                wrapper.className = 'pdf-content-wrapper';

                while (pdfContainer.firstChild) {
                    wrapper.appendChild(pdfContainer.firstChild);
                }

                pdfContainer.appendChild(wrapper);
            }
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'F11' || (event.key === 'Enter' && (event.ctrlKey || event.metaKey))) {
                event.preventDefault();
                toggleFullScreen();
            }
            else if (event.key === 'Escape' && document.fullscreenElement) {
                document.exitFullscreen();
            }
        });

        document.addEventListener('fullscreenchange', updateFullscreenUI);
        document.addEventListener('webkitfullscreenchange', updateFullscreenUI);
        document.addEventListener('mozfullscreenchange', updateFullscreenUI);
        document.addEventListener('MSFullscreenChange', updateFullscreenUI);

        function updateFullscreenUI() {
            const pdfContainer = document.getElementById('pdf-container');
            const fullScreenButton = document.querySelector('button[onclick="toggleFullScreen()"]');
            const icon = fullScreenButton.querySelector('i');

            if (document.fullscreenElement) {
                icon.classList.remove('fa-expand');
                icon.classList.add('fa-compress');
                fullScreenButton.setAttribute('title', 'Exit full-screen');
                pdfContainer.classList.add('fullscreen-mode');
                showToast('Entered fullscreen mode');
            } else {
                icon.classList.remove('fa-compress');
                icon.classList.add('fa-expand');
                fullScreenButton.setAttribute('title', 'Enter full-screen');
                pdfContainer.classList.remove('fullscreen-mode');
                showToast('Exited fullscreen mode');
            }
        }

        function setScale(scaleFactor) {
            currentScale = scaleFactor;

            pdfDoc.getPage(currentPageNum).then(page => {
                const newViewport = page.getViewport({ scale: currentScale });

                renderAllPages();
            });
        }

        let currentScale = 1.3;
        const defaultScale = 1.3;

        function debounce(func, wait) {
            return function (...args) {
                clearTimeout(zoomTimeout);
                zoomTimeout = setTimeout(() => func.apply(this, args), wait);
            };
        }


        function zoomIn() {
            const container = document.getElementById('pdf-container');

            const scrollTop = container.scrollTop;
            const scrollLeft = container.scrollLeft;
            const relativeY = (scrollTop + container.clientHeight / 2) / container.scrollHeight;
            const relativeX = (scrollLeft + container.clientWidth / 2) / container.scrollWidth;

            currentScale *= 1.1;
            updateZoomPercent();

            requestAnimationFrame(() => {
                const newScrollTop = (container.scrollHeight * relativeY) - (container.clientHeight / 2);
                const newScrollLeft = (container.scrollWidth * relativeX) - (container.clientWidth / 2);
                container.scrollTop = newScrollTop;
                container.scrollLeft = newScrollLeft;
            });

            renderAllPages();
        }

        function zoomOut() {
            const container = document.getElementById('pdf-container');

            const scrollTop = container.scrollTop;
            const scrollLeft = container.scrollLeft;
            const relativeY = (scrollTop + container.clientHeight / 2) / container.scrollHeight;
            const relativeX = (scrollLeft + container.clientWidth / 2) / container.scrollWidth;

            currentScale /= 1.1;
            renderAllPages();
            updateZoomPercent();

            requestAnimationFrame(() => {
                const newScrollTop = (container.scrollHeight * relativeY) - (container.clientHeight / 2);
                const newScrollLeft = (container.scrollWidth * relativeX) - (container.clientWidth / 2);
                container.scrollTop = newScrollTop;
                container.scrollLeft = newScrollLeft;
            });
        }

        function zoomReset() {
            const container = document.getElementById('pdf-container');

            const scrollTop = container.scrollTop;
            const scrollLeft = container.scrollLeft;
            const relativeY = (scrollTop + container.clientHeight / 2) / container.scrollHeight;
            const relativeX = (scrollLeft + container.clientWidth / 2) / container.scrollWidth;

            currentScale = defaultScale;
            renderAllPages();
            updateZoomPercent();

            requestAnimationFrame(() => {
                const newScrollTop = (container.scrollHeight * relativeY) - (container.clientHeight / 2);
                const newScrollLeft = (container.scrollWidth * relativeX) - (container.clientWidth / 2);
                container.scrollTop = newScrollTop;
                container.scrollLeft = newScrollLeft;
            });
        }
        function updateZoomPercent() {
            const zoomPercent = Math.round(currentScale * 100);
            document.getElementById('zoom-percent').textContent = zoomPercent;
            console.log("Zoom Percent:", zoomPercent);
        }

        function toggleThumbnails() {
            thumbnailContainer.style.display =
                thumbnailContainer.style.display === "none" ? "block" : "none";
        }

        function enableFreeDraw() {
            isFreeDrawEnabled = !isFreeDrawEnabled;
            fabricCanvas.isDrawingMode = isFreeDrawEnabled;
            fabricCanvas.freeDrawingBrush.width = 2;
            fabricCanvas.freeDrawingBrush.color = 'black';
        }

        function resetDrawingState() {
            isDrawing = false;
            fabricCanvas.isDrawingMode = false;
            fabricCanvas.selection = true;
            fabricCanvas.off('mouse:down');
            fabricCanvas.off('mouse:move');
            fabricCanvas.off('mouse:up');
        }

        


//         function loadPdfAnnotations(file) {
//     const formData = new FormData();
//     formData.append('file', file);
    
//     console.log("Starting to load annotations from file...");
//     showToast('Loading annotations...');
    
//     fetch('/api/annotations/load', {
//         method: 'POST',
//         body: formData
//     })
//     .then(response => {
//         if (!response.ok) {
//             return response.json().then(data => {
//                 throw new Error(data.error || `HTTP error! status: ${response.status}`);
//             });
//         }
//         return response.json();
//     })
//     .then(data => {
//         console.log('Received server response:', data);
//         console.log(`Server processed ${data.metadata.totalAnnotations} annotations`);
//         console.log(`Removed ${data.metadata.removedAnnotations} annotations from PDF`);
        
//         // Create a new PDF blob from the base64 content
//         if (data.pdfContent) {
//             console.log("Loading cleaned PDF document...");
//             const pdfBytes = atob(data.pdfContent);
//             const pdfArray = new Uint8Array(pdfBytes.length);
//             for (let i = 0; i < pdfBytes.length; i++) {
//                 pdfArray[i] = pdfBytes.charCodeAt(i);
//             }
            
//             // Load the modified PDF
//             pdfjsLib.getDocument({ data: pdfArray }).promise.then((pdf) => {
//                 console.log("PDF loaded successfully, processing annotations...");
//                 pdfDoc = pdf;
                
//                 // Clear existing annotations
//                 annotations = [];
//                 annotationsByPage = {};
                
//                 // Process annotations by page
//                 if (data.annotations) {
//                     Object.entries(data.annotations).forEach(([pageNum, pageAnnotations]) => {
//                         console.log(`Processing ${pageAnnotations.length} annotations for page ${pageNum}`);
                        
//                         const formattedAnnotations = pageAnnotations.map(annotation => {
//                             try {
//                                 const scaledAnnotation = convertPdfCoordsToCanvas(annotation, parseInt(pageNum));
//                                 console.log(`Processed annotation: ${annotation.type} on page ${pageNum}`);
//                                 return {
//                                     ...scaledAnnotation,
//                                     id: annotation.id || generateGuid(),
//                                     type: annotation.type || 'unknown',
//                                     page: parseInt(pageNum),
//                                     userName: annotation.userName || sessionUserName,
//                                     userId: annotation.userId || sessionUserId,
//                                     documentId: annotation.documentId || sessionDocumentId,
//                                     createdAt: annotation.createdAt || new Date().toISOString(),
//                                     isExisting: true
//                                 };
//                             } catch (error) {
//                                 console.error("Error formatting annotation:", error, annotation);
//                                 return null;
//                             }
//                         }).filter(item => item !== null);

//                         annotationsByPage[pageNum] = formattedAnnotations;
//                         annotations.push(...formattedAnnotations);
//                     });
                    
//                     console.log(`Total annotations processed: ${annotations.length}`);
//                     updateSidebar(annotations);
//                     renderAnnotationsForPage(currentPageNum, annotations, true);
//                     showToast(`Loaded ${annotations.length} annotations successfully`);
//                 }
//             });
//         }
//     })
//     .catch(error => {
//         console.error('Error loading annotations:', error);
//         showToast(`Error loading annotations: ${error.message}`);
//     });
// }


// // // Helper function to convert PDF coordinates to canvas coordinates
// function convertPdfCoordsToCanvas(annotation, pageNum) {
//     try {
//         // Defensive check - make sure we have a valid PDF document
//         if (!pdfDoc) {
//             console.error('PDF document not loaded');
//             return annotation; // Return unchanged if no PDF doc
//         }
        
//         // Get the page (with fallback for page number issues)
//         let page;
//         try {
//             page = pdfDoc.getPage(pageNum);
//         } catch (e) {
//             console.warn(`Error getting page ${pageNum}, trying page ${pageNum-1}`, e);
//             try {
//                 // Try with zero-based index
//                 page = pdfDoc.getPage(pageNum-1);
//             } catch (e2) {
//                 console.error(`Failed to get page ${pageNum-1} too`, e2);
//                 return annotation; // Return unchanged
//             }
//         }
        
//         // Get viewport with current scale
//         const viewport = page.getViewport({ scale: currentScale });
        
//         // Clone the annotation to avoid modifying the original
//         const converted = {...annotation};
        
//         // Calculate scaling factors
//         const scaleX = viewport.width / page.view[2];  
//         const scaleY = viewport.height / page.view[3];
        
//         // Convert coordinates - handle potential missing coordinates
//         if (annotation.hasOwnProperty('x1')) converted.x1 = annotation.x1 * scaleX;
//         if (annotation.hasOwnProperty('y1')) converted.y1 = viewport.height - (annotation.y1 * scaleY); // Y-axis is inverted
//         if (annotation.hasOwnProperty('x2')) converted.x2 = annotation.x2 * scaleX;
//         if (annotation.hasOwnProperty('y2')) converted.y2 = viewport.height - (annotation.y2 * scaleY); // Y-axis is inverted
        
//         // Calculate width and height based on coordinates
//         converted.width = (converted.x2 - converted.x1) || annotation.width * scaleX;
//         converted.height = (converted.y2 - converted.y1) || annotation.height * scaleY;
        
//         return converted;
//     } catch (error) {
//         console.error("Error in coordinate conversion:", error);
//         return annotation; // Return unchanged on error
//     }
// }



        // For IIS 

        window.onload = function () {
            const urlParams = new URLSearchParams(window.location.search);
            const pdfUrl = urlParams.get('pdf');

            sessionDocumentId = urlParams.get('DocumentId') || generateGuid();
    sessionUserId = urlParams.get('UserId') || generateGuid();
    sessionUserName = decodeURIComponent(urlParams.get('UserName')) || "Anurag Sable";

    console.log("Session values:", {
        documentId: sessionDocumentId,
        userId: sessionUserId,
        userName: sessionUserName
    });

            if (pdfUrl) {
                loadPdfFromUrl(pdfUrl);
            }
        }



        async function loadPdfFromUrl(url) {
            document.getElementById("pdf-canvas").style.display = "none";
            document.getElementById("fabric-canvas").style.display = "none";
            document.getElementById("annotation-canvas").style.display = "none";
            document.getElementById("text-layer").style.display = "none";
            document.querySelector(".upper-canvas").style.pointerEvents = "none";
            try {
                pdfContext.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
                fabricCanvas.clear();
                textLayer.innerHTML = '';
                const annotationCanvas = document.getElementById('annotation-canvas');
                const ctx = annotationCanvas.getContext('2d');
                ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

                annotationsByPage = {};
                annotations = [];

                showToast('Loading PDF...');

                document.getElementById("pdf-canvas").style.display = "block";
                document.getElementById("fabric-canvas").style.display = "block";
                document.getElementById("annotation-canvas").style.display = "block";
                document.getElementById("text-layer").style.display = "block";
                document.querySelector(".upper-canvas").style.pointerEvents = "auto";

                

                const encodedUrl = btoa(url); 
                const proxyUrl = `/load-pdf/${encodedUrl}`;
                console.log("Requesting PDF from:", proxyUrl);

                const response = await fetch(proxyUrl);

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to fetch PDF');
                }
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/pdf')) {
                    console.warn('Unexpected content type:', contentType);
                }

                const pdfData = await response.arrayBuffer();
                if (!pdfData || pdfData.byteLength === 0) {
                    throw new Error('Empty PDF data received');
                }

                const blob = new Blob([pdfData], { type: 'application/pdf' });
        const pdfFile = new File([blob], 'document.pdf', { type: 'application/pdf' });
        // await loadPDFWithAnnotations(pdfFile);
                pdfjsLib.getDocument({ data: new Uint8Array(pdfData) }).promise.then((pdf) => {
                    pdfDoc = pdf;
                    generateThumbnails();
                    renderAllPages();
                    updateZoomPercent();
                    addScrollListener();
                    document.getElementById('page-num').textContent = pageNum;
                    highlightThumbnail(pageNum);
                    window.scrollTo(0, 0);
                    showToast('PDF loaded successfully');
                    // loadPDFWithAnnotations(pdfFile);
                });

                // loadPDFWithAnnotations(url);
                
                toggleThumbnails();

                } catch (error) {
                console.error('Error loading PDF:', error);
                showToast('Error loading PDF from URL');

                document.getElementById("pdf-canvas").style.display = "none";
                document.getElementById("fabric-canvas").style.display = "none";
                document.getElementById("annotation-canvas").style.display = "none";
                document.getElementById("text-layer").style.display = "none";
                document.querySelector(".upper-canvas").style.pointerEvents = "none";
            }
        }




//         async function loadPdfFromUrl(url) {
//     document.getElementById("pdf-canvas").style.display = "none";
//     document.getElementById("fabric-canvas").style.display = "none";
//     document.getElementById("annotation-canvas").style.display = "none";
//     document.getElementById("text-layer").style.display = "none";
//     document.querySelector(".upper-canvas").style.pointerEvents = "none";
//     try {
//         pdfContext.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
//         fabricCanvas.clear();
//         textLayer.innerHTML = '';
//         const annotationCanvas = document.getElementById('annotation-canvas');
//         const ctx = annotationCanvas.getContext('2d');
//         ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

//         annotationsByPage = {};
//         annotations = [];

//         showToast('Loading PDF...');

//         document.getElementById("pdf-canvas").style.display = "block";
//         document.getElementById("fabric-canvas").style.display = "block";
//         document.getElementById("annotation-canvas").style.display = "block";
//         document.getElementById("text-layer").style.display = "block";
//         document.querySelector(".upper-canvas").style.pointerEvents = "auto";

//         const encodedUrl = btoa(url); 
//         const proxyUrl = `/load-pdf/${encodedUrl}`;
//         console.log("Requesting PDF from:", proxyUrl);

//         const response = await fetch(proxyUrl);

//         if (!response.ok) {
//             const errorData = await response.json();
//             throw new Error(errorData.error || 'Failed to fetch PDF');
//         }
//         const contentType = response.headers.get('content-type');
//         if (!contentType || !contentType.includes('application/pdf')) {
//             console.warn('Unexpected content type:', contentType);
//         }

//         const pdfData = await response.arrayBuffer();
//         if (!pdfData || pdfData.byteLength === 0) {
//             throw new Error('Empty PDF data received');
//         }

//         const blob = new Blob([pdfData], { type: 'application/pdf' });
//         const pdfFile = new File([blob], 'document.pdf', { type: 'application/pdf' });
        
//         // Process annotations first, but don't render the PDF yet
//         await processAnnotations(pdfFile);
        
//         toggleThumbnails();

//     } catch (error) {
//         console.error('Error loading PDF:', error);
//         showToast('Error loading PDF from URL');

//         document.getElementById("pdf-canvas").style.display = "none";
//         document.getElementById("fabric-canvas").style.display = "none";
//         document.getElementById("annotation-canvas").style.display = "none";
//         document.getElementById("text-layer").style.display = "none";
//         document.querySelector(".upper-canvas").style.pointerEvents = "none";
//     }
// }

// // New function to process annotations and load PDF only once
// async function processAnnotations(pdfFile) {
//     try {
//         showToast('Processing PDF annotations...');
        
//         const formData = new FormData();
//         formData.append('file', pdfFile);

//         const response = await fetch('/api/annotations/load', {
//             method: 'POST',
//             body: formData
//         });

//         if (!response.ok) {
//             throw new Error('Failed to load annotations');
//         }

//         const data = await response.json();
//         console.log("Received data from server:", {
//             annotationsCount: Object.keys(data.annotations || {}).length,
//             hasPdfContent: !!data.pdfContent,
//             metadata: data.metadata
//         });
        
//         // Store annotations globally
//         annotationsByPage = data.annotations || {};
        
//         // Use the clean PDF if available, otherwise use the original
//         let pdfBytes;
//         if (data.pdfContent) {
//             console.log("Using clean PDF from server");
//             // Convert base64 to binary array
//             const binaryString = atob(data.pdfContent);
//             pdfBytes = new Uint8Array(binaryString.length);
//             for (let i = 0; i < binaryString.length; i++) {
//                 pdfBytes[i] = binaryString.charCodeAt(i);
//             }
//             showToast('Using PDF with annotations removed');
//         } else {
//             console.warn("No clean PDF received, using original");
//             // Use the original PDF file
//             const arrayBuffer = await pdfFile.arrayBuffer();
//             pdfBytes = new Uint8Array(arrayBuffer);
//         }
        
//         // Load the PDF (either clean or original) only once
//         pdfjsLib.getDocument({ data: pdfBytes }).promise.then((pdf) => {
//             pdfDoc = pdf;
//             generateThumbnails();
//             renderAllPages();
//             updateZoomPercent();
//             addScrollListener();
//             document.getElementById('page-num').textContent = pageNum;
//             highlightThumbnail(pageNum);
//             window.scrollTo(0, 0);
            
//             // Apply annotations after PDF is loaded
//             applyAnnotationsFromJSON(annotationsByPage);
            
//             showToast('PDF loaded successfully');
//         });
        
//     } catch (error) {
//         console.error('Error processing annotations:', error);
//         showToast('Error processing annotations');
        
//         // Fall back to loading the original PDF
//         const arrayBuffer = await pdfFile.arrayBuffer();
//         pdfjsLib.getDocument({ data: new Uint8Array(arrayBuffer) }).promise.then((pdf) => {
//             pdfDoc = pdf;
//             generateThumbnails();
//             renderAllPages();
//             updateZoomPercent();
//             addScrollListener();
//             document.getElementById('page-num').textContent = pageNum;
//             highlightThumbnail(pageNum);
//             window.scrollTo(0, 0);
//             showToast('PDF loaded (original version)');
//         });
//     }
// }

// // Update loadPDFWithAnnotations to use the new processAnnotations function
// async function loadPDFWithAnnotations(pdfFile) {
//     await processAnnotations(pdfFile);
// }



//         // Add this function to your index.html
// function applyAnnotationsFromJSON(annotationsData) {
//     try {
//         console.log("Applying annotations from JSON:", annotationsData);
        
//         // Clear existing annotations on canvas
//         fabricCanvas.clear();

//         // Process annotations by page
//         Object.entries(annotationsData).forEach(([pageNum, annotations]) => {
//             // Skip if not current page
//             if (parseInt(pageNum) !== currentPageNum) return;

//             annotations.forEach(annotation => {
//                 try {
//                     const scaledAnnotation = convertPdfCoordsToCanvas(annotation, parseInt(pageNum));
                    
//                     switch (scaledAnnotation.type.toLowerCase()) {
//                         case 'text':
//                             applyTextAnnotation(scaledAnnotation);
//                             break;
//                         case 'highlight':
//                             applyHighlightAnnotation(scaledAnnotation);
//                             break;
//                         case 'underline':
//                             applyUnderlineAnnotation(scaledAnnotation);
//                             break;
//                         case 'strikeout':
//                             applyStrikeoutAnnotation(scaledAnnotation);
//                             break;
//                         case 'square':
//                             applySquareAnnotation(scaledAnnotation);
//                             break;
//                         case 'circle':
//                             applyCircleAnnotation(scaledAnnotation);
//                             break;
//                         case 'line':
//                             applyLineAnnotation(scaledAnnotation);
//                             break;
//                         case 'freedraw':
//                             applyFreeDrawAnnotation(scaledAnnotation);
//                             break;
//                         case 'cloud':
//                             applyCloudAnnotation(scaledAnnotation);
//                             break;
//                         case 'stamp':
//                             applyStampAnnotation(scaledAnnotation);
//                             break;
//                         case 'signature':
//                             applySignatureAnnotation(scaledAnnotation);
//                             break;
//                         default:
//                             console.warn(`Unknown annotation type: ${scaledAnnotation.type}`);
//                     }
//                 } catch (err) {
//                     console.error(`Error applying annotation: ${err.message}`, scaledAnnotation);
//                 }
//             });
//         });

//         fabricCanvas.renderAll();
//     } catch (error) {
//         console.error("Error applying annotations:", error);
//         showToast('Error applying annotations');
//     }
// }

// function convertPdfCoordsToCanvas(annotation, pageNum) {
//     try {
//         // Make a copy of the annotation to avoid modifying the original
//         const scaledAnnotation = {...annotation};
        
//         // Get the scale factor between PDF and canvas
//         const scale = getScaleFactor();
        
//         // Scale the coordinates
//         if (scaledAnnotation.x1 !== undefined) scaledAnnotation.x1 = scaledAnnotation.x1 / scale.x;
//         if (scaledAnnotation.y1 !== undefined) scaledAnnotation.y1 = scaledAnnotation.y1 / scale.y;
//         if (scaledAnnotation.x2 !== undefined) scaledAnnotation.x2 = scaledAnnotation.x2 / scale.x;
//         if (scaledAnnotation.y2 !== undefined) scaledAnnotation.y2 = scaledAnnotation.y2 / scale.y;
//         if (scaledAnnotation.width !== undefined) scaledAnnotation.width = scaledAnnotation.width / scale.x;
//         if (scaledAnnotation.height !== undefined) scaledAnnotation.height = scaledAnnotation.height / scale.y;
        
//         return scaledAnnotation;
//     } catch (error) {
//         console.error("Error converting coordinates:", error);
//         return annotation; // Return original if conversion fails
//     }
// }


// // Helper functions for each annotation type
// function applyTextAnnotation(annotation) {
//     const textbox = new fabric.Textbox(annotation.text || "Enter Text", {
//         left: annotation.x1,
//         top: annotation.y1,
//         width: annotation.width || 150,
//         fontSize: annotation.fontSize || 16,
//         fill: annotation.fill || 'black',
//         id: annotation.id,
//         selectable: true,
//         evented: true,
//         annotationType: 'text'
//     });
//     fabricCanvas.add(textbox);
// }

// function applyHighlightAnnotation(annotation) {
//     const rect = new fabric.Rect({
//         left: annotation.x1,
//         top: annotation.y1,
//         width: annotation.x2 - annotation.x1,
//         height: annotation.y2 - annotation.y1,
//         fill: 'rgba(255, 255, 0, 0.3)',
//         selectable: true,
//         evented: true,
//         id: annotation.id,
//         annotationType: 'highlight'
//     });
//     fabricCanvas.add(rect);
// }

// function applyUnderlineAnnotation(annotation) {
//     const line = new fabric.Line([
//         annotation.x1,
//         annotation.y2,
//         annotation.x2,
//         annotation.y2
//     ], {
//         stroke: 'red',
//         strokeWidth: 1,
//         selectable: true,
//         evented: true,
//         id: annotation.id,
//         annotationType: 'underline'
//     });
//     fabricCanvas.add(line);
// }

// function applyStrikeoutAnnotation(annotation) {
//     const line = new fabric.Line([
//         annotation.x1,
//         (annotation.y1 + annotation.y2) / 2,
//         annotation.x2,
//         (annotation.y1 + annotation.y2) / 2
//     ], {
//         stroke: 'red',
//         strokeWidth: annotation.strokeWidth || 1,
//         selectable: true,
//         evented: true,
//         id: annotation.id,
//         annotationType: 'strikeout'
//     });
//     fabricCanvas.add(line);
// }

// function applySquareAnnotation(annotation) {
//     const rect = new fabric.Rect({
//         left: annotation.x1,
//         top: annotation.y1,
//         width: annotation.x2 - annotation.x1,
//         height: annotation.y2 - annotation.y1,
//         fill: 'transparent',
//         stroke: 'red',
//         strokeWidth: annotation.strokeWidth || 1,
//         selectable: true,
//         evented: true,
//         id: annotation.id,
//         annotationType: 'square'
//     });
//     fabricCanvas.add(rect);
// }

// function applyCircleAnnotation(annotation) {
//     const circle = new fabric.Circle({
//         left: annotation.x1,
//         top: annotation.y1,
//         radius: annotation.radius || 50,
//         fill: 'transparent',
//         stroke: 'red',
//         strokeWidth: annotation.strokeWidth || 1,
//         selectable: true,
//         evented: true,
//         id: annotation.id,
//         annotationType: 'circle'
//     });
//     fabricCanvas.add(circle);
// }

// function applyLineAnnotation(annotation) {
//     const line = new fabric.Line([
//         annotation.x1,
//         annotation.y1,
//         annotation.x2,
//         annotation.y2
//     ], {
//         stroke: 'red',
//         strokeWidth: annotation.strokeWidth || 2,
//         selectable: true,
//         evented: true,
//         id: annotation.id,
//         annotationType: 'line'
//     });
//     fabricCanvas.add(line);
// }

// function applyFreeDrawAnnotation(annotation) {
//     if (!annotation.path) return;
    
//     const path = new fabric.Path(annotation.path.map(cmd => cmd.join(' ')).join(' '), {
//         stroke: annotation.stroke || 'red',
//         strokeWidth: annotation.strokeWidth || 2,
//         fill: 'transparent',
//         selectable: true,
//         evented: true,
//         id: annotation.id,
//         annotationType: 'freeDraw'
//     });
//     fabricCanvas.add(path);
// }

// function applyCloudAnnotation(annotation) {
//     if (!annotation.path) return;

//     const path = new fabric.Path(annotation.path.map(cmd => cmd.join(' ')).join(' '), {
//         stroke: annotation.stroke || 'red',
//         strokeWidth: annotation.strokeWidth || 2,
//         fill: 'transparent',
//         selectable: true,
//         evented: true,
//         id: annotation.id,
//         annotationType: 'cloud'
//     });
//     fabricCanvas.add(path);
// }

// function applyStampAnnotation(annotation) {
//     if (!annotation.imgSrc) return;

//     fabric.Image.fromURL(annotation.imgSrc, img => {
//         img.set({
//             left: annotation.x1,
//             top: annotation.y1,
//             width: annotation.width,
//             height: annotation.height,
//             selectable: true,
//             evented: true,
//             id: annotation.id,
//             annotationType: 'stamp'
//         });
//         fabricCanvas.add(img);
//     });
// }

// function applySignatureAnnotation(annotation) {
//     if (!annotation.dataURL) return;

//     fabric.Image.fromURL(annotation.dataURL, img => {
//         img.set({
//             left: annotation.x1,
//             top: annotation.y1,
//             width: annotation.width,
//             height: annotation.height,
//             selectable: true,
//             evented: true,
//             id: annotation.id,
//             annotationType: 'signature'
//         });
//         fabricCanvas.add(img);
//     });
// }





// ... existing code ...
// async function loadPDFWithAnnotations(pdfFile) {
//     try {
//         // Show loading toast
//         showToast('Processing PDF annotations...');
        
//         // Create FormData and append the file
//         const formData = new FormData();
//         formData.append('file', pdfFile);

//         // Fetch annotations from backend
//         const response = await fetch('/api/annotations/load', {
//             method: 'POST',
//             body: formData
//         });

//         if (!response.ok) {
//             throw new Error('Failed to load annotations');
//         }

//         const data = await response.json();
//         console.log("Received data from server:", {
//             annotationsCount: Object.keys(data.annotations || {}).length,
//             hasPdfContent: !!data.pdfContent,
//             metadata: data.metadata
//         });
        
//         // Store annotations globally
//         annotationsByPage = data.annotations || {};
        
//         // Use the clean PDF (with annotations removed) if available
//         if (data.pdfContent) {
//             console.log("Loading clean PDF from server response");
            
//             // Convert base64 to binary array
//             const binaryString = atob(data.pdfContent);
//             const bytes = new Uint8Array(binaryString.length);
//             for (let i = 0; i < binaryString.length; i++) {
//                 bytes[i] = binaryString.charCodeAt(i);
//             }
            
//             // Load the clean PDF with PDF.js
//             pdfjsLib.getDocument({ data: bytes }).promise.then((pdf) => {
//                 // Replace the current PDF document
//                 pdfDoc = pdf;
                
//                 // Re-render everything with the clean PDF
//                 generateThumbnails();
//                 renderAllPages();
//                 updateZoomPercent();
//                 addScrollListener();
//                 document.getElementById('page-num').textContent = pageNum;
//                 highlightThumbnail(pageNum);
//                 window.scrollTo(0, 0);
                
//                 // Apply annotations to the clean PDF
//                 applyAnnotationsFromJSON(annotationsByPage);
                
//                 showToast('PDF loaded with annotations removed');
//             }).catch(error => {
//                 console.error("Error loading clean PDF:", error);
//                 showToast('Error loading clean PDF');
                
//                 // Fall back to applying annotations to the original PDF
//                 applyAnnotationsFromJSON(annotationsByPage);
//             });
//         } else {
//             console.warn("No clean PDF content received from server");
//             // Just apply annotations to the current PDF
//             applyAnnotationsFromJSON(annotationsByPage);
//         }
        
//     } catch (error) {
//         console.error('Error loading annotations:', error);
//         showToast('Error loading annotations');
//     }
// }


      



        // For Local Server App.py



        // window.onload = function() {
        //     // Get the PDF URL from the query parameters
        //     const urlParams = new URLSearchParams(window.location.search);
        //     const pdfUrl = urlParams.get('pdf');

        //     if (pdfUrl) {
        //         loadPdfFromUrl(pdfUrl);
        //     }
        // }


        // async function loadPdfFromUrl(url) {
        //     document.getElementById("pdf-canvas").style.display = "none";
        //         document.getElementById("fabric-canvas").style.display = "none";
        //         document.getElementById("annotation-canvas").style.display = "none";
        //         document.getElementById("text-layer").style.display = "none";
        //         document.querySelector(".upper-canvas").style.pointerEvents = "none";
        //     try {
        //         pdfContext.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
        //         fabricCanvas.clear();
        //         textLayer.innerHTML = '';
        //         const annotationCanvas = document.getElementById('annotation-canvas');
        //         const ctx = annotationCanvas.getContext('2d');
        //         ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);

        //         annotationsByPage = {};
        //         annotations = [];

        //         showToast('Loading PDF...');

        //         document.getElementById("pdf-canvas").style.display = "block";
        //         document.getElementById("fabric-canvas").style.display = "block";
        //         document.getElementById("annotation-canvas").style.display = "block";
        //         document.getElementById("text-layer").style.display = "block";
        //         document.querySelector(".upper-canvas").style.pointerEvents = "auto";

        //         const proxyUrl = `/load-pdf/${encodeURIComponent(url)}`;
        //         const response = await fetch(proxyUrl);

        //         if (!response.ok) throw new Error('Failed to fetch PDF');
        //         const pdfData = await response.arrayBuffer();
        //         pdfjsLib.getDocument({ data: new Uint8Array(pdfData) }).promise.then((pdf) => {
        //             pdfDoc = pdf;
        //             generateThumbnails();
        //             renderAllPages();
        //             updateZoomPercent();
        //             addScrollListener();
        //             document.getElementById('page-num').textContent = pageNum;
        //             highlightThumbnail(pageNum);
        //             window.scrollTo(0, 0);
        //             showToast('PDF loaded successfully');
        //         });

        //         toggleThumbnails();
        //     } catch (error) {
        //         console.error('Error loading PDF:', error);
        //         showToast('Error loading PDF from URL');

        //         document.getElementById("pdf-canvas").style.display = "none";
        //         document.getElementById("fabric-canvas").style.display = "none";
        //         document.getElementById("annotation-canvas").style.display = "none";
        //         document.getElementById("text-layer").style.display = "none";
        //         document.querySelector(".upper-canvas").style.pointerEvents = "none";
        //     }
        // }        



        // document.getElementById("pdf-canvas").style.display = "none";
        // document.getElementById("fabric-canvas").style.display = "none";
        // document.getElementById("annotation-canvas").style.display = "none";
        // document.getElementById("text-layer").style.display = "none";
        // document.querySelector(".upper-canvas").style.pointerEvents = "none";

        // document.getElementById("file-input").addEventListener("change", (event) => {
        //     const file = event.target.files[0];

        //     if (file) {
        //         // showToast('Opening PDF file...');

        //         // resetCanvas();
        //         pdfContext.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
        //         fabricCanvas.clear();
        //         textLayer.innerHTML = '';
        //         const annotationCanvas = document.getElementById('annotation-canvas');
        //         const ctx = annotationCanvas.getContext('2d');

        //         ctx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height); 

        //         annotationsByPage = {};
        //         annotations = []; 



        //         document.getElementById("pdf-canvas").style.display = "block";
        //         document.getElementById("fabric-canvas").style.display = "block";
        //         document.getElementById("annotation-canvas").style.display = "block";
        //         document.getElementById("text-layer").style.display = "block";

        //         document.querySelector(".upper-canvas").style.pointerEvents = "auto";
        //         const reader = new FileReader();
        //         reader.onload = function (e) {
        //             const pdfData = new Uint8Array(e.target.result);
        //             pdfjsLib.getDocument({ data: pdfData }).promise.then((pdf) => {
        //                 pdfDoc = pdf;
        //                 generateThumbnails();
        //                 renderAllPages();
        //                 updateZoomPercent();
        //                 addScrollListener();
        //                 document.getElementById('page-num').textContent = pageNum;
        //                 highlightThumbnail(pageNum);
        //                 window.scrollTo(0, 0);

        //             });
        //         };
        //         reader.readAsArrayBuffer(file);
        //         toggleThumbnails();
        //     } else {

        //         document.getElementById("pdf-canvas").style.display = "none";
        //         document.getElementById("fabric-canvas").style.display = "none";
        //         document.getElementById("annotation-canvas").style.display = "none";
        //         document.getElementById("text-layer").style.display = "none";
        //         document.querySelector(".upper-canvas").style.pointerEvents = "none";
        //     }
        // });



        function generateThumbnails() {
            thumbnailsContainer.innerHTML = "";
            const renderPromises = [];

            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'thumbnail-wrapper thumbnail-loading';

                const placeholder = document.createElement('div');
                placeholder.style.width = '100%';
                placeholder.style.height = '150px';
                wrapper.appendChild(placeholder);

                const pageNumber = document.createElement('div');
                pageNumber.className = 'page-number';
                pageNumber.textContent = `Page ${i}`;
                wrapper.appendChild(pageNumber);

                thumbnailsContainer.appendChild(wrapper);
                renderPromises.push(
                    pdfDoc.getPage(i).then((page) => {
                        const viewport = page.getViewport({ scale: 0.2 });
                        const thumbnailCanvas = document.createElement("canvas");
                        thumbnailCanvas.width = viewport.width;
                        thumbnailCanvas.height = viewport.height;
                        const context = thumbnailCanvas.getContext("2d");
                        const renderContext = {
                            canvasContext: context,
                            viewport: viewport,
                        };

                        return page.render(renderContext).promise.then(() => {
                            thumbnailCanvas.setAttribute('data-page', i);
                            thumbnailCanvas.addEventListener("click", () => {
                                const targetPage = document.querySelector(`.pdf-page[data-page-number="${i}"]`);
                                if (targetPage) {
                                    targetPage.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                    highlightThumbnail(i);
                                    document.getElementById('page-num').textContent = i;
                                    pageNum = i;
                                }
                            });

                            wrapper.innerHTML = '';
                            wrapper.appendChild(thumbnailCanvas);
                            wrapper.appendChild(pageNumber);
                            wrapper.classList.remove('thumbnail-loading');

                            return wrapper;
                        });
                    })
                );
            }

            Promise.all(renderPromises).then(() => {
                highlightThumbnail(pageNum);
            });
        }

        function highlightThumbnail(pageNum) {
            const thumbnails = document.querySelectorAll("#thumbnails canvas");

            thumbnails.forEach((thumbnail) => {
                const wrapper = thumbnail.parentElement;
                const currentPage = parseInt(thumbnail.getAttribute('data-page'));

                if (currentPage === pageNum) {
                    thumbnail.classList.add('thumbnail-active');

                    const container = document.getElementById('thumbnail-container');
                    const wrapperRect = wrapper.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();

                    const scrollTop = wrapper.offsetTop - (container.clientHeight / 2) + (wrapperRect.height / 2);

                    container.scrollTo({
                        top: scrollTop,
                        behavior: 'smooth'
                    });
                } else {
                    thumbnail.classList.remove('thumbnail-active');
                }
            });
        }



        function addScrollListener() {
            let scrollTimeout;
            const pdfContainer = document.getElementById('pdf-container');

            // Change from window to pdfContainer
            pdfContainer.addEventListener('scroll', () => {
                if (scrollTimeout) {
                    clearTimeout(scrollTimeout);
                }
                scrollTimeout = setTimeout(() => {
                    const visiblePage = getMostVisiblePage();
                    if (visiblePage) {
                        highlightThumbnail(visiblePage);
                        document.getElementById('page-num').textContent = visiblePage;
                        pageNum = visiblePage;
                    }
                }, 50);
            });
        }

        function getMostVisiblePage() {
            const pdfContainer = document.getElementById('pdf-container');
            const pages = pdfContainer.querySelectorAll('.pdf-page');
            let maxVisibleArea = 0;
            let mostVisiblePage = 1;

            pages.forEach(page => {
                const rect = page.getBoundingClientRect();
                const containerRect = pdfContainer.getBoundingClientRect();
                const pageNum = parseInt(page.dataset.pageNumber);

                const visibleTop = Math.max(rect.top, containerRect.top);
                const visibleBottom = Math.min(rect.bottom, containerRect.bottom);
                const visibleHeight = Math.max(0, visibleBottom - visibleTop);
                const visibleArea = visibleHeight * rect.width;

                if (visibleArea > maxVisibleArea) {
                    maxVisibleArea = visibleArea;
                    mostVisiblePage = pageNum;
                }
            });

            return mostVisiblePage;
        }


        function renderDrawingAnnotation(annotation, fabricCanvas) {
            let obj;

            const left = annotation.x1;
            const top = annotation.y1;
            const width = (annotation.x2 - annotation.x1);
            const height = (annotation.y2 - annotation.y1);

            switch (annotation.type) {
                case 'square':
                    obj = new fabric.Rect({
                        left: left,
                        top: top,
                        width: width,
                        height: height,
                        fill: '',
                        stroke: annotation.stroke || 'red',
                        strokeWidth: (annotation.strokeWidth || 2),
                    });
                    break;
                case 'line':
                    obj = new fabric.Line(
                        [left, top, annotation.x2, annotation.y2],
                        {
                            stroke: annotation.stroke || 'red',
                            strokeWidth: (annotation.strokeWidth || 2),
                        }
                    );
                    break;
                case 'circle':
                    obj = new fabric.Circle({
                        left: left,
                        top: top,
                        radius: annotation.radius,
                        fill: annotation.fill || 'transparent',
                        stroke: annotation.stroke || 'red',
                        strokeWidth: (annotation.strokeWidth || 2),
                    });
                    break;
                case 'text':
                    obj = new fabric.Textbox(annotation.content || 'Enter Text', {
                        left: left,
                        top: top,
                        fontSize: (annotation.fontSize || 20),
                        fill: annotation.fill || 'black',
                    });
                    break;
                case 'freeDraw':
                    obj = new fabric.Path(annotation.path, {
                        stroke: annotation.stroke || 'red',
                        strokeWidth: (annotation.strokeWidth || 2) * currentScale,
                        fill: '',
                    });
                    break;
                case 'cloud':
                    obj = new fabric.Path(annotation.path, {
                        fill: 'transparent',
                        stroke: annotation.stroke || 'blue',
                        strokeWidth: (annotation.strokeWidth || 2) * currentScale,
                    });
                    break;

                case 'stamp':
                    fabric.Image.fromURL(annotation.imgSrc, function (img) {
                        const StampsScaleFactor = annotation.scaleFactor || 0.6;
                        img.scale(StampsScaleFactor);
                        img.set({
                            left: left,
                            top: top,
                            // width: width,
                            // height: height,
                            originX: 'center',
                            originY: 'center',
                            selectable: true,
                            evented: true,
                        });
                        fabricCanvas.add(img);
                        console.log("Stamp Annotation:", annotation);
                    });
                    break;
                case 'signature':
                    fabric.Image.fromURL(annotation.dataURL, function (img) {
                        const SigniturescaleFactor = annotation.scaleFactor || 0.4;
                        img.scale(SigniturescaleFactor);
                        img.set({
                            left: left,
                            top: top,
                            originX: 'center',
                            originY: 'center',
                            selectable: true,
                            evented: true,

                        });
                        fabricCanvas.add(img);
                    });
                    break;
                default:
                    console.warn('Unknown annotation type:', annotation.type);
                    return;
            }

            if (obj) {
                obj.id = annotation.id;
                fabricCanvas.add(obj);
            }
        }

        function renderAnnotationsForPage(pageNum, annotations, viewport, textLayer) {
            let fabricCanvas = fabricCanvases[pageNum];
            if (!fabricCanvas) {
                console.error("Fabric.js canvas not found for page:", pageNum);
                return;
            }
            fabricCanvas.clear();
            annotations.forEach(annotation => {
                renderDrawingAnnotation(annotation, fabricCanvas);
            });
        }





        async function renderAllPages() {
            const pdfContainer = document.getElementById('pdf-container');
            pdfContainer.innerHTML = '';

            // Create placeholder divs for all pages
            for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
                const pageWrapper = document.createElement('div');
                pageWrapper.classList.add('pdf-page');
                pageWrapper.style.position = 'relative';
                pageWrapper.style.marginBottom = '10px';
                pageWrapper.dataset.pageNumber = pageNum;

                pdfDoc.getPage(pageNum).then(page => {
                    const viewport = page.getViewport({ scale: currentScale });
                    pageWrapper.style.width = `${viewport.width}px`;
                    pageWrapper.style.height = `${viewport.height}px`;
                });
                pageWrapper.innerHTML = `<div class="page-loading">Loading page ${pageNum}...</div>`;
                pdfContainer.appendChild(pageWrapper);
            }

            // Set up Intersection Observer
            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const pageNum = parseInt(entry.target.dataset.pageNumber);
                        renderPage(pageNum).then(() => {
                            // Unobserve after rendering
                            observer.unobserve(entry.target);
                        });
                    }
                });
            }, {
                root: null,
                rootMargin: '10px 0px',
                threshold: 0.1
            });

            // Observe all page wrappers
            document.querySelectorAll('.pdf-page').forEach(pageWrapper => {
                observer.observe(pageWrapper);
            });

            // Render the first visible page immediately
            const visiblePage = getMostVisiblePage() || 1;
            await renderPage(visiblePage);
            highlightThumbnail(visiblePage);
            document.getElementById('page-num').textContent = visiblePage;
        }

        function renderPage(num) {
            return new Promise((resolve) => {
                const pageWrapper = document.querySelector(`.pdf-page[data-page-number="${num}"]`);
                if (!pageWrapper) {
                    console.error(`Page wrapper ${num} not found`);
                    resolve();
                    return;
                }

                // Clear the loading placeholder
                pageWrapper.innerHTML = '';
                currentPageNum = num;

                pdfDoc.getPage(num).then(page => {
                    const viewport = page.getViewport({ scale: currentScale });

                    // Create and append canvas elements
                    const pdfCanvas = document.createElement('canvas');
                    pdfCanvas.classList.add('pdf-canvas');
                    pdfCanvas.width = viewport.width;
                    pdfCanvas.height = viewport.height;
                    pageWrapper.appendChild(pdfCanvas);

                    attachFabricCanvas(pageWrapper, viewport, num);

                    const annotationCanvas = document.createElement('canvas');
                    annotationCanvas.classList.add('annotation-canvas');
                    annotationCanvas.width = viewport.width;
                    annotationCanvas.height = viewport.height;
                    annotationCanvas.style.position = 'absolute';
                    annotationCanvas.style.top = '0';
                    annotationCanvas.style.left = '0';
                    annotationCanvas.style.pointerEvents = 'none';
                    pageWrapper.appendChild(annotationCanvas);

                    // Render PDF content
                    const pdfContext = pdfCanvas.getContext('2d');
                    const renderContext = {
                        canvasContext: pdfContext,
                        viewport: viewport,
                    };

                    page.render(renderContext).promise.then(() => {
                        const fabricCanvas = fabricCanvases[num];
                        if (fabricCanvas) {
                            fabricCanvas.setWidth(viewport.width);
                            fabricCanvas.setHeight(viewport.height);
                            fabricCanvas.setZoom(currentScale);
                        }

                        renderTextLayer(page, viewport, pageWrapper, num);
                        const ctx = initializeAnnotationCanvas(viewport, pageWrapper);
                        if (ctx) {
                            renderAnnotations(num, ctx, viewport);
                        }

                        if (annotationsByPage[num]) {
                            renderAnnotationsForPage(num, annotationsByPage[num], viewport, textLayer);
                        }

                        resolve();
                    });
                });
            });
        }

        // Add some CSS for the loading state
        const style = document.createElement('style');
        style.textContent = `
    .page-loading {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
        font-size: 1.2em;
        color: #666;
        background: #f5f5f5;
    }
`;
        document.head.appendChild(style);


        let fabricCanvases = {};
        function attachFabricCanvas(pageWrapper, viewport, num) {
            const fabricCanvasElement = document.createElement('canvas');
            fabricCanvasElement.width = viewport.width;
            fabricCanvasElement.height = viewport.height;
            pageWrapper.appendChild(fabricCanvasElement);

            const fabricCanvas = new fabric.Canvas(fabricCanvasElement, {
                selection: true,
                selectionColor: 'rgba(0, 0, 0, 0)',
                selectionBorderColor: 'rgba(0, 0, 0, 0)',
                selectionLineWidth: 0
            });

            fabricCanvas.setZoom(currentScale);
            fabricCanvases[num] = fabricCanvas;
        }


        function renderTextLayer(page, viewport, pageWrapper, pageNum) {
            let existingTextLayer = pageWrapper.querySelector('.text-layer');
            if (existingTextLayer) {
                existingTextLayer.remove();
            }
            const textLayerDiv = document.createElement('div');
            textLayerDiv.dataset.pageNumber = pageNum;

            textLayerDiv.innerHTML = `
        <style>
           .text-layer {
                position: absolute;
                top: 0;
                left: 0;
                overflow: visible;
                pointer-events: none; 
                transform-origin: 0 0;
                background: rgba(255, 255, 255, 0.001); 
                will-change: transform;
                mix-blend-mode: multiply;
            }
                
            .text-layer span {
                pointer-events: all;
                position: absolute;
                white-space: pre;
                color: transparent;
                background: transparent;
                transform-origin: 0 0;
                user-select: text;
                transition: background-color 0.15s ease;
                -webkit-text-fill-color: transparent;
            }

            .text-layer span::selection {
                background: rgba(0, 120, 215, 0.3);
                color: transparent;
                transition: background-color 0.15s ease;
            }

            .text-layer span::-moz-selection {
                background: rgba(0, 120, 215, 0.3);
                color: transparent;
                transition: background-color 0.15s ease;
            }

            .text-layer span + span {
                margin-left: -0.5px;
            }
        </style>
    `;
            textLayerDiv.classList.add('text-layer');
            pageWrapper.appendChild(textLayerDiv);
            page.getTextContent().then(textContent => {
                pdfjsLib.renderTextLayer({
                    textContent,
                    container: textLayerDiv,
                    viewport,
                    textDivs: [],
                    enhanceTextSelection: true,
                }).promise.then(() => {
                    setupTextLayerEventListeners(pageWrapper, pageNum);
                });
            });
        }



        function stopAnnotationMode() {
            annotationMode = null;
            console.log("Annotation mode stopped");
            window.getSelection().removeAllRanges();
        }


        let annotationMode = null;
        document.getElementById('highlight').addEventListener('click', () => {
            if (annotationMode === 'highlight') {
                stopAnnotationMode();
                enableSelectMode();
            } else {
                annotationMode = 'highlight';
                console.log("Annotation mode set to highlight");
                enableTextLayer();
            }
        });

        document.getElementById('underline').addEventListener('click', () => {
            if (annotationMode === 'underline') {
                stopAnnotationMode();
                enableSelectMode();
            } else {
                annotationMode = 'underline';
                console.log("Annotation mode set to underline");
                enableTextLayer();
            }
        });

        document.getElementById('strikeout').addEventListener('click', () => {
            if (annotationMode === 'strikeout') {
                stopAnnotationMode();
                enableSelectMode();
            } else {
                annotationMode = 'strikeout';
                console.log("Annotation mode set to strikeout");
                enableTextLayer();
            }
        });
        document.addEventListener('DOMContentLoaded', () => {
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                if (!['highlight', 'underline', 'strikeout'].includes(button.id)) {
                    button.addEventListener('click', () => {
                        if (annotationMode !== null) {
                            stopAnnotationMode();
                            enableSelectMode();
                        }
                    });
                }
            });
        });

        function cancelAnnotation() {
            console.log("Canceling annotation...");
            window.getSelection().removeAllRanges();

            if (currentAnnotationType === 'stamp') {
                stopStampProcess();
            }

            annotationMode = null;
            fabricCanvas.isDrawingMode = false;
            isDrawing = false;
            currentAnnotationType = null;
            enableSelectMode();
        }



        function setupTextLayerEventListeners(pageWrapper, pageNum) {
            const textLayer = pageWrapper.querySelector('.text-layer');
            if (!textLayer) {
                console.error("Text layer not found");
                return;
            }

            textLayer.dataset.pageNumber = pageNum;
            console.log(`Setting up text layer listeners for page ${pageNum}`);

            textLayer.addEventListener('mouseup', (event) => {
                console.log("Mouse up event on page:", pageNum);

                // console.log("Mouse up event triggered");
                const selection = window.getSelection();

                const actualPageNum = parseInt(textLayer.dataset.pageNumber);
                console.log(`Creating annotation on page ${actualPageNum}`);


                // console.log("Selection:", selection);
                // console.log("Annotation Mode:", annotationMode);

                if (!selection || selection.isCollapsed || !annotationMode) {
                    console.log("Selection invalid or no annotation mode");
                    return;
                }

                const range = selection.getRangeAt(0);
                const text = selection.toString().trim();
                // console.log("Selected Text:", text);
                // console.log("Range:", range);

                if (!text) {
                    console.log("No text selected");
                    return;
                }

                //   const textLayer = document.getElementById('text-layer');
                if (!textLayer.contains(range.commonAncestorContainer)) {
                    console.log("Selection not within text layer");
                    return;
                }

                const rects = Array.from(range.getClientRects());
                const textLayerRect = textLayer.getBoundingClientRect();

                let uniqueRects = [];
                const annotationsToAdd = [];

                rects.forEach((rect) => {
                    let merged = false;

                    uniqueRects.forEach((uniqueRect) => {
                        const isSameLine = Math.abs(uniqueRect.top - rect.top) < rect.height * 0.7; // Allow slight variation for same line
                        const overlapX = Math.min(uniqueRect.right, rect.right) > Math.max(uniqueRect.left, rect.left);
                        const overlapY = Math.min(uniqueRect.bottom, rect.bottom) > Math.max(uniqueRect.top, rect.top); // Vertical overlap

                        if (isSameLine && overlapX && overlapY) {
                            uniqueRect.left = Math.min(uniqueRect.left, rect.left);
                            uniqueRect.top = Math.min(uniqueRect.top, rect.top);
                            uniqueRect.right = Math.max(uniqueRect.right, rect.right);
                            uniqueRect.bottom = Math.max(uniqueRect.bottom, rect.bottom);
                            uniqueRect.width = uniqueRect.right - uniqueRect.left;
                            uniqueRect.height = uniqueRect.bottom - uniqueRect.top;
                            merged = true;
                        }
                    });

                    if (!merged) {
                        uniqueRects.push({
                            left: rect.left,
                            top: rect.top,
                            right: rect.right,
                            bottom: rect.bottom,
                            width: rect.width,
                            height: rect.height,
                        });
                    }
                });

                uniqueRects = uniqueRects.filter((rect) => rect.width > 0 && rect.height > 0);

                console.log("Merged Rectangles:", uniqueRects);

                const startIndex = range.startOffset;
                const endIndex = range.endOffset;
                const lineAnnotations = [];


                uniqueRects.forEach((rect) => {
                    const lineAnnotation = {
                        left: (rect.left - textLayerRect.left) / currentScale,
                        top: (rect.top - textLayerRect.top) / currentScale,
                        width: rect.width / currentScale,
                        height: rect.height / currentScale,

                    };
                    console.log('Line Annotation:', lineAnnotation);
                    lineAnnotations.push(lineAnnotation);
                    drawAnnotation(rect, annotationMode, textLayerRect, pageWrapper);
                });



                const annotationId = Date.now() + Math.random().toString(36).substr(2, 9); // Unique ID
                const annotation = {
                    id: annotationId,
                    //   mode: annotationMode,
                    type: annotationMode,
                    text,
                    startIndex,
                    endIndex,
                    page: actualPageNum,
                    scale: currentScale,
                    lineAnnotations,
                    title: `${annotationMode} Annotation`,
                    content: `This is a ${annotationMode} annotation`,
                    subject: `This is a ${annotationMode} annotation`,
                };
                console.log('Annotation:', annotationMode, annotation);
                if (['highlight', 'underline', 'strikeout'].includes(annotationMode)) {
                    // uniqueRects.forEach(() => {
                    storeTextAnnotation(annotationMode, annotation);
                    console.log("Annotation stored for page:", actualPageNum);

                    // });
                }

                textRedoStack = [];
                const annotationsMap = {};
                annotationsMap[annotationId] = annotation;
                console.log('Annotations Map:', annotationsMap);

                console.log('Annotations Before:', annotations);
                annotations.push(annotation);
                console.log('Annotations After :', annotations);
                annotationsToAdd.push(annotation);
                console.log('Annotations annotationtoadd:', annotationsToAdd);




                textUndoStack.push({ type: 'add', annotations: annotationsToAdd });
                textRedoStack = [];

                selection.removeAllRanges();
                //   annotationMode = null;

            });
        }
        // setupTextLayerEventListeners();



        function drawAnnotation(rect, mode, textLayerRect, pageWrapper) {
            console.log("Drawing annotation:", mode, rect);
            const canvas = pageWrapper.querySelector('.annotation-canvas');
            if (!canvas) {
                console.error("Annotation canvas not found");
                return;
            }
            console.log("Annotation canvas dimensions:", canvas.width, canvas.height);
            const ctx = canvas.getContext('2d');


            ctx.lineWidth = 1;
            ctx.strokeStyle = 'red';

            switch (mode) {
                case 'highlight':
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.fillRect(
                        rect.left - textLayerRect.left,
                        rect.top - textLayerRect.top,
                        rect.width,
                        rect.height
                    );
                    break;
                case 'underline':
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(
                        rect.left - textLayerRect.left,
                        rect.bottom - textLayerRect.top - 3
                    );
                    ctx.lineTo(
                        rect.right - textLayerRect.left,
                        rect.bottom - textLayerRect.top - 3
                    );
                    ctx.stroke();
                    break;
                case 'strikeout':
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(
                        rect.left - textLayerRect.left,
                        rect.top - textLayerRect.top + rect.height / 2 - 4
                    );
                    ctx.lineTo(
                        rect.right - textLayerRect.left,
                        rect.top - textLayerRect.top + rect.height / 2 - 4
                    );
                    ctx.stroke();
                    break;
            }


        }



        function drawAnnotationFromData(annotation) {
            const textLayer = document.getElementById('text-layer');
            if (!annotation.lineAnnotations || annotation.lineAnnotations.length === 0) {
                console.error('No lineAnnotations in annotation:', annotation);
                return;
            }
            const textLayerRect = textLayer.getBoundingClientRect();

            const canvas = document.getElementById('annotation-canvas');
            const ctx = canvas.getContext('2d');

            annotation.lineAnnotations.forEach((rect) => {
                const left = rect.left * currentScale;
                const top = rect.top * currentScale;
                const width = rect.width * currentScale;
                const height = rect.height * currentScale;

                switch (annotation.mode) {
                    case 'highlight':
                        drawHighlight({ left, top, width, height }, ctx);
                        break;
                    case 'underline':
                        drawLine({ left, top, width, height }, 'underline', ctx);
                        break;
                    case 'strikeout':
                        drawLine({ left, top, width, height }, 'strikeout', ctx);
                        break;
                }
            });
        }


        function applyAnnotation(span, mode) {
            const canvas = document.getElementById('annotation-canvas');
            if (!canvas) {
                console.error('Annotation canvas not found!');
                return;
            }

            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Failed to get 2D context for annotation canvas.');
                return;
            }

            switch (mode) {
                case 'highlight':
                    drawHighlight(span, ctx, canvas);
                    break;
                case 'underline':
                    drawLine(span, 'underline', ctx, canvas);
                    break;
                case 'strikeout':
                    drawLine(span, 'strikeout', ctx, canvas);
                    break;
            }
        }

        function initializeAnnotationCanvas(viewport, pageWrapper) {
            const annotationCanvas = pageWrapper.querySelector('.annotation-canvas');

            if (!annotationCanvas) {
                console.error('Annotation canvas not found!');
                return null;
            }

            annotationCanvas.width = viewport.width;
            annotationCanvas.height = viewport.height;
            annotationCanvas.style.position = 'absolute';
            annotationCanvas.style.top = '0';
            annotationCanvas.style.left = '0';
            annotationCanvas.style.pointerEvents = 'none';

            return annotationCanvas.getContext('2d');
        }

        function drawHighlight(rect, ctx) {
            ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
            ctx.fillRect(rect.left, rect.top, rect.width, rect.height);
        }

        function drawLine(rect, mode, ctx) {
            let lineY;

            if (mode === 'underline') {
                lineY = rect.top + rect.height - 2;
                ctx.strokeStyle = 'red';
            } else if (mode === 'strikeout') {
                lineY = rect.top + rect.height / 2 - 4;
            }

            ctx.strokeStyle = 'red';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(rect.left, lineY);
            ctx.lineTo(rect.left + rect.width, lineY);
            ctx.stroke();
        }


        function renderAnnotations(pageNum, ctx, viewport) {
            if (!annotationsByPage.hasOwnProperty(pageNum)) {
                console.log(`No annotations for page ${pageNum}, skipping render`);
                return;
            }

            let pageAnnotations = annotationsByPage[pageNum];
            console.log(`Rendering annotations specifically for page ${pageNum}:`, pageAnnotations);

            pageAnnotations = JSON.parse(JSON.stringify(pageAnnotations));

            ctx.clearRect(0, 0, viewport.width, viewport.height);

            if (!Array.isArray(pageAnnotations) || pageAnnotations.length === 0) {
                console.log(`No valid annotations for page ${pageNum}`);
                return;
            }

            pageAnnotations.forEach(annotation => {
                if (!annotation.lineAnnotations) {
                    console.log('Invalid annotation format:', annotation);
                    return;
                }

                annotation.lineAnnotations.forEach(rect => {
                    const left = rect.left * currentScale;
                    const top = rect.top * currentScale;
                    const width = rect.width * currentScale;
                    const height = rect.height * currentScale;

                    if (width > 0 && height > 0) {
                        switch (annotation.type) {
                            case 'highlight':
                                drawHighlight({ left, top, width, height }, ctx);
                                break;
                            case 'underline':
                                drawLine({ left, top, width, height }, 'underline', ctx);
                                break;
                            case 'strikeout':
                                drawLine({ left, top, width, height }, 'strikeout', ctx);
                                break;
                        }
                    }
                });
            });
        }

        function disableTextLayer() {
            const textLayerDiv = document.querySelector('.text-layer');
            if (textLayerDiv) {
                console.log('Disabling text layer');
                textLayerDiv.style.display = 'none';
            }
        }

        function enableTextLayer() {
            const textLayerDiv = document.querySelector('.text-layer');
            if (textLayerDiv) {
                console.log('Enabling text layer');
                textLayerDiv.style.display = 'block';
            }
        }



        //         function deleteSelectedAnnotation() {
        //     const activeObject = fabricCanvas.getActiveObject(); 

        //     if (activeObject) {
        //         const annotationIndex = annotationsByPage[pageNum]?.findIndex((ann) => ann.id === activeObject.id);

        //         if (annotationIndex !== -1) {
        //             annotationsByPage[pageNum].splice(annotationIndex, 1); 
        //             console.log("Annotation removed from annotationsByPage:", activeObject.id);
        //         }

        //         fabricCanvas.remove(activeObject); 
        //         console.log("Annotation deleted from canvas:", activeObject); 

        //         const sidebarItem = document.getElementById(`annotation-${activeObject.id}`);
        //         if (sidebarItem) {
        //             sidebarItem.remove();  
        //             console.log("Annotation removed from sidebar:", activeObject.id);
        //         }

        //         const isSelectionEnabled = document.getElementById('toggle-selection').checked;
        //         if (!isSelectionEnabled) {
        //             enableTextLayer();
        //         }

        //         fabricCanvas.renderAll();
        //     } else {
        //         console.log("No annotation selected to delete");
        //     }

        // }


        // document.getElementById('delete-annotation-btn').addEventListener('click', deleteSelectedAnnotation);

        // document.getElementById('toggle-selection').addEventListener('change', function () {
        //     const isChecked = this.checked;
        //     if (isChecked) {
        //         fabricCanvas.selection = true;
        //         fabricCanvas.forEachObject(obj => {
        //             obj.selectable = true;
        //         });
        //         disableTextLayer();
        //     } else {
        //         fabricCanvas.selection = false;
        //         fabricCanvas.forEachObject(obj => {
        //             obj.selectable = false;
        //         });
        //         enableTextLayer();
        //     }
        //     fabricCanvas.renderAll();
        // });

        let annotations = [];

        let currentAnnotationType = null;

        function setAnnotationMode(type) {
            currentAnnotationType = type;
            document.body.style.cursor = type ? 'text' : 'default';
        }

        function getScaleFactor() {
            return {
                x: pdfCanvas.width / fabricCanvas.getWidth(),
                y: pdfCanvas.height / fabricCanvas.getHeight(),
            };
        }

        function prevPage() {
            if (pageNum <= 1) return;
            pageNum--;
            renderAllPages();
        }
        function nextPage() {
            if (pageNum >= pdfDoc.numPages) return;
            pageNum++;
            renderAllPages();
        }

       





        function sendAnnotationToBackend(annotation) {
            console.log("Original annotation data:", annotation);

            fetch('/proxy/annotation', {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                },
                body: JSON.stringify(annotation)
            })
                .then(response => {
                    console.log("Response status:", response.status);
                    console.log("Response headers:", response.headers);
                    console.log("Full response:", response);

                    if (response.ok) {
                        return response.json().then(json => {
                            console.log("Response body (JSON):", json);
                        });
                    } else {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                })
                .catch(error => {
                    console.error("Error details:", {
                        message: error.message,
                        name: error.name,
                        stack: error.stack
                    });
                });
        }

        function generateGuid() {
            function s4() {
                return Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1);
            }
            return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
                s4() + '-' + s4() + s4() + s4();
        }


        let sessionDocumentId = generateGuid();
        let sessionUserId = generateGuid();

        function storeTextAnnotation(type, obj) {


            // console.log("Storing text annotation:", mode, annotation);

            const scaleFactor = getScaleFactor();
            const pageNumber = obj.page;
            console.log('storeTextAnnotation called for page:', pageNumber);

            if (!annotationsByPage[pageNumber]) {
                console.log('Initializing annotations array for page:', pageNumber);
                annotationsByPage[pageNumber] = [];
            }

            // const annotationExists = annotationsByPage[currentPageNum].find((ann) => ann.id === obj.id);
            // if (annotationExists) {
            //     console.warn("Annotation already exists:", obj.id);
            //     return; 
            // }
            obj.id = obj.id || Date.now() + Math.random().toString(36).substr(2, 9);
            const annotation = {
                userName: "Anurag Sable",
                id: generateGuid(),
                // mode:annotationMode,
                type: annotationMode,
                text: obj.text,
                startIndex: obj.startIndex,
                endIndex: obj.endIndex,
                lineAnnotations: obj.lineAnnotations,
                radius: obj.radius,
                page: pageNumber,
                title: `${annotationMode} Annotation`,
                content: `This is a ${annotationMode} annotation`,
                subject: `This is a ${annotationMode} annotation`,
                fontSize: obj.fontSize / Math.min(scaleFactor.x, scaleFactor.y),
                color: type === 'highlight' ? 'yellow' : undefined,
                stroke: type === 'underline' ? 'red' : type === 'strikeout' ? 'red' : undefined,
                strokeWidth: 1,
            };
            //  openAnnotationModal(annotation);

            if (type === "Highlight Annotation") {
                annotation.title = "Highlight Title";
                annotation.subject = "Highlight Subject";
                annotation.content = "This is a highligh annotation.";
                annotation.color = "yellow";
                annotation.opacity = 0.5;
            } else if (type === "Underline Annotation") {
                annotation.title = "Underline Title";
                annotation.subject = "Underline Subject";
                annotation.content = "This is a underline annotation.";
                annotation.stroke = "red";
                annotation.strokeWidth = 1;
            } else if (type === "Strikeout Annotation") {
                annotation.title = "Strike-out Title";
                annotation.subject = "Strike-out Subject";
                annotation.content = "This is a strike-out annotation.";
                annotation.stroke = "red";
                annotation.strokeWidth = 1;
                annotation.translateY = obj.height / 2;
            }
            annotationsByPage[pageNumber].push(annotation);

            const undoAction = {
                type: 'text',
                page: pageNumber,
                annotations: [annotation],
                timestamp: Date.now()
            };
            console.log("Adding text annotation to undo stack:", undoAction);
            addToUndoStack(undoAction);

            console.log("Stored Annotation:", annotation);
            console.log(`Stored annotation for page ${pageNumber}`, annotationsByPage);
            updateSidebar(annotation);

            // const sessionDocumentId = generateGuid();
            // const sessionUserId = generateGuid();
            const sessionCommentId = generateGuid();


            // const backendData = {
            //     DocumentId: sessionDocumentId,
            //     CommentList: [
            //         {
            //             UserId: sessionUserId,
            //             Comments: annotation.content,
            //             Remark: "Empty String",
            //             CommentDate: new Date().toISOString(),
            //             AnnotationType: annotation.type,
            //             PageNumber: annotation.page.toString(),
            //             Id: sessionCommentId,
            //             UserName: annotation.userName
            //         }
            //     ]
            // };

            // console.log("Backend Data:", backendData);

            // sendAnnotationToBackend(backendData);

        }


        function storeAnnotation(type, obj, pageNum) {
            pageNum = parseInt(pageNum, 10);
            const scaleFactor = getScaleFactor();
            if (!annotationsByPage[pageNum]) {
                annotationsByPage[pageNum] = [];
            }
            const annotationExists = annotationsByPage[pageNum].find((ann) => ann.id === obj.id);
            if (annotationExists) {
                console.warn("Annotation already exists:", obj.id);
                return;
            }
            const annotationId = generateGuid();
            obj.id = annotationId;

            const annotation = {
                UserName: "Anurag Sable",
                id: annotationId,
                type: type,
                x1: obj.left,
                y1: obj.top,
                x2: (obj.left + (obj.width || 0)),
                y2: (obj.top + (obj.height || 0)),
                radius: obj.radius / scaleFactor.x,
                page: pageNum,
                title: "",
                subject: "",
                content: type === 'text' ? obj.text : "Enter Text",
                fontSize: obj.fontSize / Math.min(scaleFactor.x, scaleFactor.y), // Use the smaller scale factor for font size
                color: type === 'highlight' ? 'yellow' : undefined,
                stroke: type === 'underline' ? 'red' : type === 'strikeout' ? 'black' : undefined,
            };
            openAnnotationModal(annotation);

            if (type === "square") {
                annotation.title = "Square Title";
                annotation.subject = "Square Subject";
                annotation.content = "This is a square annotation.";
                annotation.stroke = obj.stroke;
                annotation.strokeWidth = obj.strokeWidth;
            }
            else if (type === "circle") {
                annotation.title = "Circle Title";
                annotation.subject = "Circle Subject";
                annotation.content = "This is a circle annotation.";
                annotation.radius = obj.radius / scaleFactor.x;
                annotation.fill = obj.fill;
            } else if (type === "line") {
                annotation.title = "Line Title";
                annotation.subject = "Line Subject";
                annotation.content = "This is a line annotation.";
                annotation.x2 = obj.x2 / scaleFactor.x;
                annotation.y2 = obj.y2 / scaleFactor.y;
                annotation.stroke = obj.stroke;
                annotation.strokeWidth = obj.strokeWidth / scaleFactor.x;
            } if (type === "text") {
                annotation.subject = "Text Subject";
                annotation.title = "Text";
                annotation.text = obj.text || "";
                annotation.fontSize = obj.fontSize / scaleFactor.x;
                annotation.fill = obj.fill;
            }
            else if (type === "freeDraw") {
                annotation.title = "Free Draw Title";
                annotation.subject = "Free Draw Subject";
                annotation.content = "This is a Free Draw annotation.";
                annotation.path = obj.path;
                annotation.stroke = obj.stroke;
                annotation.strokeWidth = obj.strokeWidth / scaleFactor.x;
            } else if (type === "cloud") {
                annotation.title = "Cloud Annotation";
                annotation.subject = "Cloud Subject";
                annotation.content = "This is a cloud annotation.";
                annotation.path = obj.path;
                annotation.stroke = obj.stroke || 'red';
                annotation.strokeWidth = obj.strokeWidth || 2;
                annotation.annotationType = 'cloud'; // Explicitly set the annotation type
            } else if (type === "stamp") {
                annotation.title = "Stamp Annotation";
                annotation.subject = "Stamp Subject";
                annotation.content = "This is a stamp annotation.";
                annotation.imgSrc = obj.imgSrc || "";
                annotation.width = obj.width || 0;
                annotation.height = obj.height || 0;
            } else if (type === "signature") {
                annotation.title = "Signature Annotation";
                annotation.subject = "Signature Subject";
                annotation.content = "This is a signature annotation.";
                annotation.dataURL = obj.dataURL || "";
                annotation.width = obj.width || 0;
                annotation.height = obj.height || 0;
            }


            annotationsByPage[pageNum].push(annotation);
            console.log("Page Number:", pageNum, "Current Page:", currentPageNum);

            //             const sessionDocumentId = generateGuid();
            // const sessionUserId = generateGuid();
            const sessionCommentId = generateGuid();

            let objData;
            if (typeof obj.toObject === 'function') {
                objData = obj.toObject();
            } else {
                objData = {
                    ...obj,
                    type: type,
                    originX: 'center',
                    originY: 'center',
                    selectable: true,
                    evented: true
                };
            }
            objData.id = sessionUserId;
            objData.annotationType = type;

            const undoAction = {
                type: 'fabric',
                page: pageNum,
                object: objData,
                annotationData: annotation,
                timestamp: Date.now()
            };

            console.log("Adding fabric annotation to undo stack:", undoAction);
            addToUndoStack(undoAction)


            console.log("Stored Annotation:", annotation);
            updateSidebar(annotation);

            //         const backendData = {
            //     DocumentId: sessionDocumentId, 
            //     CommentList: [
            //         {
            //             UserId: sessionUserId, 
            //             Comments: annotation.content,
            //             Remark: "Empty",
            //             CommentDate: new Date().toISOString(),
            //             AnnotationType: annotation.type,
            //             PageNumber: annotation.page.toString(),
            //             Id:sessionCommentId,
            //             UserName: annotation.userName
            //         }
            //     ]
            // };

            // console.log("Backend Data:", backendData);

            // sendAnnotationToBackend(backendData);
        }

        // let currentAnnotationType = null;
        function addStamp(stampType) {
            if (currentAnnotationType !== null) {
                stopStampProcess();
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;
            currentAnnotationType = 'stamp';

            const stamps = {
                approve: 'static/images/Approved.png',
                notApprove: '/static/images/Rejected.png',
            };

            const selectedStamp = stamps[stampType];
            if (!selectedStamp) {
                console.error("Invalid stamp type selected!");
                isDrawing = false;
                enableTextLayer();
                return;
            }

            document.addEventListener('click', handleGlobalClick, true);

            document.addEventListener('keydown', escHandler);

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];
                if (!fabricCanvas) return;

                fabricCanvas.isDrawingMode = false;
                fabricCanvas.selection = true;
                fabricCanvas.defaultCursor = `url(${selectedStamp}) 16 16, auto`;

                if (fabricCanvas._stampMouseDownHandler) {
                    fabricCanvas.off('mouse:down', fabricCanvas._stampMouseDownHandler);
                }


                const onMouseDown = function (e) {
                    const pointer = fabricCanvas.getPointer(e.e);
                    fabric.Image.fromURL(selectedStamp, function (img) {
                        img.scale(0.6);
                        img.set({
                            id: generateUniqueId(),
                            left: pointer.x,
                            top: pointer.y,
                            originX: 'center',
                            originY: 'center',
                            selectable: true,
                            evented: true
                        });

                        fabricCanvas.add(img);
                        fabricCanvas.renderAll();
                        fabricUndoStack.push(img);

                        storeAnnotation('stamp', {
                            id: img.id,
                            left: img.left,
                            top: img.top,
                            width: img.getScaledWidth(),
                            height: img.getScaledHeight(),
                            imgSrc: selectedStamp
                        }, pageNumber);
                    });
                };

                fabricCanvas.on('mouse:down', onMouseDown);
                fabricCanvas._stampMouseDownHandler = onMouseDown;
            });
        }

        function handleGlobalClick(event) {
            if (event.target.closest('button') &&
                !event.target.closest('[onclick*="addSelectedStamp"]') &&
                !event.target.closest('#stampSelect')) {
                stopStampProcess();
                enableSelectMode();
            }
        }

        function stopStampProcess() {
            document.removeEventListener('click', handleGlobalClick, true);

            document.removeEventListener('keydown', escHandler);

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];
                if (fabricCanvas && fabricCanvas._stampMouseDownHandler) {
                    fabricCanvas.off('mouse:down', fabricCanvas._stampMouseDownHandler);
                    delete fabricCanvas._stampMouseDownHandler;
                    fabricCanvas.defaultCursor = 'default';
                }
            });

            isDrawing = false;
            currentAnnotationType = null;
            enableTextLayer();
        }

        function escHandler(event) {
            if (event.key === 'Escape') {
                stopStampProcess();
                enableSelectMode();
            }
        }

        function cancelAnnotation() {
            console.log("Canceling annotation...");
            window.getSelection().removeAllRanges();

            if (currentAnnotationType === 'stamp') {
                stopStampProcess();
            }

            annotationMode = null;
            fabricCanvas.isDrawingMode = false;
            isDrawing = false;
            currentAnnotationType = null;
            enableSelectMode();
        }

        function addSelectedStamp() {
            const stampType = document.getElementById('stampSelect').value;
            addStamp(stampType);
        }

        function openSignatureCanvas() {
            let canvasContainer = document.createElement('div');
            canvasContainer.id = 'signatureCanvasContainer';
            canvasContainer.style.position = 'fixed';
            canvasContainer.style.top = '0';
            canvasContainer.style.left = '0';
            canvasContainer.style.width = '100%';
            canvasContainer.style.height = '100%';
            canvasContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            canvasContainer.style.display = 'flex';
            canvasContainer.style.flexDirection = 'column';
            canvasContainer.style.justifyContent = 'center';
            canvasContainer.style.alignItems = 'center';

            let canvas = document.createElement('canvas');
            canvas.id = 'signatureCanvas';
            canvas.width = 1000;
            canvas.height = 400;
            canvas.style.backgroundColor = '#fff';
            canvas.style.border = '1px solid #000';
            canvasContainer.appendChild(canvas);

            let buttonContainer = document.createElement('div');
            buttonContainer.style.marginTop = '10px';

            let doneButton = document.createElement('button');
            doneButton.innerHTML = 'Done';
            doneButton.onclick = function () {
                console.log("Done button clicked");
                placeSignatureOnPDF(canvas);
                document.body.removeChild(canvasContainer);
            };
            buttonContainer.appendChild(doneButton);

            let cancelButton = document.createElement('button');
            cancelButton.innerHTML = 'Cancel';
            cancelButton.onclick = function () {
                document.body.removeChild(canvasContainer);
            };
            buttonContainer.appendChild(cancelButton);

            let clearButton = document.createElement('button');
            clearButton.innerHTML = 'Clear';
            clearButton.onclick = function () {
                clearSignature(canvas);
            };
            buttonContainer.appendChild(clearButton);



            let saveButton = document.createElement('button');
            saveButton.innerHTML = 'Save Signature';
            saveButton.onclick = function () {
                saveSignature(canvas);
            };
            buttonContainer.appendChild(saveButton);

            let uploadButton = document.createElement('button');
            uploadButton.innerHTML = 'Upload Signature';
            uploadButton.onclick = function () {
                let input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = function (e) {
                    let file = e.target.files[0];
                    if (file) {
                        let reader = new FileReader();
                        reader.onload = function (event) {
                            let img = new Image();
                            img.onload = function () {
                                let ctx = canvas.getContext('2d');
                                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas first
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height); // Draw image
                            };
                            img.src = event.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                };
                input.click();
            };
            buttonContainer.appendChild(uploadButton);

            let colorSelect = document.createElement('select');
            colorSelect.innerHTML = `<option value="black">Black</option>
                             <option value="red">Red</option>
                             <option value="blue">Blue</option>`;
            colorSelect.onchange = function () {
                ctx.strokeStyle = colorSelect.value;
            };
            buttonContainer.appendChild(colorSelect);

            let thicknessSelect = document.createElement('select');
            thicknessSelect.innerHTML = `<option value="5">5px</option>
                                 <option value="10">10px</option>
                                 <option value="15">15px</option>`;
            thicknessSelect.onchange = function () {
                ctx.lineWidth = parseInt(thicknessSelect.value, 10);
            };
            buttonContainer.appendChild(thicknessSelect);

            canvasContainer.appendChild(buttonContainer);
            document.body.appendChild(canvasContainer);

            let ctx = canvas.getContext('2d');

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 5;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            let isDrawing = false;

            canvas.addEventListener('mousedown', function (e) {
                isDrawing = true;
                ctx.moveTo(e.offsetX, e.offsetY);
                ctx.beginPath();
            });

            canvas.addEventListener('mousemove', function (e) {
                if (isDrawing) {
                    ctx.lineTo(e.offsetX, e.offsetY);
                    ctx.stroke();
                }
            });

            canvas.addEventListener('mouseup', function () {
                isDrawing = false;
            });

            canvas.addEventListener('mouseout', function () {
                isDrawing = false;
            });
        }
        function clearSignature(canvas) {
            let ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        function resetSignature(canvas) {
            clearSignature(canvas);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 5;
        }

        function saveSignature(canvas) {
            const dataURL = canvas.toDataURL();
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'signature.png';
            a.click();
        }



        function placeSignatureOnPDF(signatureCanvas) {
            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];
                disableTextLayer();
                resetDrawingState();
                const signatureDataURL = signatureCanvas.toDataURL();
                fabric.Image.fromURL(signatureDataURL, function (img) {

                    const SigniturescaleFactor = 0.4;
                    const uniqueId = generateUniqueId();
                    img.scale(SigniturescaleFactor);

                    let isSignaturePlaced = false;

                    fabricCanvas.on('mouse:down', function (event) {
                        if (!isSignaturePlaced && !event.target) {
                            const pointer = fabricCanvas.getPointer(event.e);


                            img.set({
                                id: uniqueId,
                                left: pointer.x,
                                top: pointer.y,
                                originX: 'center',
                                originY: 'center',
                                selectable: true,
                                evented: true
                            });
                            console.log("Stamp placed at:", pointer.x, pointer.y);

                            fabricCanvas.add(img);
                            fabricCanvas.renderAll();
                            isSignaturePlaced = true;
                            fabricUndoStack.push(img);

                            storeAnnotation('signature', {
                                id: uniqueId,
                                left: img.left,
                                top: img.top,
                                width: img.getScaledWidth(),
                                height: img.getScaledHeight(),
                                dataURL: signatureDataURL
                            }, pageNumber);

                            console.log("Signature placed on PDF at:", pointer);


                        }
                    });

                    console.log("Click on the PDF to place the signature.");
                    enableTextLayer();
                });
            });
        }


        function addCloudAnnotation() {
            console.log("Activating Cloud Annotation Mode");

            if (isDrawing) {
                console.log("Already in drawing mode, ignoring duplicate click.");
                return;
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;

            let eventHandlers = {};

            const cloudColor = 'red';
            const cloudStrokeWidth = 2;
            const cloudRadius = 20;
            const humpSize = 30;

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];

                if (!fabricCanvas) {
                    console.error("Fabric.js canvas is not initialized for this page.");
                    return;
                }

                let polygonPoints = [];
                let tempPath = null;

                function cleanupListeners() {
                    fabricCanvas.off('mouse:down', eventHandlers[pageNumber]?.onMouseDown);
                    fabricCanvas.off('mouse:move', eventHandlers[pageNumber]?.onMouseMove);
                    fabricCanvas.off('mouse:dblclick', eventHandlers[pageNumber]?.onMouseDblClick);
                    enableTextLayer();
                }

                eventHandlers[pageNumber] = {
                    onMouseDown(e) {
                        const pointer = fabricCanvas.getPointer(e.e);
                        if (polygonPoints.length === 0) {
                            polygonPoints.push(new Point(pointer.x, pointer.y));
                        } else {
                            polygonPoints.push(new Point(pointer.x, pointer.y));
                        }
                        updateCloudPreview();
                    },

                    onMouseMove(e) {
                        if (polygonPoints.length < 1) return;

                        const pointer = fabricCanvas.getPointer(e.e);
                        const lastPoint = polygonPoints[polygonPoints.length - 1];

                        if (pointer.x !== lastPoint.x || pointer.y !== lastPoint.y) {
                            updateCloudPreview(pointer.x, pointer.y);
                        }
                    },

                    onMouseDblClick() {
                        if (polygonPoints.length < 2) return;

                        polygonPoints.push(polygonPoints[0]);

                        const finalPath = generateCloudPath(polygonPoints, cloudRadius, humpSize);
                        const cloudPath = new fabric.Path(finalPath, {
                            fill: 'transparent',
                            stroke: cloudColor,
                            strokeWidth: cloudStrokeWidth,
                            selectable: true,
                            annotationType: 'cloud',
                            perPixelTargetFind: true,
                            objectCaching: false,
                            strokeLineJoin: 'round',
                            strokeLineCap: 'round',
                            cloudPoints: polygonPoints,
                            cloudRadius: cloudRadius,
                            cloudHumpSize: humpSize
                        });

                        fabricCanvas.add(cloudPath);

                        if (tempPath) fabricCanvas.remove(tempPath);
                        tempPath = null;
                        polygonPoints = [];

                        storeAnnotation("cloud", {
                            ...cloudPath.toObject(),
                            cloudPoints: polygonPoints,
                            pathData: finalPath,
                            type: 'cloud'
                        }, pageNumber);

                        isDrawing = false;

                        Object.keys(fabricCanvases).forEach((page) => {
                            let canvas = fabricCanvases[page];
                            if (canvas) cleanupListeners();
                        });
                    }
                };

                function updateCloudPreview(tempX, tempY) {
                    if (polygonPoints.length < 1) return;

                    const previewPoints = [...polygonPoints];
                    if (tempX !== undefined && tempY !== undefined) {
                        previewPoints.push(new Point(tempX, tempY));
                    }

                    const pathData = generateCloudPath(previewPoints, cloudRadius, humpSize);
                    if (tempPath) fabricCanvas.remove(tempPath);

                    tempPath = new fabric.Path(pathData, {
                        fill: 'transparent',
                        stroke: cloudColor,
                        strokeWidth: cloudStrokeWidth,
                        selectable: false,
                    });

                    fabricCanvas.add(tempPath);
                }

                fabricCanvas.on('mouse:down', eventHandlers[pageNumber].onMouseDown);
                fabricCanvas.on('mouse:move', eventHandlers[pageNumber].onMouseMove);
                fabricCanvas.on('mouse:dblclick', eventHandlers[pageNumber].onMouseDblClick);
            });

            function generateCloudPath(points, cloudRadius, humpSize) {
                if (points.length < 2) return '';
                const pathData = [];
                let prev = points[points.length - 1];
                const delta = 2 * cloudRadius * 0.7;
                const circlePoints = [];
                for (let i = 0; i < points.length; i++) {
                    const curr = points[i];
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    const n = Math.max(1, Math.floor(len / delta));
                    for (let j = 0; j <= n; j++) {
                        circlePoints.push(new Point(prev.x + j * (dx / n), prev.y + j * (dy / n)));
                    }
                    prev = curr;
                }
                prev = circlePoints[circlePoints.length - 1];
                for (let i = 0; i < circlePoints.length; i++) {
                    const curr = circlePoints[i];
                    pathData.push(`M ${prev.x} ${prev.y}`);
                    pathData.push(`A ${cloudRadius},${cloudRadius} 0 0,1 ${curr.x},${curr.y}`);
                    prev = curr;
                }
                return pathData.join(' ');
            }

            function Point(x, y) {
                this.x = x;
                this.y = y;
            }
        }





        function addSquare() {
            console.log("Current Page:", pageNum);
            console.log("Available Fabric Canvases:", fabricCanvases);

            if (isDrawing) {
                console.log("Already in drawing mode, ignoring duplicate click.");
                return;
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;

            let eventHandlers = {};

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];
                console.log("Fabric Canvas for Page:", pageNumber);

                if (!fabricCanvas) {
                    console.error("Fabric.js canvas is not initialized for this page.");
                    return;
                }

                fabricCanvas.isDrawingMode = false;
                fabricCanvas.selection = true;

                let rect = null;
                let origX, origY;

                eventHandlers[pageNumber] = {
                    onMouseDown(e) {
                        const pointer = fabricCanvas.getPointer(e.e);
                        origX = pointer.x;
                        origY = pointer.y;

                        rect = new fabric.Rect({
                            left: origX,
                            top: origY,
                            width: 0,
                            height: 0,
                            fill: '',
                            stroke: 'red',
                            strokeWidth: 2,
                            annotationType: 'square',
                            id: Date.now() + Math.random().toString(36).substr(2, 9),
                        });
                        fabricCanvas.add(rect);
                    },

                    onMouseMove(e) {
                        if (!rect) return;
                        const pointer = fabricCanvas.getPointer(e.e);

                        // Calculate width and height based on mouse position
                        let width = pointer.x - origX;
                        let height = pointer.y - origY;

                        // Update left and top if drawing in negative direction
                        if (width < 0) {
                            rect.set('left', origX + width);
                            width = Math.abs(width);
                        }
                        if (height < 0) {
                            rect.set('top', origY + height);
                            height = Math.abs(height);
                        }

                        rect.set({
                            width: width,
                            height: height
                        });

                        fabricCanvas.renderAll();
                    },

                    onMouseUp() {
                        if (!rect) return;
                        console.log(`Square drawn on page ${pageNumber}:`, rect);

                        storeAnnotation('square', rect, pageNumber);

                        isDrawing = false;

                        Object.keys(fabricCanvases).forEach((page) => {
                            let canvas = fabricCanvases[page];
                            if (canvas && eventHandlers[page]) {
                                canvas.off('mouse:down', eventHandlers[page].onMouseDown);
                                canvas.off('mouse:move', eventHandlers[page].onMouseMove);
                                canvas.off('mouse:up', eventHandlers[page].onMouseUp);
                            }
                        });

                        enableTextLayer();
                    }
                };

                fabricCanvas.on('mouse:down', eventHandlers[pageNumber].onMouseDown);
                fabricCanvas.on('mouse:move', eventHandlers[pageNumber].onMouseMove);
                fabricCanvas.on('mouse:up', eventHandlers[pageNumber].onMouseUp);
            });
        }


        function addLine() {
            console.log("Adding Line Annotations");

            if (isDrawing) {
                console.log("Already in drawing mode, ignoring duplicate click.");
                return;
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;

            let eventHandlers = {};

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];

                if (!fabricCanvas) {
                    console.error("Fabric.js canvas is not initialized for this page.");
                    return;
                }

                fabricCanvas.isDrawingMode = false;
                fabricCanvas.selection = false;

                let line = null;
                let startX, startY;

                eventHandlers[pageNumber] = {
                    onMouseDown(e) {
                        const pointer = fabricCanvas.getPointer(e.e);
                        startX = pointer.x;
                        startY = pointer.y;

                        line = new fabric.Line([startX, startY, startX, startY], {
                            stroke: 'red',
                            strokeWidth: 2,
                            selectable: true,
                            evented: true,
                            annotationType: 'line',
                            id: Date.now() + Math.random().toString(36).substr(2, 9),
                        });

                        fabricCanvas.add(line);
                    },

                    onMouseMove(e) {
                        if (!line) return;
                        const pointer = fabricCanvas.getPointer(e.e);

                        line.set({ x2: pointer.x, y2: pointer.y });
                        fabricCanvas.renderAll();
                    },

                    onMouseUp() {
                        if (!line) return;

                        line.set({ selectable: true, evented: true });
                        line.setCoords();

                        console.log(`Line drawn on page ${pageNumber}:`, line);

                        storeAnnotation('line', line, pageNumber);

                        isDrawing = false;

                        Object.keys(fabricCanvases).forEach((page) => {
                            let canvas = fabricCanvases[page];
                            if (canvas && eventHandlers[page]) {
                                canvas.off('mouse:down', eventHandlers[page].onMouseDown);
                                canvas.off('mouse:move', eventHandlers[page].onMouseMove);
                                canvas.off('mouse:up', eventHandlers[page].onMouseUp);
                            }
                        });

                        enableTextLayer();
                    }
                };

                fabricCanvas.on('mouse:down', eventHandlers[pageNumber].onMouseDown);
                fabricCanvas.on('mouse:move', eventHandlers[pageNumber].onMouseMove);
                fabricCanvas.on('mouse:up', eventHandlers[pageNumber].onMouseUp);
            });
        }


        function addCircle() {
            console.log("Adding Circle Annotations");

            if (isDrawing) {
                console.log("Already in drawing mode, ignoring duplicate click.");
                return;
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;

            let eventHandlers = {};

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];

                if (!fabricCanvas) {
                    console.error("Fabric.js canvas is not initialized for this page.");
                    return;
                }

                fabricCanvas.isDrawingMode = false;
                fabricCanvas.selection = true;

                let circle = null;
                let originX, originY;

                eventHandlers[pageNumber] = {
                    onMouseDown(e) {
                        const pointer = fabricCanvas.getPointer(e.e);
                        originX = pointer.x;
                        originY = pointer.y;

                        circle = new fabric.Circle({
                            left: originX,
                            top: originY,
                            radius: 0,
                            fill: '',
                            stroke: 'red',
                            strokeWidth: 2,
                            annotationType: 'circle',
                            id: Date.now() + Math.random().toString(36).substr(2, 9),
                            selectable: true,
                            evented: true,
                        });

                        fabricCanvas.add(circle);
                    },

                    onMouseMove(e) {
                        if (!circle) return;
                        const pointer = fabricCanvas.getPointer(e.e);

                        const radius = Math.sqrt(
                            Math.pow(pointer.x - originX, 2) + Math.pow(pointer.y - originY, 2)
                        ) / 2;

                        const centerX = (pointer.x + originX) / 2;
                        const centerY = (pointer.y + originY) / 2;

                        circle.set({
                            radius: radius,
                            left: centerX - radius,
                            top: centerY - radius,
                        });

                        fabricCanvas.renderAll();
                    },

                    onMouseUp() {
                        if (!circle) return;

                        circle.setCoords();
                        console.log(`Circle drawn on page ${pageNumber}:`, circle);

                        storeAnnotation('circle', circle, pageNumber);

                        isDrawing = false;

                        Object.keys(fabricCanvases).forEach((page) => {
                            let canvas = fabricCanvases[page];
                            if (canvas && eventHandlers[page]) {
                                canvas.off('mouse:down', eventHandlers[page].onMouseDown);
                                canvas.off('mouse:move', eventHandlers[page].onMouseMove);
                                canvas.off('mouse:up', eventHandlers[page].onMouseUp);
                            }
                        });

                        enableTextLayer();
                    }
                };

                fabricCanvas.on('mouse:down', eventHandlers[pageNumber].onMouseDown);
                fabricCanvas.on('mouse:move', eventHandlers[pageNumber].onMouseMove);
                fabricCanvas.on('mouse:up', eventHandlers[pageNumber].onMouseUp);
            });
        }

        function addText() {
            console.log("Adding Text Annotation");

            if (isDrawing) {
                console.log("Already in drawing mode, ignoring duplicate click.");
                return;
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;

            let eventHandlers = {};

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];

                if (!fabricCanvas) {
                    console.error("Fabric.js canvas is not initialized for this page.");
                    return;
                }

                fabricCanvas.isDrawingMode = false;
                fabricCanvas.selection = true;

                let textObj = null;
                let startX = 0, startY = 0;

                eventHandlers[pageNumber] = {
                    onMouseDown(e) {
                        const pointer = fabricCanvas.getPointer(e.e);
                        startX = pointer.x;
                        startY = pointer.y;

                        textObj = new fabric.Textbox('Enter text', {
                            left: startX,
                            top: startY,
                            fontSize: 14,
                            fill: 'black',
                            editable: true,
                            id: `text-${Date.now()}`,
                        });

                        fabricCanvas.add(textObj);
                    },

                    onMouseMove(e) {
                        if (!textObj) return;
                        const pointer = fabricCanvas.getPointer(e.e);

                        const distance = Math.sqrt(
                            Math.pow(pointer.x - startX, 2) + Math.pow(pointer.y - startY, 2)
                        );

                        const newFontSize = Math.max(10, Math.min(50, distance / 2));
                        textObj.set({ fontSize: newFontSize });
                        fabricCanvas.renderAll();
                    },

                    onMouseUp() {
                        if (!textObj) return;

                        console.log(`Text annotation added on page ${pageNumber}:`, textObj);

                        storeAnnotation('text', textObj, pageNumber);

                        textObj.on('changed', () => {
                            updateStoredAnnotation(textObj.id, { text: textObj.text });
                        });

                        isDrawing = false;

                        Object.keys(fabricCanvases).forEach((page) => {
                            let canvas = fabricCanvases[page];
                            if (canvas && eventHandlers[page]) {
                                canvas.off('mouse:down', eventHandlers[page].onMouseDown);
                                canvas.off('mouse:move', eventHandlers[page].onMouseMove);
                                canvas.off('mouse:up', eventHandlers[page].onMouseUp);
                            }
                        });

                        enableTextLayer();
                    }
                };

                fabricCanvas.on('mouse:down', eventHandlers[pageNumber].onMouseDown);
                fabricCanvas.on('mouse:move', eventHandlers[pageNumber].onMouseMove);
                fabricCanvas.on('mouse:up', eventHandlers[pageNumber].onMouseUp);
            });
        }


        function updateStoredAnnotation(id, updates) {
            for (let page in annotationsByPage) {
                const annotation = annotationsByPage[page].find(ann => ann.id === id);
                if (annotation) {
                    Object.assign(annotation, updates);

                    if (updates.text) {
                        annotation.content = updates.text;
                    }

                    console.log("Updated Annotation:", annotation);
                    break;
                }
            }
        }

        function addFreeDraw() {
            console.log("Activating Free Draw Mode");

            if (isDrawing) {
                console.log("Already in drawing mode, ignoring duplicate click.");
                return;
            }

            disableTextLayer();
            resetDrawingState();
            isDrawing = true;

            let eventHandlers = {};

            Object.keys(fabricCanvases).forEach((pageNumber) => {
                let fabricCanvas = fabricCanvases[pageNumber];

                if (!fabricCanvas) {
                    console.error("Fabric.js canvas is not initialized for this page.");
                    return;
                }

                fabricCanvas.isDrawingMode = true;
                fabricCanvas.freeDrawingBrush.color = "red";
                fabricCanvas.freeDrawingBrush.width = 2;

                eventHandlers[pageNumber] = {
                    onPathCreated(e) {
                        const path = e.path;
                        console.log(`Free draw annotation added on page ${pageNumber}:`, path);

                        storeAnnotation("freeDraw", path, pageNumber);

                        isDrawing = false;

                        Object.keys(fabricCanvases).forEach((page) => {
                            let canvas = fabricCanvases[page];
                            if (canvas) {
                                canvas.isDrawingMode = false;
                                canvas.off("path:created", eventHandlers[page]?.onPathCreated);
                            }
                        });

                        enableTextLayer();
                    }
                };

                fabricCanvas.on("path:created", eventHandlers[pageNumber].onPathCreated);
            });
        }


        //Shows error 
        // document.getElementById('toggle-free-draw').addEventListener('click', enableFreeDraw);

        fabricCanvas.on('object:modified', function (e) {
            const obj = e.target;
            if (obj && annotationsByPage[pageNum]) {
                const pageAnnotations = annotationsByPage[pageNum];
                const annotationIndex = pageAnnotations.findIndex(ann => ann.id === obj.id);
                if (annotationIndex !== -1) {
                    const annotation = pageAnnotations[annotationIndex];
                    annotation.x1 = obj.left;
                    annotation.y1 = obj.top;
                    if (obj.type === 'textbox') {
                        annotation.text = obj.text;
                        annotation.x2 = obj.left + obj.width;
                        annotation.y2 = obj.top + obj.height;
                    } else if (obj.type === 'rect') {
                        annotation.x2 = obj.left + obj.width;
                        annotation.y2 = obj.top + obj.height;
                    } else if (obj.type === 'circle') {
                        annotation.radius = obj.radius;
                    } else if (obj.type === 'line') {
                        annotation.x2 = obj.x2;
                        annotation.y2 = obj.y2;
                    }
                    annotationsByPage[pageNum][annotationIndex] = annotation;
                }
            }
        });

        document.addEventListener('keydown', function (event) {
            if (event.ctrlKey || event.metaKey) {
                switch (event.key.toLowerCase()) {
                    case 'z':
                        event.preventDefault();
                        if (event.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                        break;

                    case 'y':
                        event.preventDefault();
                        redo();
                        break;
                }
            }
        });


        let fabricUndoStack = [];
        let fabricRedoStack = [];
        let textUndoStack = [];
        let textRedoStack = [];
        let undoStack = [];
        // let redoStack = [];

        function addToUndoStack(action) {
            if (!action || !action.type || !action.timestamp) {
                console.error("Invalid action format:", action);
                return;
            }

            undoStack.push(action);
            redoStack = [];
            console.log("Successfully added to undo stack:", action);
            console.log("Current undo stack:", undoStack);
            console.log("Current undo stack size:", undoStack.length);
        }


        function undo() {
            console.log("Current undo stack before undo:", undoStack);

            if (undoStack.length === 0) {
                console.log("Nothing to undo");
                showToast('Nothing to undo');
                return;
            }

            const lastAction = undoStack.pop();
            console.log("Undoing action:", lastAction);
            redoStack.push(lastAction);

            if (lastAction.type === 'fabric') {
                const pageNum = lastAction.page;
                const canvas = fabricCanvases[pageNum];

                if (canvas) {
                    const objectToRemove = canvas.getObjects().find(obj => obj.id === lastAction.annotationData.id);
                    if (objectToRemove) {
                        canvas.remove(objectToRemove);
                        canvas.renderAll();
                    }

                    if (annotationsByPage[pageNum]) {
                        annotationsByPage[pageNum] = annotationsByPage[pageNum].filter(
                            ann => ann.id !== lastAction.annotationData.id
                        );
                    }
                }
                renderPage(pageNum);
            } else if (lastAction.type === 'text') {
                lastAction.annotations.forEach(annotation => {
                    const pageNum = annotation.page;

                    if (annotationsByPage[pageNum]) {
                        annotationsByPage[pageNum] = annotationsByPage[pageNum].filter(
                            ann => ann.id !== annotation.id
                        );
                    }

                    renderPageAnnotations(pageNum);
                });
            }

            refreshSidebar();
            showToast('Undo successful');

            // updatePDFAnnotations();
        }

        function redo() {
            if (redoStack.length === 0) {
                console.log("Nothing to redo");
                showToast('Nothing to redo');

                return;
            }

            const lastAction = redoStack.pop();
            console.log("Redoing action:", lastAction);
            undoStack.push(lastAction);

            if (lastAction.type === 'fabric') {
                const pageNum = lastAction.page;
                const canvas = fabricCanvases[pageNum];

                if (canvas) {
                    let newObj;
                    const objData = lastAction.object;

                    switch (objData.type) {
                        case 'rect':
                            newObj = new fabric.Rect(objData);
                            break;
                        case 'circle':
                            newObj = new fabric.Circle(objData);
                            break;
                        case 'line':
                            newObj = new fabric.Line([objData.x1, objData.y1, objData.x2, objData.y2], objData);
                            break;
                        case 'path':
                            newObj = new fabric.Path(objData.path, objData);
                            break;
                        case 'textbox':
                            newObj = new fabric.Textbox(objData.text || '', objData);
                            break;
                        case 'cloud':
                            // Create new cloud path with stored data
                            newObj = new fabric.Path(objData.path || objData.pathData, {
                                fill: 'transparent',
                                stroke: objData.stroke || 'red',
                                strokeWidth: objData.strokeWidth || 2,
                                selectable: true,
                                evented: true,
                                id: objData.id,
                                annotationType: 'cloud',
                                perPixelTargetFind: true,
                                objectCaching: false,
                                strokeLineJoin: 'round',
                                strokeLineCap: 'round',
                                cloudPoints: objData.cloudPoints,
                                cloudRadius: objData.cloudRadius,
                                cloudHumpSize: objData.cloudHumpSize
                            });
                            break;
                        case 'stamp':
                            fabric.Image.fromURL(objData.imgSrc, function (img) {
                                img.set({
                                    left: objData.left,
                                    top: objData.top,
                                    scaleX: 0.6,
                                    scaleY: 0.6,
                                    originX: 'center',
                                    originY: 'center',
                                    selectable: true,
                                    evented: true,
                                    id: objData.id,
                                    annotationType: objData.annotationType
                                });
                                canvas.add(img);
                                canvas.renderAll();

                                if (!annotationsByPage[pageNum]) {
                                    annotationsByPage[pageNum] = [];
                                }
                                annotationsByPage[pageNum].push(lastAction.annotationData);
                                updateSidebar(lastAction.annotationData);
                            });
                            return;
                        case 'signature':
                            fabric.Image.fromURL(objData.dataURL, function (img) {
                                img.set({
                                    left: objData.left,
                                    top: objData.top,
                                    scaleX: 0.4,
                                    scaleY: 0.4,
                                    originX: 'center',
                                    originY: 'center',
                                    selectable: true,
                                    evented: true,
                                    id: objData.id,
                                    annotationType: objData.annotationType
                                });
                                canvas.add(img);
                                canvas.renderAll();

                                if (!annotationsByPage[pageNum]) {
                                    annotationsByPage[pageNum] = [];
                                }
                                annotationsByPage[pageNum].push(lastAction.annotationData);
                                updateSidebar(lastAction.annotationData);
                            });
                            return;
                        default:
                            console.error('Unknown object type:', objData.type);
                            return;
                    }
                    if (newObj) {
                        newObj.id = objData.id;
                        newObj.annotationType = objData.annotationType;
                        canvas.add(newObj);
                        canvas.renderAll();

                        if (!annotationsByPage[pageNum]) {
                            annotationsByPage[pageNum] = [];
                        }
                        annotationsByPage[pageNum].push(lastAction.annotationData);
                    }
                }
            }

            else if (lastAction.type === 'text') {
                lastAction.annotations.forEach(annotation => {
                    const pageNum = annotation.page;

                    if (!annotationsByPage[pageNum]) {
                        annotationsByPage[pageNum] = [];
                    }
                    annotationsByPage[pageNum].push(annotation);

                    renderPageAnnotations(pageNum);
                });
            }

            refreshSidebar();
            // updatePDFAnnotations();
            showToast('Redo successful');

        }

        function showToast(message) {
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                document.body.appendChild(toastContainer);
            }

            const toast = document.createElement('div');
            toast.className = 'toast';

            const icon = message.toLowerCase().includes('success') ? '✓' :
                message.toLowerCase().includes('nothing') ? 'ℹ' : '!';

            toast.innerHTML = `
        <span class="toast-icon">${icon}</span>
        <span class="toast-message">${message}</span>
    `;

            toastContainer.appendChild(toast);

            requestAnimationFrame(() => {
                toast.classList.add('show');
            });

            setTimeout(() => {
                toast.classList.add('fade-out');
                setTimeout(() => {
                    if (toastContainer.contains(toast)) {
                        toastContainer.removeChild(toast);
                    }
                }, 500);
            }, 3000);
        }

        function renderPageAnnotations(pageNum) {
            const pageWrapper = document.querySelector(`[data-page-number="${pageNum}"]`);
            if (pageWrapper) {
                const annotationCanvas = pageWrapper.querySelector('.annotation-canvas');
                if (annotationCanvas) {
                    const ctx = annotationCanvas.getContext('2d');
                    const viewport = {
                        width: annotationCanvas.width,
                        height: annotationCanvas.height
                    };
                    renderAnnotations(pageNum, ctx, viewport);
                }
            }
        }

        // function addToUndoStack(fabricObject, pageNumber) {
        //     if (!fabricUndoStack[pageNumber]) {
        //         fabricUndoStack[pageNumber] = [];
        //     }

        //     // Add timestamp to the object
        //     fabricObject.timestamp = Date.now();

        //     fabricUndoStack[pageNumber].push({
        //         object: fabricObject,
        //         page: pageNumber,
        //         timestamp: fabricObject.timestamp
        //     });

        //     // Clear redo stack for this page
        //     fabricRedoStack[pageNumber] = [];
        // }

        // function updatePDFAnnotations() {
        //     // Combine Fabric.js and text-layer annotations

        //     if (annotationsByPage[currentPageNum]) {
        //         console.log("Annotations By Page after Redo:", annotationsByPage[currentPageNum]);
        //         allAnnotations.push(...annotationsByPage[currentPageNum]);
        //     }

        //     console.log("Annotations for PDF:", allAnnotations);
        //     saveAnnotationsToPDF(allAnnotations);
        // }

        function saveAnnotationsToPDF(annotations) {
            if (annotations.length === 0) {
                console.warn("No annotations to save!");
                return;
            }
            console.log("Saving Annotations:", annotations);
        }


        function refreshSidebar() {
            const annotationList = document.getElementById("annotationList");
            annotationList.innerHTML = "";

            Object.values(annotationsByPage).flat().forEach(annotation => {
                updateSidebar(annotation);
            });
        }


        // function save() {
        //     // showToast('Saving annotations...');

        //     const annotations = [];
        //     Object.keys(annotationsByPage).forEach(pageNum => {
        //         annotations.push(...annotationsByPage[pageNum]);
        //     });

        //     fabricCanvas.getObjects().forEach(obj => {
        //         if (!obj.id || annotations.find(ann => ann.id === obj.id)) {
        //             return; 
        //         }

        //         console.log("Object on canvas:", obj); 
        //         if (obj.type === 'textbox') {
        //             console.log("Saving textbox object:", obj); 
        //             annotations.push({
        //         id: obj.id,
        //         type: 'text',
        //         page: pageNum,
        //         x1: obj.left,
        //         y1: obj.top,
        //         x2: obj.left + obj.width * obj.scaleX,  
        //         y2: obj.top + obj.height * obj.scaleY,  
        //         text: obj.text || "Enter Text",
        //         fontSize: obj.fontSize,
        //         fontFamily: obj.fontFamily || 'Arial',
        //         fill: obj.fill || 'black',
        //         title: "Text Annotation",
        //         subject: "Text",
        //         content: obj.text || "Enter Text",
        //         strokeWidth: obj.strokeWidth || 1,
        //         selectable: true,
        //         evented: true
        //     });
        //         } else if (obj.annotationType === 'highlight') {
        //             annotations.push({
        //                 type: 'highlight',
        //                 page: pageNum,
        //                 x1: obj.left,
        //                 y1: obj.top,
        //                 x2: obj.left + obj.width,
        //                 y2: obj.top + obj.height,
        //                 fill: obj.fill,
        //             });
        //         } else if (obj.annotationType === 'underline') {
        //             annotations.push({
        //                 type: 'underline',
        //                 page: pageNum,
        //                 x1: obj.left,
        //                 y1: obj.top,
        //                 x2: obj.left + obj.width,
        //                 y2: obj.top + obj.height,
        //             });
        //         } else if (obj.annotationType === 'strikeout') {
        //             annotations.push({
        //                 type: 'strikeout',
        //                 page: pageNum,
        //                 x1: obj.left,
        //                 y1: obj.top,
        //                 x2: obj.left + obj.width,
        //                 y2: obj.top + obj.height,
        //                 stroke: obj.stroke,
        //                 strokeWidth: obj.strokeWidth,

        //             });
        //         }
        //         else if (obj.annotationType === 'square') {
        //             annotations.push({
        //                 id: obj.id,
        //                 type: 'square',
        //                 page: pageNum,
        //                 x1: obj.left,
        //                 y1: obj.top,
        //                 x2: obj.left + obj.width,
        //                 y2: obj.top + obj.height,
        //                 stroke: obj.stroke,
        //                 strokeWidth: obj.strokeWidth,
        //                 title: "Square Annotation",
        //                 subject: "Square Subject",
        //                 content: "This is a square annotation."
        //             });
        //         } else if (obj.type === 'circle') {
        //             annotations.push({
        //                 type: 'circle',
        //                 page: pageNum, 
        //                 x1: obj.left,
        //                 y1: obj.top,
        //                 radius: obj.radius,
        //                 fill: obj.fill,
        //                 stroke: obj.stroke,
        //                 strokeWidth: obj.strokeWidth,
        //                 title: "Circle ",  
        //                 subject: "Circle Subject",  
        //                 content: "This is a circle annotation."  
        //             });
        //         } else if (obj.type === 'line') {
        //             annotations.push({
        //                 type: 'line',
        //                 page: pageNum, 
        //                 x1: obj.x1,
        //                 y1: obj.y1,
        //                 x2: obj.x2,
        //                 y2: obj.y2,
        //                 stroke: obj.stroke,
        //                 strokeWidth: obj.strokeWidth,
        //                 title: "Line ",  
        //                 subject: "Line Subject",  
        //                 content: "This is a line annotation."  
        //             });
        //         } else if (obj.type === 'path') {
        //             if (obj.annotationType === 'cloud') { 
        //                 annotations.push({
        //                     type: 'cloud',
        //                     page: pageNum,
        //                     path: obj.path,
        //                     cloudPoints: obj.cloudPoints,
        //                     cloudRadius: obj.cloudRadius,
        //                     cloudHumpSize: obj.cloudHumpSize,   
        //                     stroke: obj.stroke,
        //                     strokeWidth: obj.strokeWidth,
        //                     title: "Cloud Annotation",
        //                     subject: "Cloud Subject",
        //                     content: "This is a cloud annotation.",
        //                 });
        //             } else if (obj.annotationType === 'stamp') {
        //                 annotations.push({
        //                     type: 'stamp',
        //                     page: pageNum,
        //                     x1: obj.left,
        //                     y1: obj.top,
        //                     x2: obj.left + obj.width,
        //                     y2: obj.top + obj.height,
        //                     imgSrc: obj.imgSrc, 
        //                     width: obj.width,
        //                     height: obj.height,
        //                     title: "Stamp",
        //                     subject: "Stamp Subject",
        //                     content: "This is a stamp annotation.",
        //                 });
        //             } else if (obj.annotationType === 'signature') {
        //                 annotations.push({
        //                     type: 'signature',
        //                     page: pageNum,
        //                     x1: obj.left,
        //                     y1: obj.top,
        //                     width: obj.getScaledWidth(),
        //                     height: obj.getScaledHeight(),
        //                     dataURL: obj.dataURL, 
        //                     title: "Signature",
        //                     subject: "Signature Subject",
        //                     content: "This is a signature annotation.",
        //                 });
        //             } else {
        //                 annotations.push({
        //                     type: 'freeDraw',
        //                     page: pageNum,
        //                     path: obj.path,
        //                     stroke: obj.stroke,
        //                     strokeWidth: obj.strokeWidth,
        //                     title: "Free Draw",
        //                     subject: "Free Draw Subject",
        //                     content: "This is a free draw annotation.",
        //                 });
        //             }
        //         }
        //     });
        //     console.log("Annotations Saved:", annotations);

        //     const fileInput = document.getElementById('file-input');
        //     const reader = new FileReader();
        //     reader.onload = function (e) {
        //         const pdfData = e.target.result.split(',')[1];
        //         fetch('http://127.0.0.1:5000/save', {  
        //             method: 'POST',
        //             body: JSON.stringify({ pdf: pdfData, annotations }),
        //             headers: { 'Content-Type': 'application/json' },
        //         })
        //             .then(response => response.blob())
        //             .then(blob => {
        //                 const url = window.URL.createObjectURL(blob);
        //                 const a = document.createElement('a');
        //                 a.href = url;
        //                 a.download = 'Annotated.pdf';
        //                 a.click();
        //                 window.URL.revokeObjectURL(url);
        //                 showToast('PDF saved successfully');
        //             })
        //             .catch(error => {
        //                 showToast('Error saving PDF');
        //                 console.error("Error saving PDF:", error);
        //             });
        //     };
        //     if (fileInput.files.length > 0) {
        //         reader.readAsDataURL(fileInput.files[0]);
        //     } else {
        //         showToast('Error saving PDF');
        //     }
        // }



        function save() {

            try {

                // showToast('Saving annotations...');

                const annotations = [];
                Object.keys(annotationsByPage).forEach(pageNum => {
                    annotations.push(...annotationsByPage[pageNum]);
                });

                fabricCanvas.getObjects().forEach(obj => {
                    if (!obj.id || annotations.find(ann => ann.id === obj.id)) {
                        return;
                    }

                    console.log("Object on canvas:", obj);
                    if (obj.type === 'textbox') {
                        console.log("Saving textbox object:", obj);
                        annotations.push({
                            UserName: "Anurag Sable",
                            DocumentId: sessionDocumentId,
                            UserId: sessionUserId,
                            id: obj.id,
                            type: 'text',
                            page: pageNum,
                            x1: obj.left,
                            y1: obj.top,
                            x2: obj.left + obj.width * obj.scaleX,
                            y2: obj.top + obj.height * obj.scaleY,
                            text: obj.text || "Enter Text",
                            fontSize: obj.fontSize,
                            fontFamily: obj.fontFamily || 'Arial',
                            fill: obj.fill || 'black',
                            title: "Text Annotation",
                            subject: "Text",
                            content: obj.text || "Enter Text",
                            strokeWidth: obj.strokeWidth || 1,
                            selectable: true,
                            evented: true
                        });
                    } else if (obj.annotationType === 'highlight') {
                        annotations.push({
                            type: 'highlight',
                            page: pageNum,
                            x1: obj.left,
                            y1: obj.top,
                            x2: obj.left + obj.width,
                            y2: obj.top + obj.height,
                            fill: obj.fill,
                        });
                    } else if (obj.annotationType === 'underline') {
                        annotations.push({
                            type: 'underline',
                            page: pageNum,
                            x1: obj.left,
                            y1: obj.top,
                            x2: obj.left + obj.width,
                            y2: obj.top + obj.height,
                        });
                    } else if (obj.annotationType === 'strikeout') {
                        annotations.push({
                            type: 'strikeout',
                            page: pageNum,
                            x1: obj.left,
                            y1: obj.top,
                            x2: obj.left + obj.width,
                            y2: obj.top + obj.height,
                            stroke: obj.stroke,
                            strokeWidth: obj.strokeWidth,

                        });
                    }
                    else if (obj.annotationType === 'square') {
                        annotations.push({
                            id: obj.id,
                            type: 'square',
                            page: pageNum,
                            x1: obj.left,
                            y1: obj.top,
                            x2: obj.left + obj.width,
                            y2: obj.top + obj.height,
                            stroke: obj.stroke,
                            strokeWidth: obj.strokeWidth,
                            title: "Square Annotation",
                            subject: "Square Subject",
                            content: "This is a square annotation."
                        });
                    } else if (obj.type === 'circle') {
                        annotations.push({
                            type: 'circle',
                            page: pageNum,
                            x1: obj.left,
                            y1: obj.top,
                            radius: obj.radius,
                            fill: obj.fill,
                            stroke: obj.stroke,
                            strokeWidth: obj.strokeWidth,
                            title: "Circle ",
                            subject: "Circle Subject",
                            content: "This is a circle annotation."
                        });
                    } else if (obj.type === 'line') {
                        annotations.push({
                            type: 'line',
                            page: pageNum,
                            x1: obj.x1,
                            y1: obj.y1,
                            x2: obj.x2,
                            y2: obj.y2,
                            stroke: obj.stroke,
                            strokeWidth: obj.strokeWidth,
                            title: "Line ",
                            subject: "Line Subject",
                            content: "This is a line annotation."
                        });
                    } else if (obj.type === 'path') {
                        if (obj.annotationType === 'cloud') {
                            annotations.push({
                                type: 'cloud',
                                page: pageNum,
                                path: obj.path,
                                cloudPoints: obj.cloudPoints,
                                cloudRadius: obj.cloudRadius,
                                cloudHumpSize: obj.cloudHumpSize,
                                stroke: obj.stroke,
                                strokeWidth: obj.strokeWidth,
                                title: "Cloud Annotation",
                                subject: "Cloud Subject",
                                content: "This is a cloud annotation.",
                            });
                        } else if (obj.annotationType === 'stamp') {
                            annotations.push({
                                type: 'stamp',
                                page: pageNum,
                                x1: obj.left,
                                y1: obj.top,
                                x2: obj.left + obj.width,
                                y2: obj.top + obj.height,
                                imgSrc: obj.imgSrc,
                                width: obj.width,
                                height: obj.height,
                                title: "Stamp",
                                subject: "Stamp Subject",
                                content: "This is a stamp annotation.",
                            });
                        } else if (obj.annotationType === 'signature') {
                            annotations.push({
                                type: 'signature',
                                page: pageNum,
                                x1: obj.left,
                                y1: obj.top,
                                width: obj.getScaledWidth(),
                                height: obj.getScaledHeight(),
                                dataURL: obj.dataURL,
                                title: "Signature",
                                subject: "Signature Subject",
                                content: "This is a signature annotation.",
                            });
                        } else {
                            annotations.push({
                                type: 'freeDraw',
                                page: pageNum,
                                path: obj.path,
                                stroke: obj.stroke,
                                strokeWidth: obj.strokeWidth,
                                title: "Free Draw",
                                subject: "Free Draw Subject",
                                content: "This is a free draw annotation.",
                            });
                        }
                    }
                });
                console.log("Collected annotations:", annotations);

              

        

                const commentList = annotations.map(annotation => ({
            UserId: sessionUserId,
            Comments: annotation.content || "No content",
            Remark: "Empty",
            CommentDate: new Date().toISOString(),
            AnnotationType: annotation.type,
            PageNumber: annotation.page,
            Id: generateGuid(),
            UserName: "Anurag Sable"
        }));

        const backendData = {
            DocumentId: sessionDocumentId,
            CommentList: commentList
        };

        console.log("Backend Data to be sent:", backendData);
        sendAnnotationToBackend(backendData);


                const urlParams = new URLSearchParams(window.location.search);
                const pdfUrl = urlParams.get('pdf');

                if (!pdfUrl) {
                    throw new Error('No PDF URL found');
                }

                // Show loading toast
                showToast('Processing PDF...');


                // For IIS 


                const base64Url = btoa(pdfUrl);

                fetch(`/load-pdf/${base64Url}`)
                    .then(response => {
                        if (!response.ok) {
                            return response.json().then(error => {
                                throw new Error(error.error || 'Failed to load PDF');
                            });
                        }
                        return response.arrayBuffer();
                    }).then(pdfData => {


                        // Convert PDF data to base64
                        // const base64pdf = btoa(
                        //     new Uint8Array(pdfData)
                        //         .reduce((data, byte) => data + String.fromCharCode(byte), '')
                        // );

                        // Create the exact JSON format required
                        const formData = new FormData();

                        // Create Blob from base64 PDF
                        const pdfBlob = new Blob([pdfData], { type: 'application/pdf' });


                        formData.append('file', pdfBlob, 'annotated.pdf');
                        formData.append('DocumentId', sessionDocumentId);
                        formData.append('annotations', JSON.stringify(annotations));  


                        // Send to backend
                        return fetch('/api/comment/Pdf', {
                            method: 'POST',
                            body: formData
                        });
                    })
                    


                //for local server


                // // First fetch the PDF
                // fetch(`/load-pdf/${encodeURIComponent(pdfUrl)}`)
                // .then(response => {
                // if (!response.ok) {
                // throw new Error('Failed to load PDF');
                // }
                // return response.arrayBuffer();
                // })
                // .then(pdfData => {
                // Convert ArrayBuffer to Base64
                // const base64pdf = btoa(
                // new Uint8Array(pdfData)
                //     .reduce((data, byte) => data + String.fromCharCode(byte), '')
                // );


                // // Send to backend
                // return fetch('http://127.0.0.1:80/save', {
                //         method: 'POST',
                //         headers: {
                //             'Content-Type': 'application/json',
                //         },
                //         body: JSON.stringify({
                //             pdf: base64pdf,
                //             annotations: annotations,
                //             savePath:'D:/Publish Code/PdfAnnotation'
                //         })
                //     });
                // })



            } catch (error) {
                console.error("Error in save function:", error);
                showToast(`Error: ${error.message}`);
            }
        }



        fabricCanvasElement.addEventListener('mousedown', (e) => {
            isDrawing = true;
            pdfContext.beginPath();
            pdfContext.moveTo(e.offsetX, e.offsetY);
        });
        fabricCanvasElement.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                pdfContext.lineTo(e.offsetX, e.offsetY);
                pdfContext.stroke();
            }
        });
        fabricCanvasElement.addEventListener('mouseup', () => {
            isDrawing = false;
            pdfContext.closePath();
        });
        // console.log("Annotations to be sent:", annotations);

    </script>


    <script src="../assets/plugins/jquery/jquery.min.js"></script>
    <!-- Bootstrap 4 -->
    <script src="../assets/plugins/bootstrap/js/bootstrap.bundle.min.js"></script>

    <script src="../assets/plugins/bs-custom-file-input/bs-custom-file-input.min.js"></script>

    <!-- AdminLTE App -->
    <script src="../assets/js/main.js"></script>
    <!-- AdminLTE for demo purposes -->
    <script src="../assets/js/demo.js"></script>
    <!-- Page specific script -->

    <script>
        $(function () {
            bsCustomFileInput.init();
        });
    </script>
    <script>
        $(document).ready(function () {
            $('[data-toggle="tooltip"]').tooltip();
        });
    </script>

</body>

</html>
>
