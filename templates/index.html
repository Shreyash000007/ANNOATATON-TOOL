<!DOCTYPE html>
<html lang="en">
<head>
   
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Transport | Dashboard</title>
    <!-- Google Font: Source Sans Pro -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,400i,700&display=fallback">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="../assets/plugins/fontawesome-free/css/all.min.css">


    <!-- Tempusdominus Bootstrap 4 -->
    <link rel="stylesheet" href="../assets/plugins/tempusdominus-bootstrap-4/css/tempusdominus-bootstrap-4.min.css">
    <!-- Theme style -->
    <link rel="stylesheet" href="../assets/css/main.css">



    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.2.4/fabric.min.js"></script>
    <style>
        /* Global Styling */
        button:focus {
            outline: none;
            box-shadow: 0 0 0 3px #00bcd4;
            /* Focus effect with teal */
        }
        /* Page Navigation Buttons */
        button.prev-next {
            background-color: #00796b;
            /* Deep teal for navigation */
            color: white;
            font-weight: bold;
            border-radius: 8px;
        }
        button.prev-next:hover {
            background-color: #004d40;
            /* Darker teal on hover */
        }
        /* PDF Container Styling */
        #pdf-container {
            /* position: relative;
            display: inline-block; */
            background-color: #ffffff;
            margin-top: 20px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0px 6px 12px rgba(0, 0, 0, 0.1);
            /* border: 1px solid #00bcd4; */
            /* Teal border for the PDF container */
            padding: 12px;
        }
        /* PDF Canvas and Fabric Canvas Styling */
        #pdf-canvas,
        #fabric-canvas {
            position: absolute;
            /* top: 0;
            left: 0; */
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
        }
        /* Page Number Display */
        #page-num,
        #page-count {
            font-size: 18px;
            font-weight: bold;
            color: #00796b;
            /* Teal page number color */
        }

        /* Annotation Types (highlight, text, shapes) */
        .fabric-rect {
            border: 3px solid #ffeb3b;
            /* Bright yellow for highlight */
            background-color: rgba(255, 235, 59, 0.4);
            /* Light yellow background */
            box-shadow: 0 0 10px rgba(255, 235, 59, 0.3);
        }

        .fabric-circle {
            border: 3px solid #f44336;
            /* Red for circles */
            background-color: rgba(244, 67, 54, 0.4);
            /* Light red background */
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.3);
        }

        .fabric-line {
            stroke: #4caf50;
            /* Green for lines */
            stroke-width: 2;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.2);
        }

        .fabric-textbox {
            color: #1976d2;
            /* Blue text color */
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 0 5px rgba(25, 118, 210, 0.4);
        }

      
        /* Styling for undo/redo buttons */
        .undo-redo-buttons {
            background-color: #ff9800;
            /* Orange color */
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
        }

        .undo-redo-buttons:hover {
            background-color: #fb8c00;
        }

        .undo-redo-buttons:active {
            transform: scale(0.98);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            

            #controls {
                flex-direction: column;
                gap: 15px;
            }

            #pdf-container {
                width: 100%;
                margin-top: 20px;
            }

            canvas {
                width: 100%;
            }

            button,
            input {
                font-size: 14px;
                padding: 8px 14px;
            }

            .fabric-rect,
            .fabric-circle,
            .fabric-line,
            .fabric-textbox {
                font-size: 14px;
            }

            #pdf-container {
                box-shadow: none;
                border-radius: 0;
            }
        }

        /* Final Touches */
        #pdf-container canvas {
            transition: all 0.3s ease-in-out;
        }

        #pdf-container canvas:hover {
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }
        
        /* Text Layer Styling */
        #text-layer {
            position: absolute;
            top: 0;
            left: 0;
            overflow: hidden;
            /* Prevent content overflow */
            pointer-events: auto;
            /* Allow interactions with annotations if needed */
            transform-origin: 0 0;
            background: rgba(255, 255, 255, 0.01);
            /* Slightly visible or transparent background to ensure it's a layer */
        }
        #text-layer span {
            pointer-events: all;
            /* Allow text selection if needed */
            position: absolute;
            white-space: pre;
            color: transparent;
            /* Completely hide the text visually */
            background: transparent;
            /* Ensure no additional rendering issues */
            transform-origin: 0 0;
        }
        .text-annotation {
            pointer-events: none;
            /* Prevent interference with text selection */
            z-index: 1000;
            /* Ensure annotations are above the text layer */
        }
        #thumbnail-container {
            width: 250px;
            overflow-y: auto;
            background-color: #f2f2f2;
            padding: 20px;
            border-right: 1px solid #b9bdbe;
            z-index: 100;
            height: 75vh;
        }

        #thumbnails canvas {
            margin-bottom: 10px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        #pdf-container:fullscreen {
    width: 100%;
    height: 100%;
    display: block;
    margin: 0;
    padding: 0;
    background-color: #fff; /* Optional: background color in full-screen */
        }

    </style>
</head>


<body class="hold-transition sidebar-collapse layout-footer-fixed">
    <div class="wrapper">

    <!-- Navbar -->
    <nav class="main-header navbar navbar-expand navbar-white navbar-light text-sm">
        <!-- Left navbar links -->
        <ul class="navbar-nav">
            <li class="nav-item">
                <a class="nav-link" data-widget="pushmenu" href="#" role="button"><i class="fas fa-bars"></i></a>
            </li>
            <li class="nav-item d-none d-sm-inline-block">
                <a href="" class="nav-link">Home</a>
            </li>

        </ul>

        <!-- Right navbar links -->
        <ul class="navbar-nav ml-auto">
            <!-- Navbar Search -->
            <li class="nav-item">
                <a class="nav-link" data-widget="navbar-search" href="#" role="button">
                    <i class="fas fa-search"></i>
                </a>
                <div class="navbar-search-block">
                    <form class="form-inline">
                        <div class="input-group input-group-sm">
                            <input class="form-control form-control-navbar" type="search" placeholder="Search" aria-label="Search">
                            <div class="input-group-append">
                                <button class="btn btn-navbar" type="submit">
                                    <i class="fas fa-search"></i>
                                </button>
                                <button class="btn btn-navbar" type="button" data-widget="navbar-search">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                        </div>
                    </form>
                </div>
            </li>


            <!-- Notifications Dropdown Menu -->
            <li class="nav-item dropdown">
                <a class="nav-link" data-toggle="dropdown" href="#">
                    <i class="far fa-bell"></i>
                    <span class="badge badge-warning navbar-badge">15</span>
                </a>
                <div class="dropdown-menu dropdown-menu-lg dropdown-menu-right">
                    <span class="dropdown-item dropdown-header">15 Notifications</span>
                    <div class="dropdown-divider"></div>
                    <a href="#" class="dropdown-item">
                        <i class="fas fa-envelope mr-2"></i> 4 new messages
                        <span class="float-right text-muted text-sm">3 mins</span>
                    </a>
                    <div class="dropdown-divider"></div>
                    <a href="#" class="dropdown-item">
                        <i class="fas fa-users mr-2"></i> 8 friend requests
                        <span class="float-right text-muted text-sm">12 hours</span>
                    </a>
                    <div class="dropdown-divider"></div>
                    <a href="#" class="dropdown-item">
                        <i class="fas fa-file mr-2"></i> 3 new reports
                        <span class="float-right text-muted text-sm">2 days</span>
                    </a>
                    <div class="dropdown-divider"></div>
                    <a href="#" class="dropdown-item dropdown-footer">See All Notifications</a>
                </div>
            </li>
            <li class="nav-item">
                <a class="nav-link" data-widget="fullscreen" href="#" role="button">
                    <i class="fas fa-expand-arrows-alt"></i>
                </a>
            </li>
            <li class="nav-item">
                <a class="nav-link" data-widget="control-sidebar" data-controlsidebar-slide="true" href="#" role="button">
                    <i class="fas fa-th-large"></i>
                </a>
            </li>
        </ul>
    </nav>
    <!-- /.navbar -->

    <!-- Main Sidebar Container -->
    <aside class="main-sidebar elevation-4 sidebar-light-navy">
        <!-- Brand Logo -->
        <a href="" class="brand-link">
            <img src="../assets/img/logo.png" alt="Logo" class="brand-image img-circle elevation-3" style="opacity: .8">
            <span class="brand-text font-weight-light">PDF</span>
        </a>

        <!-- Sidebar -->
        <div class="sidebar">
            <!-- Sidebar user panel (optional) -->
            <div class="user-panel mt-3 pb-3 mb-3 d-flex">
                <div class="image">
                    <img src="../assets/img/user2-160x160.jpg" class="img-circle elevation-2" alt="User Image">
                </div>
                <div class="info">
                    <a href="#" class="d-block">Vaibhav Barsagade</a>
                </div>
            </div>

            <!-- Sidebar Menu -->
            <nav class="mt-2">
                <ul class="nav nav-pills nav-sidebar flex-column nav-compact" data-widget="treeview" role="menu" data-accordion="false">
                    <!-- Add icons to the links using the .nav-icon class
                         with font-awesome or any other icon font library -->

                    <li class="nav-item menu-open">
                        <a href="#" class="nav-link active">
                            <i class="nav-icon fas fa-tachometer-alt"></i>
                            <p>
                                Admin Menu
                                <i class="right fas fa-angle-left"></i>
                            </p>
                        </a>
                        <ul class="nav nav-treeview">
                            <li class="nav-item">
                                <a href="index.html" class="nav-link active">
                                    <i class="far fa-circle nav-icon"></i>
                                    <p>Create Employee</p>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="starter.html" class="nav-link">
                                    <i class="far fa-circle nav-icon"></i>
                                    <p>View Employee</p>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="" class="nav-link">
                                    <i class="far fa-circle nav-icon"></i>
                                    <p>Follow Up Check</p>
                                </a>
                            </li>
                        </ul>
                    </li>

                    <li class="nav-item">
                        <a href="#" class="nav-link">
                            <i class="nav-icon fas fa-chart-pie"></i>
                            <p>
                                Road Services
                                <i class="right fas fa-angle-left"></i>
                            </p>
                        </a>
                        <ul class="nav nav-treeview">
                            <li class="nav-item">
                                <a href="" class="nav-link">
                                    <i class="far fa-circle nav-icon"></i>
                                    <p>HighTea</p>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="" class="nav-link">
                                    <i class="far fa-circle nav-icon"></i>
                                    <p>SideHigh</p>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="" class="nav-link">
                                    <i class="far fa-circle nav-icon"></i>
                                    <p>Inline</p>
                                </a>
                            </li>
                            <li class="nav-item">
                                <a href="" class="nav-link">
                                    <i class="far fa-circle nav-icon"></i>
                                    <p>uPlot</p>
                                </a>
                            </li>
                        </ul>
                    </li>

                </ul>
            </nav>
            <!-- /.sidebar-menu -->
        </div>
        <!-- /.sidebar -->
    </aside>

    <!-- Content Wrapper. Contains page content -->
    <div class="content-wrapper">
        <section class="content mt-2">
            <div class="container-fluid">

                <div class="row">
                    <div class="col-md-12">
                        <div class="card" >
                            <div class="card-body">
                                <div class="row">
                                    <div class="col-lg-2">
                                        <div class="custom-file">
                                            <input type="file" id="file-input" class="custom-file-input" accept="application/pdf" />
                                            <label class="custom-file-label" for="customFile">Choose file</label>
                                        </div>
                                    </div>
                                    <div class="col-lg-10">
                                        <div class="btn-group">
                                          
                                            <button onclick="toggleThumbnails()" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="ThumbNail!">
                                                <i class="fas fa-list"></i>
                                            </button>

                                            <button  onclick="prevPage()" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="ThumbNail!">
                                                <i class="fas fa-step-backward"></i>
                                            </button>
                                            <button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="ThumbNail!">
                                                <i class="fas fa-chevron-left"></i>
                                            </button>
                                            <button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="ThumbNail!">
                                                <i class="fas fa-chevron-right"></i>
                                            </button>
                                            <button onclick="nextPage()" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="ThumbNail!">
                                                <i class="fas fa-step-forward"></i>
                                            </button>
                                        </div>
                                        <div class="btn-group">
                                            <button onclick="zoomOut()" id="zoom-out" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Zoom In">
                                                <i class="fas fa-search-minus"></i>
                                            </button>
                                            <button type="button" class="btn btn-default">
                                                <div id="zoom-percent">60</div>
                                            </button>
                                            <button onclick="zoomIn()" id="zoom-in" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Zoom Out">
                                                <i class="fas fa-search-plus"></i>
                                            </button>
                                            <button id="zoom-reset" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Zoom Reset">
                                                <i class="fas fa-undo-alt"></i>
                                            </button>
                                        </div>
                                        <div class="btn-group">
                                            <button onclick="addSquare()" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Draw Square">
                                                <i class="far fa-square"></i>
                                            </button>
                                            <button onclick="addLine()" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Draw Line">
                                                <i class="fas fa-slash"></i>
                                            </button>
                                            <button onclick="addCircle()" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Draw Circle">
                                                <i class="far fa-circle"></i>
                                            </button>
                                            <button onclick="addFreeDraw()"  type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Free Draw">
                                                <i class="fas fa-edit"></i>
                                            </button>
                                            <button onclick="addSelectedStamp()" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Add Stamp">
                                                <i class="fas fa-stamp"></i>
                                            </button>
                                            <button id="highlight" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Add Highlighter">
                                                <i class="fas fa-highlighter"></i>
                                            </button>
                                            <button id="underline" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Add Underline">
                                                <i class="fas fa-underline"></i>
                                            </button>
                                            <button id="strikeout" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Add strikethrough">
                                                <i class="fas fa-strikethrough"></i>
                                            </button>
                                            <button onclick="toggleFullScreen()" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Add full-screen">
                                                <i class="fas fa-window-maximize"></i>
                                            </button>
                                        </div>
                                        <div class="btn-group">
                                            <button onclick="undo()" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Undo">
                                                <i class="fas fa-undo"></i>
                                            </button>
                                            <button onclick="redo()" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Redu">
                                                <i class="fas fa-redo"></i>
                                            </button>
                                        </div>
                                        <div class="btn-group">
                                            <button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Expand">
                                                <i class="fas fa-expand"></i>
                                            </button>
                                            <button onclick="addCloudAnnotation()" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Draw Cloud">
                                                <i class="fas fa-cloud"></i>
                                            </button>
                                            <button onclick="addText()" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Add Text">
                                                <i class="fas fa-text-width"></i>
                                            </button>
                                        </div>
                                        <div class="btn-group">
                                            <button type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Print">
                                                <i class="fas fa-print"></i>
                                            </button>
                                            <button onclick="save()" type="button" class="btn btn-default" data-toggle="tooltip" data-placement="top" title="Save PDF">
                                                <i class="fas fa-save"></i>
                                            </button>
                                        </div>
                                        <div class="btn-group">
                                            <button onclick="fitToWidth()" title="Fit to Width" type="button" class="btn btn-default">
                                                <i class="fas fa-expand-arrows-alt"></i>
                                            </button>
                                            <button onclick="fitToHeight()" title="Fit to Height" type="button" class="btn btn-default">
                                                <i class="fas fa-chevron-right"></i>
                                            </button>
                                        </div>
                                        <select id="stampSelect" class="d-none">
                                            <option value="approve">Approve</option>
                                            <option value="notApprove">Not Approve</option>
                                            <option value="right">Right</option>
                                            <option value="wrong">Wrong</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="row">
                                    <div class="col-lg-3">
                                        <div class="card-body">
                                            <div id="thumbnail-container" style="display: none;">
                                                <div id="thumbnails"></div>
                                            </div>
                                            
                                            <div id="thumbnail-container" style="display: none;">
                                                <div id="thumbnails"></div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-lg-9">
                                        <div class="card-body">
                                            <div id="pdf-container">
                                                <canvas id="pdf-canvas"></canvas>
                                                <canvas id="fabric-canvas"></canvas>
                                                <div id="text-layer" style="position: absolute; top: 0; left: 0;"></div>
                                            </div>

                                            <div class="row">
                                                <div class="col-lg-12">
                                                    <input type="checkbox" id="toggle-selection"> Enable Annotation Selection <span>Page: <span id="page-num">1</span> / <span id="page-count">0</span></span>
                                                </div>
                                            </div>

                                        </div>

                                    </div>
                                </div>
                               
                            </div>
                        </div>
                    </div>

                </div>

            </div>

        </section>

    </div>
    <!-- /.content-wrapper -->
    <footer class="main-footer text-sm">
        <strong>&copy; 2023 <a href="">PDF System</a>.</strong>
        All rights reserved.
        <div class="float-right d-none d-sm-inline-block">
            <b>Version</b> 3.2.0
        </div>
    </footer>

    <!-- Control Sidebar -->
    <aside class="control-sidebar control-sidebar-dark">
        <div class="p-3 control-sidebar-content">

        </div>
    </aside>
    <!-- /.control-sidebar -->
</div>
<!-- ./wrapper -->

<script>
    let pdfDoc = null;
    let pageNum = 1;
    const pdfCanvas = document.getElementById('pdf-canvas');
    const fabricCanvasElement = document.getElementById('fabric-canvas');
    const textLayer = document.getElementById('text-layer');
    const pdfContext = pdfCanvas.getContext('2d');
    const fabricCanvas = new fabric.Canvas(fabricCanvasElement, { selection: true });
    let redoStack = []; // Create a stack for redo
    // Store annotations by page number
    let annotationsByPage = {};  // Store annotations for each page
    let isDrawing = false; // To track if user is drawing
    let startX, startY; // Start coordinates for drawing
    let currentAnnotation = null;
    // Enable free draw mode
    let isFreeDrawEnabled = false;
    const textLayerAdjustments = {}; // Store adjustments for each page { pageNum: { x: 0, y: 0 } }
    const thumbnailsContainer = document.getElementById("thumbnails");
    const thumbnailContainer = document.getElementById("thumbnail-container");
    let currentScale = 1; // Keep track of current zoom level
    let currentPageNum = 1; // Initialize with the first page or whatever page is being rendered initially

    // Function to fit the PDF to the container width
function fitToWidth() {
const containerWidth = document.getElementById('pdf-container').offsetWidth; // Get the container width
const pageWidth = pdfCanvas.width; // Get the PDF page width
const scaleFactor = containerWidth / pageWidth; // Calculate the scale to fit the width
setScale(scaleFactor);
}

// Function to fit the PDF to the container height
function fitToHeight() {
const containerHeight = document.getElementById('pdf-container').offsetHeight; // Get the container height
const pageHeight = pdfCanvas.height; // Get the PDF page height
const scaleFactor = containerHeight / pageHeight; // Calculate the scale to fit the height
setScale(scaleFactor);
}
// Function to toggle full-screen mode
function toggleFullScreen() {
const pdfContainer = document.getElementById('pdf-container');
const fullScreenButton = document.querySelector('button[onclick="toggleFullScreen()"]');

if (!document.fullscreenElement) {
    // Enter full-screen mode
    if (pdfContainer.requestFullscreen) {
        pdfContainer.requestFullscreen();
    } else if (pdfContainer.mozRequestFullScreen) { // Firefox
        pdfContainer.mozRequestFullScreen();
    } else if (pdfContainer.webkitRequestFullscreen) { // Chrome, Safari, Opera
        pdfContainer.webkitRequestFullscreen();
    } else if (pdfContainer.msRequestFullscreen) { // IE/Edge
        pdfContainer.msRequestFullscreen();
    }
    fullScreenButton.textContent = "Exit Full Screen"; // Update button text
} else {
    // Exit full-screen mode
    if (document.exitFullscreen) {
        document.exitFullscreen();
    } else if (document.mozCancelFullScreen) { // Firefox
        document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) { // Chrome, Safari, Opera
        document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) { // IE/Edge
        document.msExitFullscreen();
    }
    fullScreenButton.textContent = "Full Screen"; // Update button text
}
}

// Update button text when exiting full-screen using ESC or other methods
document.addEventListener('fullscreenchange', () => {
const fullScreenButton = document.querySelector('button[onclick="toggleFullScreen()"]');
if (!document.fullscreenElement) {
    fullScreenButton.textContent = "Full Screen";
} else {
    fullScreenButton.textContent = "Exit Full Screen";
}
});

document.addEventListener('keydown', (event) => {
if (event.key === 'F11') {
    event.preventDefault(); // Prevent default browser full-screen toggle
    toggleFullScreen();
}
});


// Function to apply the scale factor and re-render the page
function setScale(scaleFactor) {
currentScale = scaleFactor;

// Calculate the new viewport for the page render
const viewport = pdfDoc.getPage(currentPageNum).then(page => {
    const newViewport = page.getViewport({ scale: currentScale });
    
    renderPage(currentPageNum, newViewport); // Re-render the page with the new scale
});
}

    function zoomIn() {
currentScale *= 1.1; // Increase scale by 10%
renderPage(currentPageNum); // Re-render current page with the new 

}

// Function to zoom out
function zoomOut() {
currentScale /= 1.1; // Decrease scale by 10%
renderPage(currentPageNum); // Re-render current page with the new scale

}

    // Function to toggle the thumbnail panel
    function toggleThumbnails() {
        thumbnailContainer.style.display =
            thumbnailContainer.style.display === "none" ? "block" : "none";
    }

    function enableFreeDraw() {
        isFreeDrawEnabled = !isFreeDrawEnabled;
        fabricCanvas.isDrawingMode = isFreeDrawEnabled;
        fabricCanvas.freeDrawingBrush.width = 2;
        fabricCanvas.freeDrawingBrush.color = 'black';
    }
    function redrawAnnotations() {
        // Clear the canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Loop through all saved annotations and redraw them
        annotations.forEach((annotation) => {
            if (annotation.type === 'square') {
                // Draw square annotation
                ctx.beginPath();
                ctx.strokeStyle = annotation.stroke || '#ffeb3b'; // Bright yellow border
                ctx.lineWidth = annotation.strokeWidth || 3;
                ctx.rect(annotation.x1, annotation.y1, annotation.x2 - annotation.x1, annotation.y2 - annotation.y1);
                ctx.stroke();
                ctx.closePath();
            }
            else if (annotation.type === 'line') {
                // Logic for line annotation
                ctx.beginPath();
                ctx.strokeStyle = annotation.color || 'black';
                ctx.lineWidth = annotation.lineWidth || 2;
                ctx.moveTo(annotation.start.x, annotation.start.y);
                ctx.lineTo(annotation.end.x, annotation.end.y);
                ctx.stroke();
                ctx.closePath();
            } else if (annotation.type === 'text') {
                // Logic for text annotation
                ctx.font = `${annotation.fontSize || 16}px ${annotation.font || 'Arial'}`;
                ctx.fillStyle = annotation.color || 'black';
                ctx.fillText(annotation.text, annotation.position.x, annotation.position.y);
            } else if (annotation.type === 'circle') {
                // Logic for circle annotation
                ctx.beginPath();
                ctx.strokeStyle = annotation.color || 'red';
                ctx.lineWidth = annotation.lineWidth || 2;
                ctx.arc(
                    annotation.center.x,
                    annotation.center.y,
                    annotation.radius,
                    0,
                    2 * Math.PI
                );
                ctx.stroke();
                ctx.closePath();
            } else if (annotation.type === 'text') {
                // Logic for rendering text annotation
                const obj = new fabric.Textbox(annotation.content || 'Enter Text', {
                    left: annotation.x1 * scaleFactor,
                    top: annotation.y1 * scaleFactor,
                    fontSize: (annotation.fontSize || 20) * scaleFactor, // Apply scaling to fontSize
                    fill: annotation.fill || 'black',
                });
                fabricCanvas.add(obj);
            }

        });
    }
    function resetDrawingState() {
        isDrawing = false;
        fabricCanvas.isDrawingMode = false; // Disable free drawing mode
        fabricCanvas.selection = true;     // Enable object selection
        fabricCanvas.off('mouse:down');
        fabricCanvas.off('mouse:move');
        fabricCanvas.off('mouse:up');
    }
    // Load PDF file and generate thumbnails
    document.getElementById("file-input").addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const pdfData = new Uint8Array(e.target.result);
                pdfjsLib.getDocument({ data: pdfData }).promise.then((pdf) => {
                    pdfDoc = pdf;
                    generateThumbnails(); // Generate thumbnails for all pages
                    renderPage(pageNum); // Render the first page
                });
            };
            reader.readAsArrayBuffer(file);
            toggleThumbnails();
        }
    });


    // Generate thumbnails for all pages
    function generateThumbnails() {
        thumbnailsContainer.innerHTML = ""; // Clear existing thumbnails
        // Array to store the rendering promises
        const renderPromises = [];

        for (let i = 1; i <= pdfDoc.numPages; i++) {
            renderPromises.push(
                pdfDoc.getPage(i).then((page) => {
                    const viewport = page.getViewport({ scale: 0.2 }); // Smaller scale for thumbnails
                    const thumbnailCanvas = document.createElement("canvas");
                    thumbnailCanvas.width = viewport.width;
                    thumbnailCanvas.height = viewport.height;
                    const context = thumbnailCanvas.getContext("2d");
                    const renderContext = {
                        canvasContext: context,
                        viewport: viewport,
                    };

                    return page.render(renderContext).promise.then(() => {
                        // Add click event to navigate to the corresponding page
                        thumbnailCanvas.addEventListener("click", () => {
                            pageNum = i;
                            renderPage(pageNum);
                        });

                        return thumbnailCanvas;
                    });
                })
            );
        }

        // Render thumbnails in order after all rendering is complete
        Promise.all(renderPromises).then((thumbnails) => {
            thumbnails.forEach((thumbnailCanvas) => {
                thumbnailsContainer.appendChild(thumbnailCanvas);
            });
        });
    }

// Function to calculate scale properties (coordinates, sizes, etc.)
function scaleProperties(value, currentScale) {
    return value * currentScale; // Adjust scale by only the current scale
}

function renderAnnotation(annotation, currentScale) {
    let obj;

    // Apply scaling only to coordinates and dimensions
    const left = scaleProperties(annotation.x1, currentScale);
    const top = scaleProperties(annotation.y1, currentScale);
    const width = scaleProperties(annotation.x2 - annotation.x1, currentScale);
    const height = scaleProperties(annotation.y2 - annotation.y1, currentScale);

    // Create annotation object
    switch (annotation.type) {
        case 'square':
            obj = new fabric.Rect({
                left: left,
                top: top,
                width: width,
                height: height,
                fill: '',
                stroke: annotation.stroke || '#ffeb3b',
                strokeWidth: scaleProperties(annotation.strokeWidth, currentScale) || 2,
            });
            break;
        case 'line':
            obj = new fabric.Line(
                [left, top, scaleProperties(annotation.x2, currentScale), scaleProperties(annotation.y2, currentScale)],
                {
                    stroke: annotation.stroke || 'red',
                    strokeWidth: scaleProperties(annotation.strokeWidth, currentScale) || 2,
                }
            );
            break;
        case 'circle':
            obj = new fabric.Circle({
                left: left,
                top: top,
                radius: scaleProperties(annotation.radius, currentScale),
                fill: annotation.fill || 'transparent',
                stroke: annotation.stroke || 'red',
                strokeWidth: scaleProperties(annotation.strokeWidth, currentScale) || 2,
            });
            break;
        case 'text':
            obj = new fabric.Textbox(annotation.content || 'Enter Text', {
                left: left,
                top: top,
                fontSize: scaleProperties(annotation.fontSize || 20, currentScale),
                fill: annotation.fill || 'black',
            });
            break;
        case 'freeDraw':
            obj = new fabric.Path(annotation.path, {
                stroke: annotation.stroke || 'black',
                strokeWidth: scaleProperties(annotation.strokeWidth, currentScale) || 2,
                fill: '',
            });
            break;
        case 'cloud':
            obj = new fabric.Path(annotation.path, {
                fill: 'transparent',
                stroke: annotation.stroke || 'blue',
                strokeWidth: scaleProperties(annotation.strokeWidth, currentScale) || 2,
            });
            break;
        case 'stamp':
            fabric.Image.fromURL(annotation.imgSrc, function (img) {
                img.set({
                    left: left,
                    top: top,
                    originX: 'center',
                    originY: 'center',
                    selectable: false,
                    evented: false
                });
                fabricCanvas.add(img);
            });
            break;
                default:
            console.warn('Unknown annotation type:', annotation.type);
            return;
    
    }

    // Add the annotation to Fabric.js canvas
    if (obj) {
        obj.id = annotation.id; // Assign id to the annotation
        fabricCanvas.add(obj); // Add to canvas
    }
}


function renderAnnotationsForPage(pageNum, annotations, currentScale, viewport) {
    annotations.forEach(annotation => {
        if (isNaN(annotation.x1) || isNaN(annotation.y1) || isNaN(annotation.x2) || isNaN(annotation.y2)) {
            console.warn('Invalid annotation coordinates:', annotation);
            return; // Skip invalid annotations
        }

        // Ensure coordinates are within valid range
        annotation.x1 = Math.max(0, Math.min(viewport.width, annotation.x1));
        annotation.y1 = Math.max(0, Math.min(viewport.height, annotation.y1));
        annotation.x2 = Math.max(0, Math.min(viewport.width, annotation.x2));
        annotation.y2 = Math.max(0, Math.min(viewport.height, annotation.y2));

        // Ensure required properties exist
        if (!annotation.x1 || !annotation.y1 || !annotation.x2 || !annotation.y2) {
            console.warn('Missing or invalid annotation properties:', annotation);
            return;
        }

        renderAnnotation(annotation, currentScale); // Ensure scaling is applied
    });
}


    function renderPage(num) {
        currentPageNum = num; // Set the current page number
        pdfDoc.getPage(num).then(page => {
            const viewport = page.getViewport({ scale: currentScale });
            pdfCanvas.width = viewport.width;
            pdfCanvas.height = viewport.height;
            fabricCanvasElement.width = viewport.width;
            fabricCanvasElement.height = viewport.height;
            fabricCanvas.setZoom(currentScale); // Apply new zoom level to Fabric.js canvas
            const renderContext = {
                canvasContext: pdfContext,
                viewport: viewport,
            };
            // Clear any existing content on the canvas before rendering new page
            pdfContext.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
            page.render(renderContext).promise.then(() => {
                fabricCanvas.clear(); // Clear existing annotations for the new page
                fabricCanvas.setWidth(viewport.width);
                fabricCanvas.setHeight(viewport.height);
                fabricCanvas.setZoom(currentScale); // Apply new zoom level to Fabric.js canvas
                renderTextLayer(page, viewport);
                logAnnotations(num);
                // renderAnnotations(num);
                 // Reapply annotations for the current page
                 if (annotationsByPage[num]) {
    renderAnnotationsForPage(num, annotationsByPage[num], currentScale, viewport);
}


                // Log dimensions after setting them
                console.log('PDF Canvas Dimensions:', pdfCanvas.width, pdfCanvas.height);
                console.log('Fabric Canvas Dimensions:', fabricCanvasElement.width, fabricCanvasElement.height);
                const scaleFactor = viewport.scale; // Current viewport scale
                // Reapply annotations for the current page
                // Reapply annotations for the current page
        if (annotationsByPage[num]) {
            annotationsByPage[num].forEach(annotation => {
                // Validation and logging logic for annotations
                if (!annotation.coordinates || !annotation.coordinates.left || !annotation.coordinates.top) {
                    console.warn('Invalid annotation coordinates:', annotation);
                    return; // Skip this annotation if it's invalid
                }

                console.log('Annotation coordinates:', annotation.x1, annotation.y1, annotation.x2, annotation.y2);

                let obj; // Object for Fabric.js
                const scaleProperties = property => property * currentScale;

                if (annotation.type === 'highlight' || annotation.type === 'underline' || annotation.type === 'strikeout') {
                    const annotationDiv = document.createElement('div');
                    annotationDiv.style.position = 'absolute';
                    annotationDiv.style.left = `${annotation.coordinates.left}px`;
                    annotationDiv.style.top = `${annotation.coordinates.top}px`;
                    annotationDiv.style.width = `${annotation.coordinates.width}px`;
                    annotationDiv.style.height = `${annotation.coordinates.height}px`;

                    if (annotation.type === 'highlight') {
                        annotationDiv.style.backgroundColor = 'yellow';
                        annotationDiv.style.opacity = '0.5';
                    } else if (annotation.type === 'underline') {
                        annotationDiv.style.borderBottom = '2px solid red';
                    } else if (annotation.type === 'strikeout') {
                        annotationDiv.style.borderTop = '2px solid black';
                        annotationDiv.style.transform = `translateY(${annotation.coordinates.height / 2}px)`;
                    }

                    annotationDiv.classList.add('text-annotation');
                    textLayer.appendChild(annotationDiv);
                }  

                        if (obj) {
                            obj.id = annotation.id; // Reassign the id
                            fabricCanvas.add(obj);
                        }
                    });
                }
            });
            document.getElementById('page-num').textContent = num;
            console.log("Viewport Scale:", viewport.scale);
            console.log("PDF Canvas:", pdfCanvas.width, pdfCanvas.height);
            console.log("Fabric Canvas:", fabricCanvas.width, fabricCanvas.height);
            console.log(`Rendering annotation: ${annotation.type} at (${annotation.x1}, ${annotation.y1}) with width ${annotation.x2 - annotation.x1} and height ${annotation.y2 - annotation.y1}`);

        });
    }

    function storeAnnotation(type, coordinates, pageNum) {
        if (!annotationsByPage[pageNum]) {
            annotationsByPage[pageNum] = [];
        }
        annotationsByPage[pageNum].push({
            type: type,
            coordinates: coordinates
        });
    }

    function onPageVisible(page, pageNum) {
        const viewport = page.getViewport({ scale: 1 });
        renderTextLayer(page, viewport, pageNum);
        renderAnnotations(pageNum); // Ensure annotations are rendered
    }



    function renderTextLayer(page, viewport) {
        const textLayerDiv = document.getElementById('text-layer');
        textLayerDiv.innerHTML = '';

        const scaleFactor = viewport.scale;
        const scaledWidth = viewport.width;
        const scaledHeight = viewport.height;

       // Set the width and height for the text layer
textLayerDiv.style.width = `${scaledWidth}px`;
textLayerDiv.style.height = `${scaledHeight}px`;

 // Apply scale directly to the text layer container without using transform scale
 textLayerDiv.style.transform = ''; // Clear any previous transform effects

// Adjust left and top positioning of the text layer container
// Ensure that it stays in the correct position (top-left corner)
textLayerDiv.style.position = 'absolute';
textLayerDiv.style.left = '35px';
textLayerDiv.style.top = '45px';
      page.getTextContent().then(textContent => {
            pdfjsLib.renderTextLayer({
                textContent: textContent,
                container: textLayerDiv,
                viewport: viewport,
                textDivs: [],
                enhanceTextSelection: true,
            }).promise.then(() => {
                console.log('Text layer successfully rendered.');

                // Render annotations for this page
                renderAnnotations(pageNum);
            }).catch(err => {
                console.error('Error rendering text layer:', err);
            });
        }).catch(error => {
            console.error('Error fetching text content:', error);
        });
    }

    function disableTextLayer() {
        document.getElementById('text-layer').style.display = 'none';
    }
    // document.querySelectorAll('#controls button').forEach(button => {
    //     button.addEventListener('click', disableTextLayer);
    // });
    function enableTextLayer() {
        const textLayerDiv = document.getElementById('text-layer');
        if (textLayerDiv) {
            textLayerDiv.style.display = 'block';
        }
    }
    document.getElementById('toggle-selection').addEventListener('change', function () {
        const isChecked = this.checked;
        if (isChecked) {
            // Enable annotation selection
            fabricCanvas.selection = true;
            fabricCanvas.forEachObject(obj => {
                obj.selectable = true; // Allow objects to be selectable
            });
            disableTextLayer(); // Disable the text layer
        } else {
            // Disable annotation selection
            fabricCanvas.selection = false;
            fabricCanvas.forEachObject(obj => {
                obj.selectable = false; // Prevent objects from being selectable
            });
            enableTextLayer(); // Enable the text layer
        }
        fabricCanvas.renderAll(); // Re-render the canvas to apply changes
    });

    let annotations = []; // Array to store all annotations

    let currentAnnotationType = null; // Global state to track the current annotation tool

    // Set annotation mode when a button is clicked
    function setAnnotationMode(type) {
        currentAnnotationType = type;
        document.body.style.cursor = type ? 'text' : 'default'; // Change cursor to indicate annotation mode
        //alert(`Annotation mode: ${type}. Select text to annotate.`);
    }

    // Add event listeners to buttons
    document.querySelector('button#highlight').addEventListener('click', () => setAnnotationMode('highlight'));
    document.querySelector('button#underline').addEventListener('click', () => setAnnotationMode('underline'));
    document.querySelector('button#strikeout').addEventListener('click', () => setAnnotationMode('strikeout'));

    // Listen for text selection
    document.addEventListener('mouseup', () => {
        if (!currentAnnotationType) return;

        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            if (!range.collapsed) {
                addTextAnnotation(currentAnnotationType); // Call your existing function
                setAnnotationMode(null); // Exit annotation mode after use
            }
        }
    });

    function logAnnotations(pageNum) {
        const pageAnnotations = annotationsByPage[pageNum] || [];
        console.log(`Annotations for Page ${pageNum}:`, pageAnnotations);
    }

    function renderAnnotations(pageNum) {
        const pageAnnotations = annotationsByPage[pageNum] || [];
        pageAnnotations.forEach(annotation => {
            // Ensure the coordinates are valid
            const { x1, y1, x2, y2 } = annotation;
            if (x1 === undefined || y1 === undefined || x2 === undefined || y2 === undefined) {
                console.warn('Missing or invalid coordinates for annotation:', annotation);
                return;  // Skip rendering this annotation
            }

             // Apply zoom to the annotation coordinates
    const scaleFactor = currentScale; // Use current scale
    const left = x1 * scaleFactor;
    const top = y1 * scaleFactor;
    const width = (x2 - x1) * scaleFactor;
    const height = (y2 - y1) * scaleFactor;

    const annotationDiv = document.createElement('div');
    annotationDiv.style.position = 'absolute';
    annotationDiv.style.left = `${left}px`;
    annotationDiv.style.top = `${top}px`;
    annotationDiv.style.width = `${width}px`;
    annotationDiv.style.height = `${height}px`;

            // Handle annotation types (highlight, underline, strikeout)
            if (annotation.type === 'highlight') {
                annotationDiv.style.backgroundColor = 'yellow';
                annotationDiv.style.opacity = '0.5';
            } else if (annotation.type === 'underline') {
                annotationDiv.style.borderBottom = '2px solid red';
            } else if (annotation.type === 'strikeout') {
                annotationDiv.style.borderTop = '2px solid black';
                annotationDiv.style.transform = `translateY(${height / 2}px)`;
            }

            annotationDiv.classList.add('text-annotation');
            document.getElementById('text-layer').appendChild(annotationDiv);
        });
    }
    // Modified addTextAnnotation function
    function addTextAnnotation(type) {
        const selection = window.getSelection();
        if (!selection.rangeCount) {
            alert('Please select some text to annotate.');
            return;
        }

        const range = selection.getRangeAt(0);
        const rects = range.getClientRects();
        const textLayerDiv = document.getElementById('text-layer');

        Array.from(rects).forEach(rect => {
            // Validate rect values
            if (!rect.left || !rect.top || !rect.width || !rect.height) {
                console.warn('Invalid coordinates:', rect);
                return; // Skip invalid rects
            }
            const annotationDiv = document.createElement('div');
            annotationDiv.style.position = 'absolute';
            annotationDiv.style.left = `${rect.left - textLayerDiv.getBoundingClientRect().left}px`;
            annotationDiv.style.top = `${rect.top - textLayerDiv.getBoundingClientRect().top}px`;
            annotationDiv.style.width = `${rect.width}px`;
            annotationDiv.style.height = `${rect.height}px`;

            if (type === 'highlight') {
                annotationDiv.style.backgroundColor = 'yellow';
                annotationDiv.style.opacity = '0.5';
            } else if (type === 'underline') {
                annotationDiv.style.borderBottom = '2px solid red';
            } else if (type === 'strikeout') {
                annotationDiv.style.borderTop = '2px solid black';
                annotationDiv.style.transform = `translateY(${rect.height / 2}px)`;
            }

            annotationDiv.classList.add('text-annotation');
            annotationDiv.dataset.annotationType = type;

            textLayerDiv.appendChild(annotationDiv);

            // Pass the correct coordinates to storeAnnotation
            storeAnnotation(type, {
                left: rect.left - textLayerDiv.getBoundingClientRect().left,
                top: rect.top - textLayerDiv.getBoundingClientRect().top,
                width: rect.width,
                height: rect.height
            });
        });

        // Clear selection after applying annotation
        selection.removeAllRanges();
    }

    function saveAnnotationsToLocalStorage() {
        localStorage.setItem('annotationsByPage', JSON.stringify(annotationsByPage));
    }

    function loadAnnotationsFromLocalStorage() {
        const storedAnnotations = localStorage.getItem('annotationsByPage');
        if (storedAnnotations) {
            annotationsByPage = JSON.parse(storedAnnotations);
        }
    }
    loadAnnotationsFromLocalStorage();


    function storeAnnotation(type, coordinates, pageNum) {
if (!annotationsByPage[pageNum]) {
    annotationsByPage[pageNum] = [];
}

const annotation = {
    id: `${Date.now()}${Math.random().toString(36).substr(2, 5)}`,
    type: type,
    coordinates: {
        left: coordinates.x1,
        top: coordinates.y1,
        width: coordinates.x2 - coordinates.x1,
        height: coordinates.y2 - coordinates.y1,
    }
};

annotationsByPage[pageNum].push(annotation);
console.log('Stored annotation:', annotation);
saveAnnotationsToLocalStorage(); // Save after every update
}




    function getRelativeCoordinates(rect, container) {
        const containerRect = container.getBoundingClientRect();
        return {
            left: rect.left - containerRect.left,
            top: rect.top - containerRect.top,
            width: rect.width,
            height: rect.height,
        };
    }

        // Function to get the scaling factor between the PDF page and canvas
        function getScaleFactor() {
            return {
                x: pdfCanvas.width / fabricCanvas.getWidth(),
                y: pdfCanvas.height / fabricCanvas.getHeight(),
            };
        }

        //page change
        function prevPage() {
            if (pageNum <= 1) return;
            pageNum--;
            renderPage(pageNum);
        }
        function nextPage() {
            if (pageNum >= pdfDoc.numPages) return;
            pageNum++;
            renderPage(pageNum);
        }

        // Function to store annotations with scaling applied based on the current page's viewport
        function storeAnnotation(type, obj) {
            const scaleFactor = getScaleFactor();
            if (!annotationsByPage[pageNum]) {
                annotationsByPage[pageNum] = [];
            }
            const annotationExists = annotationsByPage[pageNum].find((ann) => ann.id === obj.id);
            if (annotationExists) {
                console.warn("Annotation already exists:", obj.id);
                return; // Avoid duplicate storage
            }
            obj.id = obj.id || Date.now() + Math.random().toString(36).substr(2, 9);
            const annotation = {
                id: obj.id,
                type: type,
                x1: obj.left / scaleFactor.x,
                y1: obj.top / scaleFactor.y,
                x2: (obj.left + (obj.width || 0)) / scaleFactor.x,
                y2: (obj.top + (obj.height || 0)) / scaleFactor.y,
                radius: obj.radius / scaleFactor.x, // Store scaled radius
                page: pageNum,
                title: "", // Default title if not set
                subject: "", // Default subject if not set
                content: type === 'text' ? obj.text : "Enter Text",
                fontSize: obj.fontSize / Math.min(scaleFactor.x, scaleFactor.y), // Use the smaller scale factor for font size
                color: type === 'highlight' ? 'yellow' : undefined,
                stroke: type === 'underline' ? 'red' : type === 'strikeout' ? 'black' : undefined,
            };
            // Add title, subject, and content for each annotation type
            if (type === "square") {
                annotation.title = "Square Title";  // Custom title
                annotation.subject = "Square Subject";  // Custom subject
                annotation.content = "This is a square annotation.";  // Custom content
                annotation.stroke = obj.stroke;
                annotation.strokeWidth = obj.strokeWidth;
            }
            else if (type === "circle") {
                annotation.title = "Circle Title";
                annotation.subject = "Circle Subject";
                annotation.content = "This is a circle annotation.";
                annotation.radius = obj.radius / scaleFactor.x;
                annotation.fill = obj.fill;
            } else if (type === "line") {
                annotation.title = "Line Title";
                annotation.subject = "Line Subject";
                annotation.content = "This is a line annotation.";
                annotation.x2 = obj.x2 / scaleFactor.x;
                annotation.y2 = obj.y2 / scaleFactor.y;
                annotation.stroke = obj.stroke;
                annotation.strokeWidth = obj.strokeWidth / scaleFactor.x;
            } if (type === "text") {
                annotation.subject = "Text Subject";
                annotation.title = "Text";
                annotation.text = obj.text || ""; // Ensure you store the actual text input
                annotation.fontSize = obj.fontSize / scaleFactor.x; // Store font size, adjusted for scale
                annotation.fill = obj.fill;  // Store color
            }
            else if (type === "freeDraw") {
                annotation.title = "Free Draw Title";
                annotation.subject = "Free Draw Subject";
                annotation.content = "This is a Free Draw annotation.";
                annotation.path = obj.path; // Save the path data
                annotation.stroke = obj.stroke;
                annotation.strokeWidth = obj.strokeWidth / scaleFactor.x;
            } else if (type === "cloud") {
                annotation.title = "Cloud Annotation";
                annotation.subject = "Cloud Subject";
                annotation.content = "This is a cloud annotation.";
                annotation.path = obj.path;
                annotation.stroke = obj.stroke;
                annotation.strokeWidth = obj.strokeWidth / scaleFactor.x;
            } else if (type === "highlight") {
                annotation.title = "Highlight Title";
                annotation.subject = "Highlight Subject";
                annotation.content = "This is a highligh annotation.";
                annotation.color = "yellow";
                annotation.opacity = 0.5;
            } else if (type === "underline") {
                annotation.title = "Underline Title";
                annotation.subject = "Underline Subject";
                annotation.content = "This is a underline annotation.";
                annotation.stroke = "red";
                annotation.strokeWidth = 2;
            } else if (type === "strikeout") {
                annotation.title = "Strike-out Title";
                annotation.subject = "Strike-out Subject";
                annotation.content = "This is a strike-out annotation.";
                annotation.stroke = "black";
                annotation.strokeWidth = 2;
                annotation.translateY = obj.height / 2;
            } else if (type === "stamp") {
                annotation.title = "Stamp Title";
                annotation.subject = "Stamp Subject";
                annotation.content = "This is a stamp annotation.";
                annotation.imgSrc = obj.imgSrc; // Ensure the stamp image URL is stored
                annotation.width = obj.width;
                annotation.height = obj.height;
                annotation.fill = obj.fill;
            }


            annotationsByPage[pageNum].push(annotation);
            console.log("Stored Annotation:", annotation);
        }

        function addStamp(stampType) {
            disableTextLayer(); // Disable the text layer
            resetDrawingState();
            isDrawing = true;
            fabricCanvas.isDrawingMode = false; // Disable free drawing mode
            fabricCanvas.selection = false;    // Disable object selection

            let isStampPlaced = false; // Ensure only one stamp is placed per action

            // Define the stamp images (use forward slashes or full URLs)
            const stamps = {
                approve: '/images/Approved.png', // Use relative path
                notApprove: '/images/NotApproved.png',
                right: '/images/Right.png',
                wrong: '/images/Wrong.png'
            };

            // Check if the stamp type is valid
            const selectedStamp = stamps[stampType];
            if (!selectedStamp) {
                console.error("Invalid stamp type selected!");
                isDrawing = false;
                enableTextLayer();
                return;
            }

            // Change the cursor to the selected stamp image
            fabricCanvas.defaultCursor = `url(${selectedStamp}) 16 16, auto`; // Adjust '16 16' to center the cursor

            // Define a single-use event listener for placing the stamp
            const onMouseDown = function (e) {
                if (isStampPlaced) return; // Avoid placing multiple stamps

                const pointer = fabricCanvas.getPointer(e.e); // Get pointer coordinates
                const startX = pointer.x;
                const startY = pointer.y;

                // Create the stamp as an image
                fabric.Image.fromURL(selectedStamp, function (img) {
                    // Set a scale factor for smaller stamps (0.2 means 20% of the original size)
                    const scaleFactor = 0.7; // Adjust this to control the size

                    // Scale the image
                    img.scale(scaleFactor);

                    // Adjust position to center the image at the click point
                    img.set({
                        left: startX - img.width * scaleFactor / 2, // Center horizontally
                        top: startY - img.height * scaleFactor / 2, // Center vertically
                        originX: 'center',
                        originY: 'center',
                        selectable: false, // Disable selection
                        evented: false     // Disable events for this stamp
                    });

                    fabricCanvas.add(img);
                    fabricCanvas.renderAll();
                });

                // Mark stamp as placed, restore cursor, and clean up
                isStampPlaced = true;
                isDrawing = false;
                fabricCanvas.defaultCursor = 'default'; // Reset cursor to default
                fabricCanvas.off('mouse:down', onMouseDown); // Remove listener
                enableTextLayer();
            };

            // Add the event listener for mouse down
            fabricCanvas.on('mouse:down', onMouseDown);
        }

        function addSelectedStamp() {
            const stampType = document.getElementById('stampSelect').value;
            addStamp(stampType);
        }

        function addCloudAnnotation() {
    disableTextLayer();
    resetDrawingState();

    let polygonPoints = [];
    let tempPath = null;
    let isDrawing = false;

    const cloudColor = 'red';
    const cloudStrokeWidth = 2;
    const cloudRadius = 20; // Radius of the cloud arcs
    const cloudFillColor = 'transparent';
    const humpSize = 30; // Target size for each hump (adjustable by user)
    const cloudOverlap = 0.7;  // Define cloud overlap factor

    function cleanupListeners() {
        fabricCanvas.off('mouse:down');
        fabricCanvas.off('mouse:move');
        fabricCanvas.off('mouse:dblclick');
        enableTextLayer();
    }

    // Start or continue drawing on mouse down
    fabricCanvas.on('mouse:down', function (e) {
        const pointer = fabricCanvas.getPointer(e.e);
        if (!isDrawing) {
            isDrawing = true;
            polygonPoints = [new Point(pointer.x, pointer.y)];
        } else {
            polygonPoints.push(new Point(pointer.x, pointer.y));
        }
        updateCloudPreview();
    });

    // Update the cloud preview on mouse move
    fabricCanvas.on('mouse:move', function (e) {
        if (!isDrawing || polygonPoints.length < 1) return;

        const pointer = fabricCanvas.getPointer(e.e);
        const lastPoint = polygonPoints[polygonPoints.length - 1];

        // Update preview only if the mouse has moved
        if (pointer.x !== lastPoint.x || pointer.y !== lastPoint.y) {
            updateCloudPreview(pointer.x, pointer.y);
        }
    });

    // Finalize the annotation on double-click
    fabricCanvas.on('mouse:dblclick', function () {
        if (!isDrawing) return;

        isDrawing = false;

        // Close the path by connecting the last point to the first
        polygonPoints.push(polygonPoints[0]);

        const finalPath = generateCloudPath(polygonPoints, cloudRadius, humpSize);
        const cloudPath = new fabric.Path(finalPath, {
            fill: cloudFillColor,
            stroke: cloudColor,
            strokeWidth: cloudStrokeWidth,
            selectable: true,
            annotationType: 'cloud',
            path: finalPath // Ensure this is the correct string format
        });

        fabricCanvas.add(cloudPath); // Add the finalized cloud annotation

        if (tempPath) fabricCanvas.remove(tempPath); // Remove temporary path
        tempPath = null;
        polygonPoints = [];

        storeAnnotation("cloud", cloudPath); // Save the annotation

        cleanupListeners(); // Remove event listeners

        // Do not start a new cloud recursively, let the user decide when to start a new one
    });

    // Update the cloud preview during dragging
    function updateCloudPreview(tempX, tempY) {
        if (polygonPoints.length < 1) return;

        const previewPoints = [...polygonPoints];
        if (tempX !== undefined && tempY !== undefined) {
            previewPoints.push(new Point(tempX, tempY)); // Add a temporary point for preview
        }

        const pathData = generateCloudPath(previewPoints, cloudRadius, humpSize);
        if (tempPath) fabricCanvas.remove(tempPath);

        tempPath = new fabric.Path(pathData, {
            fill: 'transparent',
            stroke: cloudColor,
            strokeWidth: cloudStrokeWidth,
            selectable: false,
        });

        fabricCanvas.add(tempPath); // Add the updated preview
    }

    function generateCloudPath(points) {
        const pathData = [];
        let prev = points[points.length - 1];
        const delta = 2 * cloudRadius * cloudOverlap;  // Now this is defined
        const circlePoints = [];
        for (let i = 0; i < points.length; i++) {
            const curr = points[i];
            const dx = curr.x - prev.x;
            const dy = curr.y - prev.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            const n = Math.max(1, Math.floor(len / delta));
            const d = len / n;
            for (let j = 0; j <= n; j++) {
                circlePoints.push(new Point(prev.x + j * (dx / n), prev.y + j * (dy / n)));
            }
            prev = curr;
        }
        prev = circlePoints[circlePoints.length - 1];
        for (let i = 0; i < circlePoints.length; i++) {
            const curr = circlePoints[i];
            const angle = intersect(prev, curr, cloudRadius);
            pathData.push(`M ${prev.x} ${prev.y}`);
            pathData.push(`A ${cloudRadius},${cloudRadius} 0 0,1 ${curr.x},${curr.y}`);
            prev = curr;
        }
        return pathData.join(' ');
    }

    function intersect(p, q, r) {
        const dx = q.x - p.x;
        const dy = q.y - p.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        const a = Math.min(Math.max(0.5 * len / r, -1), 1);
        const phi = Math.atan2(dy, dx);
        const gamma = Math.acos(a);
        return [phi - gamma, phi + gamma];
    }

    // Point constructor
    function Point(x, y) {
        this.x = x;
        this.y = y;
    }
}


        function addSquare() {
            disableTextLayer(); // Disable the text layer
            resetDrawingState();
            isDrawing = true;
            fabricCanvas.isDrawingMode = false;  // Disable free drawing mode
            fabricCanvas.selection = true;      // Disable object selection
            let rect; // Declare the rectangle outside of the event handlers
            fabricCanvas.on('mouse:down', function (e) {
                const pointer = fabricCanvas.getPointer(e.e);
                startX = pointer.x;
                startY = pointer.y;
                // Create the rectangle (square annotation) at mouse down
                rect = new fabric.Rect({
                    left: startX,
                    top: startY,
                    width: 0,
                    height: 0,
                    fill: '', // No fill
                    stroke: 'red', // Bright yellow for the border
                    strokeWidth: 2,    // Border thickness
                    annotationType: 'square', // Set type early
                    id: Date.now() + Math.random().toString(36).substr(2, 9),
                });
                fabricCanvas.add(rect);
            });

            fabricCanvas.on('mouse:move', function (e) {
                if (!rect) return;
                const pointer = fabricCanvas.getPointer(e.e);
                rect.set({ width: pointer.x - startX, height: pointer.y - startY });
                fabricCanvas.renderAll();
            });

            fabricCanvas.on('mouse:up', function () {
                if (!rect) return;
                console.log("Square drawn:", rect);

                storeAnnotation('square', rect);
                isDrawing = false;

                fabricCanvas.off('mouse:down');
                fabricCanvas.off('mouse:move');
                fabricCanvas.off('mouse:up');

                enableTextLayer();

            });
        }

        function addLine() {
    disableTextLayer(); // Disable the text layer
    resetDrawingState(); // Reset any active drawing state
    isDrawing = true;
    fabricCanvas.isDrawingMode = false; // Disable free drawing mode
    fabricCanvas.selection = false; // Disable object selection during drawing
    let line; // Placeholder for the line object
    let startX, startY; // Variables to store starting coordinates

    // Mouse Down: Start drawing the line
    const mouseDownHandler = function (e) {
        const pointer = fabricCanvas.getPointer(e.e); // Get mouse position
        startX = pointer.x;
        startY = pointer.y;

        // Create the line object with initial overlapping start and end points
        line = new fabric.Line([startX, startY, startX, startY], {
            stroke: 'red', // Line color
            strokeWidth: 2, // Line thickness
            selectable: false, // Prevent interaction during drawing
            evented: false, // Disable event handling during drawing
            annotationType: 'line', // Custom property for annotation type
            id: Date.now() + Math.random().toString(36).substr(2, 9), // Unique ID
        });

        fabricCanvas.add(line); // Add the line to the canvas
    };

    // Mouse Move: Update the line's endpoint as the mouse moves
    const mouseMoveHandler = function (e) {
        if (!line) return; // Do nothing if the line doesn't exist
        const pointer = fabricCanvas.getPointer(e.e); // Get current mouse position

        // Update the line's end coordinates
        line.set({
            x2: pointer.x,
            y2: pointer.y,
        });

        fabricCanvas.renderAll(); // Redraw the canvas
    };

    // Mouse Up: Finalize the line
    const mouseUpHandler = function () {
        if (!line) return; // Do nothing if the line doesn't exist

        // Ensure the line is interactive after drawing
        line.set({
            selectable: true,
            evented: true,
        });
        line.setCoords(); // Recalculate the line's bounding box for accurate interaction

        console.log("Line drawn:", line); // Debug log

        // Store the line annotation for later use
        storeAnnotation('line', line);

        // Reset state and clean up
        isDrawing = false;
        line = null; // Clear the line object

        // Remove event listeners
        fabricCanvas.off('mouse:down', mouseDownHandler);
        fabricCanvas.off('mouse:move', mouseMoveHandler);
        fabricCanvas.off('mouse:up', mouseUpHandler);

        enableTextLayer(); // Re-enable the text layer
    };

    // Attach event listeners to the canvas
    fabricCanvas.on('mouse:down', mouseDownHandler);
    fabricCanvas.on('mouse:move', mouseMoveHandler);
    fabricCanvas.on('mouse:up', mouseUpHandler);
}


        function addCircle() {
    disableTextLayer(); // Disable the text layer
    resetDrawingState();
    isDrawing = true;
    fabricCanvas.isDrawingMode = false;  // Disable free drawing mode
    fabricCanvas.selection = true;      // Disable object selection
    let circle; // Declare the circle object outside of the event handlers
    let originX, originY; // Store the original coordinates

    fabricCanvas.on('mouse:down', function (e) {
        const pointer = fabricCanvas.getPointer(e.e);
        originX = pointer.x;
        originY = pointer.y;

        // Create the circle annotation at mouse down
        circle = new fabric.Circle({
            left: originX,
            top: originY,
            radius: 0, // Initially zero radius
            fill: '', // No fill
            stroke: '#ff5722', // Bright orange for the border
            strokeWidth: 2,    // Border thickness
            annotationType: 'circle', // Set type early
            id: Date.now() + Math.random().toString(36).substr(2, 9),
            selectable: false,
            evented: false,
        });

        fabricCanvas.add(circle);
    });

    fabricCanvas.on('mouse:move', function (e) {
        if (!circle) return;
        const pointer = fabricCanvas.getPointer(e.e);

        // Calculate the radius based on the distance from the origin
        const radius = Math.sqrt(
            Math.pow(pointer.x - originX, 2) + Math.pow(pointer.y - originY, 2)
        ) / 2;

        // Calculate the center position
        const centerX = (pointer.x + originX) / 2;
        const centerY = (pointer.y + originY) / 2;

        // Adjust circle properties to ensure perfect alignment
        circle.set({
            radius: radius,
            left: centerX - radius,
            top: centerY - radius,
        });

        fabricCanvas.renderAll();
    });

    fabricCanvas.on('mouse:up', function () {
        if (!circle) return;

        // Finalize the circle properties
        circle.setCoords();
        console.log("Circle drawn:", circle);

        // Store annotation data
        storeAnnotation('circle', circle);

        // Reset state
        isDrawing = false;
        circle = null;

        // Clean up event handlers
        fabricCanvas.off('mouse:down');
        fabricCanvas.off('mouse:move');
        fabricCanvas.off('mouse:up');

        enableTextLayer();
    });
}

        function addText() {
            disableTextLayer(); // Disable text layer during interaction
            resetDrawingState();
            isDrawing = true;
            fabricCanvas.isDrawingMode = false;
            fabricCanvas.selection = true;

            let textObj = null, startX = 0, startY = 0;


            // Mouse down - Capture initial click point and create text object
            const mouseDownHandler = function (e) {
                const pointer = fabricCanvas.getPointer(e.e);
                startX = pointer.x;
                startY = pointer.y;


                textObj = new fabric.Textbox('Enter text', {
                    left: startX,
                    top: startY,
                    fontSize: 10,
                    fill: 'black',
                    editable: true,
                    id: `text-${Date.now()}`, // Assign unique ID
                });

                fabricCanvas.add(textObj);
            };

            // Mouse move: Adjust textbox size dynamically
            const mouseMoveHandler = function (e) {
                if (!textObj) return;
                const pointer = fabricCanvas.getPointer(e.e);

                const distance = Math.sqrt(
                    Math.pow(pointer.x - startX, 2) + Math.pow(pointer.y - startY, 2)
                );

                const newFontSize = Math.max(10, Math.min(50, distance / 2));
                textObj.set({ fontSize: newFontSize });
                fabricCanvas.renderAll();
            };

            // Mouse up: Finalize and store the annotation
            const mouseUpHandler = function () {
                if (!textObj) return;

                storeAnnotation('text', textObj);
                // Listen for changes to the text content
                textObj.on('changed', () => {
                    updateStoredAnnotation(textObj.id, { text: textObj.text });
                });
                isDrawing = false;

                fabricCanvas.off('mouse:down', mouseDownHandler);
                fabricCanvas.off('mouse:move', mouseMoveHandler);
                fabricCanvas.off('mouse:up', mouseUpHandler);

                //enableTextLayer();
            };

            // Attach event listeners
            fabricCanvas.on('mouse:down', mouseDownHandler);
            fabricCanvas.on('mouse:move', mouseMoveHandler);
            fabricCanvas.on('mouse:up', mouseUpHandler);
        }

        function updateStoredAnnotation(id, updates) {
            for (let page in annotationsByPage) {
                const annotation = annotationsByPage[page].find(ann => ann.id === id);
                if (annotation) {
                    Object.assign(annotation, updates);

                    // Synchronize content if text is updated
                    if (updates.text) {
                        annotation.content = updates.text;
                    }

                    console.log("Updated Annotation:", annotation);
                    break;
                }
            }
        }

        function addFreeDraw() {
            disableTextLayer(); // Disable the text layer
            resetDrawingState();
            fabricCanvas.isDrawingMode = true; // Enable free drawing mode
            fabricCanvas.freeDrawingBrush.color = "black"; // Set drawing color
            fabricCanvas.freeDrawingBrush.width = 2; // Set brush width
            // Event listener to capture the drawn paths
            fabricCanvas.on("path:created", function (e) {
                const path = e.path;
                storeAnnotation("freeDraw", path);
                const centerX = path.left + path.width / 2;
                const centerY = path.top + path.height / 2;

            });
        }
        document.getElementById('toggle-free-draw').addEventListener('click', enableFreeDraw);
        // Update and store annotations for all object types
        fabricCanvas.on('object:modified', function (e) {
            const obj = e.target;
            if (obj && annotationsByPage[pageNum]) {
                const pageAnnotations = annotationsByPage[pageNum];
                const annotationIndex = pageAnnotations.findIndex(ann => ann.id === obj.id);
                if (annotationIndex !== -1) {
                    const annotation = pageAnnotations[annotationIndex];
                    // Update common properties
                    annotation.x1 = obj.left;
                    annotation.y1 = obj.top;
                    // Update specific properties based on the object type
                    if (obj.type === 'textbox') {
                        annotation.text = obj.text;
                        annotation.x2 = obj.left + obj.width;
                        annotation.y2 = obj.top + obj.height;
                    } else if (obj.type === 'rect') {
                        annotation.x2 = obj.left + obj.width;
                        annotation.y2 = obj.top + obj.height;
                    } else if (obj.type === 'circle') {
                        annotation.radius = obj.radius;
                    } else if (obj.type === 'line') {
                        annotation.x2 = obj.x2;
                        annotation.y2 = obj.y2;
                    }
                    // Save the updated annotation
                    annotationsByPage[pageNum][annotationIndex] = annotation;
                }
            }
        });
        function undo() {
            const objects = fabricCanvas.getObjects();
            if (objects.length > 0) {
                const last = objects[objects.length - 1];
                redoStack.push(last); // Push the removed object to the redo stack
                // Remove the annotation from `annotationsByPage`
                if (annotationsByPage[pageNum]) {
                    annotationsByPage[pageNum] = annotationsByPage[pageNum].filter(ann => ann.id !== last.id);
                }
                fabricCanvas.remove(last);
            }
        }
        function redo() {
            if (redoStack.length > 0) {
                const lastRedo = redoStack.pop();
                fabricCanvas.add(lastRedo);
                if (annotationsByPage[pageNum]) {
                    const annotation = annotationsByPage[pageNum].find(ann => ann.id === lastRedo.id);
                    if (annotation) {
                        annotationsByPage[pageNum].push(annotation);
                    }
                }
            }
        }
        // Assuming fabricCanvas and pageNum are defined in your application
        function save() {
            const annotations = [];
            Object.keys(annotationsByPage).forEach(pageNum => {
                annotations.push(...annotationsByPage[pageNum]);
            });
            // Loop through each object on the canvas
            fabricCanvas.getObjects().forEach(obj => {
                if (!obj.id || annotations.find(ann => ann.id === obj.id)) {
                    return; // Skip objects already stored
                }
                console.log("Object on canvas:", obj); // Debugging output
                // Process different object types and add them to annotations
                if (obj.type === 'textbox') {
                    console.log("Saving textbox object:", obj); // Debugging object
                    annotations.push({
                        type: 'text',
                        page: pageNum,
                        x1: obj.left,
                        y1: obj.top,
                        x2: obj.left + obj.width,
                        y2: obj.top + obj.height,
                        text: obj.text || "Enter Text", // Ensure default text if not set
                        title: "Text",
                        subject: "Text Subject",
                    });
                } else if (obj.annotationType === 'highlight') {
                    annotations.push({
                        type: 'highlight',
                        page: pageNum,
                        x1: obj.left,
                        y1: obj.top,
                        x2: obj.left + obj.width,
                        y2: obj.top + obj.height,
                        fill: obj.fill,
                    });
                } else if (obj.annotationType === 'underline') {
                    annotations.push({
                        type: 'underline',
                        page: pageNum,
                        x1: obj.left,
                        y1: obj.top,
                        x2: obj.left + obj.width,
                        y2: obj.top + obj.height,
                    });
                } else if (obj.annotationType === 'strikeout') {
                    annotations.push({
                        type: 'strikeout',
                        page: pageNum,
                        x1: obj.left,
                        y1: obj.top,
                        x2: obj.left + obj.width,
                        y2: obj.top + obj.height,
                    });
                }
                else if (obj.annotationType === 'square') {
                    annotations.push({
                        id: obj.id,
                        type: 'square',
                        page: pageNum,
                        x1: obj.left,
                        y1: obj.top,
                        x2: obj.left + obj.width,
                        y2: obj.top + obj.height,
                        stroke: obj.stroke,
                        strokeWidth: obj.strokeWidth,
                        title: "Square Annotation",
                        subject: "Square Subject",
                        content: "This is a square annotation."
                    });
                } else if (obj.type === 'circle') {
                    annotations.push({
                        type: 'circle',
                        page: pageNum, // Add the current page number
                        x1: obj.left,
                        y1: obj.top,
                        radius: obj.radius,
                        fill: obj.fill,
                        title: "Circle ",  // Add title
                        subject: "Circle Subject",  // Add subject
                        content: "This is a circle annotation."  // Add content
                    });
                } else if (obj.type === 'line') {
                    annotations.push({
                        type: 'line',
                        page: pageNum, // Add the current page number
                        x1: obj.x1,
                        y1: obj.y1,
                        x2: obj.x2,
                        y2: obj.y2,
                        stroke: obj.stroke,
                        strokeWidth: obj.strokeWidth,
                        title: "Line ",  // Add title
                        subject: "Line Subject",  // Add subject
                        content: "This is a line annotation."  // Add content
                    });
                } else if (obj.type === 'path') {
                    if (obj.annotationType === 'cloud') { // Check for custom annotation type
                        annotations.push({
                            type: 'cloud',
                            page: pageNum,
                            path: obj.path,
                            stroke: obj.stroke,
                            strokeWidth: obj.strokeWidth,
                            title: "Cloud Annotation",
                            subject: "Cloud Subject",
                            content: "This is a cloud annotation.",
                        });
                    } else if (obj.annotationType === 'stamp') {
                        annotations.push({
                            type: 'stamp',
                            page: pageNum,
                            x1: obj.left,
                            y1: obj.top,
                            imgSrc: obj.imgSrc, // Assuming stamp image source
                            width: obj.width,
                            height: obj.height,
                            title: "Stamp",
                            subject: "Stamp Subject",
                            content: "This is a stamp annotation.",
                        });
                    } else {
                        annotations.push({
                            type: 'freeDraw',
                            page: pageNum,
                            path: obj.path,
                            stroke: obj.stroke,
                            strokeWidth: obj.strokeWidth,
                            title: "Free Draw",
                            subject: "Free Draw Subject",
                            content: "This is a free draw annotation.",
                        });
                    }
                }
            });
            // Example logic to save or process annotations
            console.log("Annotations Saved:", annotations);
            // You can replace the above console log with code to save annotations to a database or server
            // Example: send a POST request
            const fileInput = document.getElementById('file-input');
            const reader = new FileReader();
            reader.onload = function (e) {
                const pdfData = e.target.result.split(',')[1];
                fetch('http://127.0.0.1:5000/save', {  // Changed URL to `/save`
                    method: 'POST',
                    body: JSON.stringify({ pdf: pdfData, annotations }),
                    headers: { 'Content-Type': 'application/json' },
                })
                    .then(response => response.blob())
                    .then(blob => {
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'annotated.pdf';
                        a.click();
                        window.URL.revokeObjectURL(url);
                    })
                    .catch(error => {
                        console.error("Error saving PDF:", error);
                    });
            };
            if (fileInput.files.length > 0) {
                reader.readAsDataURL(fileInput.files[0]);
            } else {
                alert("No file selected!");
            }
        }

        fabricCanvasElement.addEventListener('mousedown', (e) => {
            isDrawing = true;
            pdfContext.beginPath();
            pdfContext.moveTo(e.offsetX, e.offsetY);
        });
        fabricCanvasElement.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                pdfContext.lineTo(e.offsetX, e.offsetY);
                pdfContext.stroke();
            }
        });
        fabricCanvasElement.addEventListener('mouseup', () => {
            isDrawing = false;
            pdfContext.closePath();
        });
        console.log("Annotations to be sent:", annotations);
    </script>


<script src="../assets/plugins/jquery/jquery.min.js"></script>
<!-- Bootstrap 4 -->
<script src="../assets/plugins/bootstrap/js/bootstrap.bundle.min.js"></script>

<script src="../assets/plugins/bs-custom-file-input/bs-custom-file-input.min.js"></script>

<!-- AdminLTE App -->
<script src="../assets/js/main.js"></script>
<!-- AdminLTE for demo purposes -->
<script src="../assets/js/demo.js"></script>
<!-- Page specific script -->

<script>
    $(function () {
        bsCustomFileInput.init();
    });
</script>
<script>
    $(document).ready(function () {
        $('[data-toggle="tooltip"]').tooltip();
    });
</script>

</body>
</html>